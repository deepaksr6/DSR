import { Directive, HostBinding, NgModule, Input } from '@angular/core';
import { mkenum } from '../../core/utils';
export const IgxDividerType = mkenum({
    SOLID: 'solid',
    DASHED: 'dashed'
});
let NEXT_ID = 0;
export class IgxDividerDirective {
    constructor() {
        /**
         * Sets/gets the `id` of the divider.
         * If not set, `id` will have value `"igx-divider-0"`;
         * ```html
         * <igx-divider id="my-divider"></igx-divider>
         * ```
         * ```typescript
         * let dividerId =  this.divider.id;
         * ```
         */
        this.id = `igx-divider-${NEXT_ID++}`;
        /**
         * An @Input property that sets the value of the `inset` attribute.
         * If not provided it will be set to `'0'`.
         * ```html
         * <igx-divider inset="16px"></igx-divider>
         * ```
         */
        this._inset = '0';
        /**
         * An @Input property that sets the value of `role` attribute.
         * If not the default value of `separator` will be used.
         */
        this.role = 'separator';
        /**
         * Sets the type of the divider. The default value
         * is `default`. The divider can also be `dashed`;
         * ```html
         * <igx-divider type="dashed"></igx-divider>
         * ```
         */
        this.type = IgxDividerType.SOLID;
        /**
         * An @Input that sets the `middle` attribute of the divider.
         * If set to `true` and an `inset` value has been provided,
         * the divider will start shrinking from both ends.
         * ```html
         * <igx-divider [middle]="true"></igx-divider>
         * ```
         */
        this.middle = false;
        /**
         * An @Input that sets the vertical attribute of the divider.
         * ```html
         * <igx-divider [vertical]="true"></igx-divider>
         * ```
         */
        this.vertical = false;
    }
    get isDashed() {
        return this.type === IgxDividerType.DASHED;
    }
    /**
     * A getter that returns `true` if the type of the divider is `default`;
     * ```typescript
     * const isDefault = this.divider.isDefault;
     * ```
     */
    get isSolid() {
        return this.type === IgxDividerType.SOLID;
    }
    /**
     * Sets the inset of the divider from the side(s).
     * If the divider attribute `middle` is set to `true`,
     * it will inset the divider on both sides.
     * ```typescript
     * this.divider.inset = '32px';
     * ```
     */
    set inset(value) {
        this._inset = value;
    }
    /**
     * Gets the current divider inset in terms of
     * margin representation as applied to the divider.
     * ```typescript
     * const inset = this.divider.inset;
     * ```
     */
    get inset() {
        const baseMargin = '0';
        if (this.middle) {
            if (this.vertical) {
                return `${this._inset} ${baseMargin}`;
            }
            return `${baseMargin} ${this._inset}`;
        }
        else {
            if (this.vertical) {
                return `${this._inset} ${baseMargin} 0 ${baseMargin}`;
            }
            return `${baseMargin} 0 ${baseMargin} ${this._inset}`;
        }
    }
}
IgxDividerDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-divider'
            },] }
];
IgxDividerDirective.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    _inset: [{ type: Input, args: ['inset',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }],
    type: [{ type: HostBinding, args: ['class.igx-divider',] }, { type: Input }],
    isDashed: [{ type: HostBinding, args: ['class.igx-divider--dashed',] }],
    middle: [{ type: HostBinding, args: ['class.igx-divider--inset',] }, { type: Input }],
    vertical: [{ type: HostBinding, args: ['class.igx-divider--vertical',] }, { type: Input }],
    inset: [{ type: HostBinding, args: ['style.margin',] }]
};
export class IgxDividerModule {
}
IgxDividerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxDividerDirective],
                exports: [IgxDividerDirective]
            },] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGl2aWRlci5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiL2hvbWUvcnVubmVyL3dvcmsvaWduaXRldWktYW5ndWxhci9pZ25pdGV1aS1hbmd1bGFyL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjLyIsInNvdXJjZXMiOlsibGliL2RpcmVjdGl2ZXMvZGl2aWRlci9kaXZpZGVyLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3hFLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUUxQyxNQUFNLENBQUMsTUFBTSxjQUFjLEdBQUcsTUFBTSxDQUFDO0lBQ2pDLEtBQUssRUFBRSxPQUFPO0lBQ2QsTUFBTSxFQUFFLFFBQVE7Q0FDbkIsQ0FBQyxDQUFDO0FBR0gsSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDO0FBTWhCLE1BQU0sT0FBTyxtQkFBbUI7SUFKaEM7UUFLSTs7Ozs7Ozs7O1dBU0c7UUFHSSxPQUFFLEdBQUcsZUFBZSxPQUFPLEVBQUUsRUFBRSxDQUFDO1FBR3ZDOzs7Ozs7V0FNRztRQUVLLFdBQU0sR0FBRyxHQUFHLENBQUM7UUFFckI7OztXQUdHO1FBR0ksU0FBSSxHQUFHLFdBQVcsQ0FBQztRQUUxQjs7Ozs7O1dBTUc7UUFHSSxTQUFJLEdBQTRCLGNBQWMsQ0FBQyxLQUFLLENBQUM7UUFPNUQ7Ozs7Ozs7V0FPRztRQUdJLFdBQU0sR0FBRyxLQUFLLENBQUM7UUFZdEI7Ozs7O1dBS0c7UUFHSSxhQUFRLEdBQUcsS0FBSyxDQUFDO0lBcUM1QixDQUFDO0lBeEVHLElBQ0ksUUFBUTtRQUNSLE9BQU8sSUFBSSxDQUFDLElBQUksS0FBSyxjQUFjLENBQUMsTUFBTSxDQUFDO0lBQy9DLENBQUM7SUFjRDs7Ozs7T0FLRztJQUNILElBQUksT0FBTztRQUNQLE9BQU8sSUFBSSxDQUFDLElBQUksS0FBSyxjQUFjLENBQUMsS0FBSyxDQUFDO0lBQzlDLENBQUM7SUFZRDs7Ozs7OztPQU9HO0lBQ0gsSUFDSSxLQUFLLENBQUMsS0FBYTtRQUNuQixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztJQUN4QixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsSUFBSSxLQUFLO1FBQ0wsTUFBTSxVQUFVLEdBQUcsR0FBRyxDQUFDO1FBRXZCLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNiLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDZixPQUFPLEdBQUcsSUFBSSxDQUFDLE1BQU0sSUFBSSxVQUFVLEVBQUUsQ0FBQzthQUN6QztZQUNELE9BQU8sR0FBRyxVQUFVLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1NBQ3pDO2FBQU07WUFDSCxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0JBQ2YsT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLElBQUksVUFBVSxNQUFNLFVBQVUsRUFBRSxDQUFDO2FBQ3pEO1lBQ0QsT0FBTyxHQUFHLFVBQVUsTUFBTSxVQUFVLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1NBQ3pEO0lBQ0wsQ0FBQzs7O1lBeEhKLFNBQVMsU0FBQztnQkFDUCw4Q0FBOEM7Z0JBQzlDLFFBQVEsRUFBRSxhQUFhO2FBQzFCOzs7aUJBWUksV0FBVyxTQUFDLFNBQVMsY0FDckIsS0FBSztxQkFXTCxLQUFLLFNBQUMsT0FBTzttQkFPYixXQUFXLFNBQUMsV0FBVyxjQUN2QixLQUFLO21CQVVMLFdBQVcsU0FBQyxtQkFBbUIsY0FDL0IsS0FBSzt1QkFHTCxXQUFXLFNBQUMsMkJBQTJCO3FCQWF2QyxXQUFXLFNBQUMsMEJBQTBCLGNBQ3RDLEtBQUs7dUJBbUJMLFdBQVcsU0FBQyw2QkFBNkIsY0FDekMsS0FBSztvQkFXTCxXQUFXLFNBQUMsY0FBYzs7QUFpQy9CLE1BQU0sT0FBTyxnQkFBZ0I7OztZQUo1QixRQUFRLFNBQUM7Z0JBQ04sWUFBWSxFQUFFLENBQUMsbUJBQW1CLENBQUM7Z0JBQ25DLE9BQU8sRUFBRSxDQUFDLG1CQUFtQixDQUFDO2FBQ2pDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBIb3N0QmluZGluZywgTmdNb2R1bGUsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBta2VudW0gfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcblxuZXhwb3J0IGNvbnN0IElneERpdmlkZXJUeXBlID0gbWtlbnVtKHtcbiAgICBTT0xJRDogJ3NvbGlkJyxcbiAgICBEQVNIRUQ6ICdkYXNoZWQnXG59KTtcbmV4cG9ydCB0eXBlIElneERpdmlkZXJUeXBlID0gKHR5cGVvZiBJZ3hEaXZpZGVyVHlwZSlba2V5b2YgdHlwZW9mIElneERpdmlkZXJUeXBlXTtcblxubGV0IE5FWFRfSUQgPSAwO1xuXG5ARGlyZWN0aXZlKHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6ZGlyZWN0aXZlLXNlbGVjdG9yXG4gICAgc2VsZWN0b3I6ICdpZ3gtZGl2aWRlcidcbn0pXG5leHBvcnQgY2xhc3MgSWd4RGl2aWRlckRpcmVjdGl2ZSB7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBgaWRgIG9mIHRoZSBkaXZpZGVyLlxuICAgICAqIElmIG5vdCBzZXQsIGBpZGAgd2lsbCBoYXZlIHZhbHVlIGBcImlneC1kaXZpZGVyLTBcImA7XG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZGl2aWRlciBpZD1cIm15LWRpdmlkZXJcIj48L2lneC1kaXZpZGVyPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgZGl2aWRlcklkID0gIHRoaXMuZGl2aWRlci5pZDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuaWQnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlkID0gYGlneC1kaXZpZGVyLSR7TkVYVF9JRCsrfWA7XG5cblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHZhbHVlIG9mIHRoZSBgaW5zZXRgIGF0dHJpYnV0ZS5cbiAgICAgKiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBzZXQgdG8gYCcwJ2AuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZGl2aWRlciBpbnNldD1cIjE2cHhcIj48L2lneC1kaXZpZGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgnaW5zZXQnKVxuICAgIHByaXZhdGUgX2luc2V0ID0gJzAnO1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdmFsdWUgb2YgYHJvbGVgIGF0dHJpYnV0ZS5cbiAgICAgKiBJZiBub3QgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYHNlcGFyYXRvcmAgd2lsbCBiZSB1c2VkLlxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5yb2xlJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyByb2xlID0gJ3NlcGFyYXRvcic7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0eXBlIG9mIHRoZSBkaXZpZGVyLiBUaGUgZGVmYXVsdCB2YWx1ZVxuICAgICAqIGlzIGBkZWZhdWx0YC4gVGhlIGRpdmlkZXIgY2FuIGFsc28gYmUgYGRhc2hlZGA7XG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZGl2aWRlciB0eXBlPVwiZGFzaGVkXCI+PC9pZ3gtZGl2aWRlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1kaXZpZGVyJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB0eXBlOiBJZ3hEaXZpZGVyVHlwZSB8IHN0cmluZyA9IElneERpdmlkZXJUeXBlLlNPTElEO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtZGl2aWRlci0tZGFzaGVkJylcbiAgICBnZXQgaXNEYXNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IElneERpdmlkZXJUeXBlLkRBU0hFRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgdGhhdCBzZXRzIHRoZSBgbWlkZGxlYCBhdHRyaWJ1dGUgb2YgdGhlIGRpdmlkZXIuXG4gICAgICogSWYgc2V0IHRvIGB0cnVlYCBhbmQgYW4gYGluc2V0YCB2YWx1ZSBoYXMgYmVlbiBwcm92aWRlZCxcbiAgICAgKiB0aGUgZGl2aWRlciB3aWxsIHN0YXJ0IHNocmlua2luZyBmcm9tIGJvdGggZW5kcy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1kaXZpZGVyIFttaWRkbGVdPVwidHJ1ZVwiPjwvaWd4LWRpdmlkZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtZGl2aWRlci0taW5zZXQnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIG1pZGRsZSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQSBnZXR0ZXIgdGhhdCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdHlwZSBvZiB0aGUgZGl2aWRlciBpcyBgZGVmYXVsdGA7XG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGlzRGVmYXVsdCA9IHRoaXMuZGl2aWRlci5pc0RlZmF1bHQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGlzU29saWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IElneERpdmlkZXJUeXBlLlNPTElEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCB0aGF0IHNldHMgdGhlIHZlcnRpY2FsIGF0dHJpYnV0ZSBvZiB0aGUgZGl2aWRlci5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1kaXZpZGVyIFt2ZXJ0aWNhbF09XCJ0cnVlXCI+PC9pZ3gtZGl2aWRlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1kaXZpZGVyLS12ZXJ0aWNhbCcpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdmVydGljYWwgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGluc2V0IG9mIHRoZSBkaXZpZGVyIGZyb20gdGhlIHNpZGUocykuXG4gICAgICogSWYgdGhlIGRpdmlkZXIgYXR0cmlidXRlIGBtaWRkbGVgIGlzIHNldCB0byBgdHJ1ZWAsXG4gICAgICogaXQgd2lsbCBpbnNldCB0aGUgZGl2aWRlciBvbiBib3RoIHNpZGVzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmRpdmlkZXIuaW5zZXQgPSAnMzJweCc7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5tYXJnaW4nKVxuICAgIHNldCBpbnNldCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX2luc2V0ID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBkaXZpZGVyIGluc2V0IGluIHRlcm1zIG9mXG4gICAgICogbWFyZ2luIHJlcHJlc2VudGF0aW9uIGFzIGFwcGxpZWQgdG8gdGhlIGRpdmlkZXIuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGluc2V0ID0gdGhpcy5kaXZpZGVyLmluc2V0O1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBpbnNldCgpIHtcbiAgICAgICAgY29uc3QgYmFzZU1hcmdpbiA9ICcwJztcblxuICAgICAgICBpZiAodGhpcy5taWRkbGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuX2luc2V0fSAke2Jhc2VNYXJnaW59YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgJHtiYXNlTWFyZ2lufSAke3RoaXMuX2luc2V0fWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy52ZXJ0aWNhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLl9pbnNldH0gJHtiYXNlTWFyZ2lufSAwICR7YmFzZU1hcmdpbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGAke2Jhc2VNYXJnaW59IDAgJHtiYXNlTWFyZ2lufSAke3RoaXMuX2luc2V0fWA7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbSWd4RGl2aWRlckRpcmVjdGl2ZV0sXG4gICAgZXhwb3J0czogW0lneERpdmlkZXJEaXJlY3RpdmVdXG59KVxuZXhwb3J0IGNsYXNzIElneERpdmlkZXJNb2R1bGUgeyB9XG4iXX0=