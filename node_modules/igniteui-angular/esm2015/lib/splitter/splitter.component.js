import { Component, Input, ContentChildren, HostBinding } from '@angular/core';
import { IgxSplitterPaneComponent } from './splitter-pane/splitter-pane.component';
/**
 * An enumeration that defines the `SplitterComponent` panes orientation.
 */
export var SplitterType;
(function (SplitterType) {
    SplitterType[SplitterType["Horizontal"] = 0] = "Horizontal";
    SplitterType[SplitterType["Vertical"] = 1] = "Vertical";
})(SplitterType || (SplitterType = {}));
/**
 * Provides a framework for a simple layout, splitting the view horizontally or vertically
 * into multiple smaller resizable and collapsible areas.
 * @igxModule IgxSplitterModule
 *
 * @igxParent Layouts
 *
 * @igxTheme igx-splitter-theme
 *
 * @igxKeywords splitter panes layout
 *
 * @igxGroup presentation
 *
 * @example
 * ```html
 * <igx-splitter>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 * </igx-splitter>
 * ```
 */
export class IgxSplitterComponent {
    constructor() {
        this._type = SplitterType.Horizontal;
        /**
         * @hidden @internal
         * Gets/Sets the `overflow` property of the current splitter.
         */
        this.overflow = 'hidden';
        /**
         * @hidden @internal
         * Sets/Gets the `display` property of the current splitter.
         */
        this.display = 'flex';
    }
    /**
     * Gets/Sets the splitter orientation.
     * @example
     * ```html
     * <igx-splitter [type]="type">...</igx-splitter>
     * ```
     */
    get type() {
        return this._type;
    }
    set type(value) {
        this._type = value;
        if (this.panes) {
            // if type is changed runtime, should reset sizes.
            this.panes.forEach(x => x.size = 'auto');
        }
    }
    /**
     * @hidden @internal
     * Gets the `flex-direction` property of the current `SplitterComponent`.
     */
    get direction() {
        return this.type === SplitterType.Horizontal ? 'row' : 'column';
    }
    /** @hidden @internal */
    ngAfterContentInit() {
        this.panes.forEach(pane => pane.owner = this);
        this.assignFlexOrder();
        this.panes.changes.subscribe(() => {
            this.panes.forEach(pane => pane.owner = this);
            this.assignFlexOrder();
        });
    }
    /**
     * @hidden @internal
     * This method performs  initialization logic when the user starts dragging the splitter bar between each pair of panes.
     * @param pane - the main pane associated with the currently dragged bar.
     */
    onMoveStart(pane) {
        const panes = this.panes.toArray();
        this.pane = pane;
        this.sibling = panes[panes.indexOf(this.pane) + 1];
        const paneRect = this.pane.element.getBoundingClientRect();
        this.initialPaneSize = this.type === SplitterType.Horizontal ? paneRect.width : paneRect.height;
        if (this.pane.size === 'auto') {
            this.pane.size = this.type === SplitterType.Horizontal ? paneRect.width : paneRect.height;
        }
        const siblingRect = this.sibling.element.getBoundingClientRect();
        this.initialSiblingSize = this.type === SplitterType.Horizontal ? siblingRect.width : siblingRect.height;
        if (this.sibling.size === 'auto') {
            this.sibling.size = this.type === SplitterType.Horizontal ? siblingRect.width : siblingRect.height;
        }
    }
    /**
     * @hidden @internal
     * This method performs calculations concerning the sizes of each pair of panes when the bar between them is dragged.
     * @param delta - The difference along the X (or Y) axis between the initial and the current point when dragging the bar.
     */
    onMoving(delta) {
        const min = parseInt(this.pane.minSize, 10) || 0;
        const max = parseInt(this.pane.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const minSibling = parseInt(this.sibling.minSize, 10) || 0;
        const maxSibling = parseInt(this.sibling.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const paneSize = this.initialPaneSize - delta;
        const siblingSize = this.initialSiblingSize + delta;
        if (paneSize < min || paneSize > max || siblingSize < minSibling || siblingSize > maxSibling) {
            return;
        }
        this.pane.size = paneSize + 'px';
        this.sibling.size = siblingSize + 'px';
    }
    /**
     * @hidden @internal
     * This method assigns the order of each pane.
     */
    assignFlexOrder() {
        let k = 0;
        this.panes.forEach((pane) => {
            pane.order = k;
            k += 2;
        });
    }
    /** @hidden @internal */
    getPaneSiblingsByOrder(order, barIndex) {
        const panes = this.panes.toArray();
        const prevPane = panes[order - barIndex - 1];
        const nextPane = panes[order - barIndex];
        const siblings = [prevPane, nextPane];
        return siblings;
    }
}
IgxSplitterComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-splitter',
                template: "<ng-content select=\"igx-splitter-pane\"></ng-content>\n<ng-container *ngFor=\"let pane of panes; let last = last; let index= index;\">\n    <igx-splitter-bar *ngIf=\"!last\" [order]='pane.order + 1' role='separator'\n                    [type]=\"type\"\n                    [pane]=\"pane\"\n                    [siblings]='getPaneSiblingsByOrder(pane.order + 1, index)'\n                    (moveStart)=\"onMoveStart($event)\"\n                    (moving)=\"onMoving($event)\">\n    </igx-splitter-bar>\n</ng-container>\n"
            },] }
];
IgxSplitterComponent.propDecorators = {
    type: [{ type: Input }],
    panes: [{ type: ContentChildren, args: [IgxSplitterPaneComponent, { read: IgxSplitterPaneComponent },] }],
    direction: [{ type: HostBinding, args: ['style.flex-direction',] }],
    overflow: [{ type: HostBinding, args: ['style.overflow',] }],
    display: [{ type: HostBinding, args: ['style.display',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BsaXR0ZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Ii9ob21lL3J1bm5lci93b3JrL2lnbml0ZXVpLWFuZ3VsYXIvaWduaXRldWktYW5ndWxhci9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy8iLCJzb3VyY2VzIjpbImxpYi9zcGxpdHRlci9zcGxpdHRlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBYSxLQUFLLEVBQUUsZUFBZSxFQUFvQixXQUFXLEVBQXdCLE1BQU0sZUFBZSxDQUFDO0FBQ2xJLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHlDQUF5QyxDQUFDO0FBRW5GOztHQUVHO0FBQ0gsTUFBTSxDQUFOLElBQVksWUFHWDtBQUhELFdBQVksWUFBWTtJQUNwQiwyREFBVSxDQUFBO0lBQ1YsdURBQVEsQ0FBQTtBQUNaLENBQUMsRUFIVyxZQUFZLEtBQVosWUFBWSxRQUd2QjtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F3Qkc7QUFLSCxNQUFNLE9BQU8sb0JBQW9CO0lBSmpDO1FBS1ksVUFBSyxHQUFpQixZQUFZLENBQUMsVUFBVSxDQUFDO1FBdUN0RDs7O1dBR0c7UUFFSSxhQUFRLEdBQUcsUUFBUSxDQUFDO1FBRTNCOzs7V0FHRztRQUVJLFlBQU8sR0FBRyxNQUFNLENBQUM7SUFvRzVCLENBQUM7SUF0Skc7Ozs7OztPQU1HO0lBQ0gsSUFDSSxJQUFJO1FBQ0osT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ3RCLENBQUM7SUFDRCxJQUFJLElBQUksQ0FBQyxLQUFLO1FBQ1YsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ1osa0RBQWtEO1lBQ2xELElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsQ0FBQztTQUM1QztJQUNMLENBQUM7SUFZRDs7O09BR0c7SUFDSCxJQUNXLFNBQVM7UUFDaEIsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLFlBQVksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDO0lBQ3BFLENBQUM7SUF3Q0Qsd0JBQXdCO0lBQ2pCLGtCQUFrQjtRQUNyQixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUM7UUFDOUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7WUFDOUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDO1lBQzlDLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUMzQixDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksV0FBVyxDQUFDLElBQThCO1FBQzdDLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDbkMsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFFbkQsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMscUJBQXFCLEVBQUUsQ0FBQztRQUMzRCxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxJQUFJLEtBQUssWUFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQztRQUNoRyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sRUFBRTtZQUMzQixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxLQUFLLFlBQVksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUM7U0FDN0Y7UUFFRCxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO1FBQ2pFLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLENBQUMsSUFBSSxLQUFLLFlBQVksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUM7UUFDekcsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksS0FBSyxNQUFNLEVBQUU7WUFDOUIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksS0FBSyxZQUFZLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDO1NBQ3RHO0lBQ0wsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxRQUFRLENBQUMsS0FBYTtRQUN6QixNQUFNLEdBQUcsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2pELE1BQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQztRQUM5RixNQUFNLFVBQVUsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzNELE1BQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQztRQUV4RyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsZUFBZSxHQUFHLEtBQUssQ0FBQztRQUM5QyxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsS0FBSyxDQUFDO1FBQ3BELElBQUksUUFBUSxHQUFHLEdBQUcsSUFBSSxRQUFRLEdBQUcsR0FBRyxJQUFJLFdBQVcsR0FBRyxVQUFVLElBQUksV0FBVyxHQUFHLFVBQVUsRUFBRTtZQUMxRixPQUFPO1NBQ1Y7UUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLFdBQVcsR0FBRyxJQUFJLENBQUM7SUFDM0MsQ0FBQztJQUVEOzs7T0FHRztJQUNLLGVBQWU7UUFDbkIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1YsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUE4QixFQUFFLEVBQUU7WUFDbEQsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7WUFDZixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ1gsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQsd0JBQXdCO0lBQ2pCLHNCQUFzQixDQUFDLEtBQWEsRUFBRSxRQUFnQjtRQUN6RCxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ25DLE1BQU0sUUFBUSxHQUFHLEtBQUssQ0FBQyxLQUFLLEdBQUcsUUFBUSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQzdDLE1BQU0sUUFBUSxHQUFHLEtBQUssQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLENBQUM7UUFDekMsTUFBTSxRQUFRLEdBQUcsQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDdEMsT0FBTyxRQUFRLENBQUM7SUFDcEIsQ0FBQzs7O1lBM0pKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsY0FBYztnQkFDeEIsdWhCQUF3QzthQUMzQzs7O21CQVVJLEtBQUs7b0JBbUJMLGVBQWUsU0FBQyx3QkFBd0IsRUFBRSxFQUFFLElBQUksRUFBRSx3QkFBd0IsRUFBRTt3QkFPNUUsV0FBVyxTQUFDLHNCQUFzQjt1QkFTbEMsV0FBVyxTQUFDLGdCQUFnQjtzQkFPNUIsV0FBVyxTQUFDLGVBQWUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIFF1ZXJ5TGlzdCwgSW5wdXQsIENvbnRlbnRDaGlsZHJlbiwgQWZ0ZXJDb250ZW50SW5pdCwgSG9zdEJpbmRpbmcsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQgfSBmcm9tICcuL3NwbGl0dGVyLXBhbmUvc3BsaXR0ZXItcGFuZS5jb21wb25lbnQnO1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIHRoYXQgZGVmaW5lcyB0aGUgYFNwbGl0dGVyQ29tcG9uZW50YCBwYW5lcyBvcmllbnRhdGlvbi5cbiAqL1xuZXhwb3J0IGVudW0gU3BsaXR0ZXJUeXBlIHtcbiAgICBIb3Jpem9udGFsLFxuICAgIFZlcnRpY2FsXG59XG5cbi8qKlxuICogUHJvdmlkZXMgYSBmcmFtZXdvcmsgZm9yIGEgc2ltcGxlIGxheW91dCwgc3BsaXR0aW5nIHRoZSB2aWV3IGhvcml6b250YWxseSBvciB2ZXJ0aWNhbGx5XG4gKiBpbnRvIG11bHRpcGxlIHNtYWxsZXIgcmVzaXphYmxlIGFuZCBjb2xsYXBzaWJsZSBhcmVhcy5cbiAqIEBpZ3hNb2R1bGUgSWd4U3BsaXR0ZXJNb2R1bGVcbiAqXG4gKiBAaWd4UGFyZW50IExheW91dHNcbiAqXG4gKiBAaWd4VGhlbWUgaWd4LXNwbGl0dGVyLXRoZW1lXG4gKlxuICogQGlneEtleXdvcmRzIHNwbGl0dGVyIHBhbmVzIGxheW91dFxuICpcbiAqIEBpZ3hHcm91cCBwcmVzZW50YXRpb25cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgaHRtbFxuICogPGlneC1zcGxpdHRlcj5cbiAqICA8aWd4LXNwbGl0dGVyLXBhbmU+XG4gKiAgICAgIC4uLlxuICogIDwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gKiAgPGlneC1zcGxpdHRlci1wYW5lPlxuICogICAgICAuLi5cbiAqICA8L2lneC1zcGxpdHRlci1wYW5lPlxuICogPC9pZ3gtc3BsaXR0ZXI+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtc3BsaXR0ZXInLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9zcGxpdHRlci5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgSWd4U3BsaXR0ZXJDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcbiAgICBwcml2YXRlIF90eXBlOiBTcGxpdHRlclR5cGUgPSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbDtcbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgdGhlIHNwbGl0dGVyIG9yaWVudGF0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc3BsaXR0ZXIgW3R5cGVdPVwidHlwZVwiPi4uLjwvaWd4LXNwbGl0dGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgIH1cbiAgICBzZXQgdHlwZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl90eXBlID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLnBhbmVzKSB7XG4gICAgICAgICAgICAvLyBpZiB0eXBlIGlzIGNoYW5nZWQgcnVudGltZSwgc2hvdWxkIHJlc2V0IHNpemVzLlxuICAgICAgICAgICAgdGhpcy5wYW5lcy5mb3JFYWNoKHggPT4geC5zaXplID0gJ2F1dG8nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxpc3Qgb2Ygc3BsaXR0ZXIgcGFuZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgcGFuZXMgPSB0aGlzLnNwbGl0dGVyLnBhbmVzO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGRyZW4oSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50LCB7IHJlYWQ6IElneFNwbGl0dGVyUGFuZUNvbXBvbmVudCB9KVxuICAgIHB1YmxpYyBwYW5lcyE6IFF1ZXJ5TGlzdDxJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQ+O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBHZXRzIHRoZSBgZmxleC1kaXJlY3Rpb25gIHByb3BlcnR5IG9mIHRoZSBjdXJyZW50IGBTcGxpdHRlckNvbXBvbmVudGAuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5mbGV4LWRpcmVjdGlvbicpXG4gICAgcHVibGljIGdldCBkaXJlY3Rpb24oKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWwgPyAncm93JyA6ICdjb2x1bW4nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogR2V0cy9TZXRzIHRoZSBgb3ZlcmZsb3dgIHByb3BlcnR5IG9mIHRoZSBjdXJyZW50IHNwbGl0dGVyLlxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUub3ZlcmZsb3cnKVxuICAgIHB1YmxpYyBvdmVyZmxvdyA9ICdoaWRkZW4nO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBTZXRzL0dldHMgdGhlIGBkaXNwbGF5YCBwcm9wZXJ0eSBvZiB0aGUgY3VycmVudCBzcGxpdHRlci5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLmRpc3BsYXknKVxuICAgIHB1YmxpYyBkaXNwbGF5ID0gJ2ZsZXgnO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBBIGZpZWxkIHRoYXQgaG9sZHMgdGhlIGluaXRpYWwgc2l6ZSBvZiB0aGUgbWFpbiBgSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50YCBpbiBlYWNoIHBhaXIgb2YgcGFuZXMgZGl2aWRlZCBieSBhIHNwbGl0dGVyIGJhci5cbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRpYWxQYW5lU2l6ZSE6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogQSBmaWVsZCB0aGF0IGhvbGRzIHRoZSBpbml0aWFsIHNpemUgb2YgdGhlIHNpYmxpbmcgcGFuZSBpbiBlYWNoIHBhaXIgb2YgcGFuZXMgZGl2aWRlZCBieSBhIGdyaXBwZXIuXG4gICAgICogQG1lbWJlcm9mIFNwbGl0dGVyQ29tcG9uZW50XG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0aWFsU2libGluZ1NpemUhOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIFRoZSBtYWluIHBhbmUgaW4gZWFjaCBwYWlyIG9mIHBhbmVzIGRpdmlkZWQgYnkgYSBncmlwcGVyLlxuICAgICAqL1xuICAgIHByaXZhdGUgcGFuZSE6IElneFNwbGl0dGVyUGFuZUNvbXBvbmVudDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaWJsaW5nIHBhbmUgaW4gZWFjaCBwYWlyIG9mIHBhbmVzIGRpdmlkZWQgYnkgYSBzcGxpdHRlciBiYXIuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzaWJsaW5nITogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50O1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wYW5lcy5mb3JFYWNoKHBhbmUgPT4gcGFuZS5vd25lciA9IHRoaXMpO1xuICAgICAgICB0aGlzLmFzc2lnbkZsZXhPcmRlcigpO1xuICAgICAgICB0aGlzLnBhbmVzLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFuZXMuZm9yRWFjaChwYW5lID0+IHBhbmUub3duZXIgPSB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuYXNzaWduRmxleE9yZGVyKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogVGhpcyBtZXRob2QgcGVyZm9ybXMgIGluaXRpYWxpemF0aW9uIGxvZ2ljIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBzcGxpdHRlciBiYXIgYmV0d2VlbiBlYWNoIHBhaXIgb2YgcGFuZXMuXG4gICAgICogQHBhcmFtIHBhbmUgLSB0aGUgbWFpbiBwYW5lIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudGx5IGRyYWdnZWQgYmFyLlxuICAgICAqL1xuICAgIHB1YmxpYyBvbk1vdmVTdGFydChwYW5lOiBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQpIHtcbiAgICAgICAgY29uc3QgcGFuZXMgPSB0aGlzLnBhbmVzLnRvQXJyYXkoKTtcbiAgICAgICAgdGhpcy5wYW5lID0gcGFuZTtcbiAgICAgICAgdGhpcy5zaWJsaW5nID0gcGFuZXNbcGFuZXMuaW5kZXhPZih0aGlzLnBhbmUpICsgMV07XG5cbiAgICAgICAgY29uc3QgcGFuZVJlY3QgPSB0aGlzLnBhbmUuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsUGFuZVNpemUgPSB0aGlzLnR5cGUgPT09IFNwbGl0dGVyVHlwZS5Ib3Jpem9udGFsID8gcGFuZVJlY3Qud2lkdGggOiBwYW5lUmVjdC5oZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLnBhbmUuc2l6ZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICB0aGlzLnBhbmUuc2l6ZSA9IHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWwgPyBwYW5lUmVjdC53aWR0aCA6IHBhbmVSZWN0LmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNpYmxpbmdSZWN0ID0gdGhpcy5zaWJsaW5nLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbFNpYmxpbmdTaXplID0gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCA/IHNpYmxpbmdSZWN0LndpZHRoIDogc2libGluZ1JlY3QuaGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5zaWJsaW5nLnNpemUgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgdGhpcy5zaWJsaW5nLnNpemUgPSB0aGlzLnR5cGUgPT09IFNwbGl0dGVyVHlwZS5Ib3Jpem9udGFsID8gc2libGluZ1JlY3Qud2lkdGggOiBzaWJsaW5nUmVjdC5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zIGNhbGN1bGF0aW9ucyBjb25jZXJuaW5nIHRoZSBzaXplcyBvZiBlYWNoIHBhaXIgb2YgcGFuZXMgd2hlbiB0aGUgYmFyIGJldHdlZW4gdGhlbSBpcyBkcmFnZ2VkLlxuICAgICAqIEBwYXJhbSBkZWx0YSAtIFRoZSBkaWZmZXJlbmNlIGFsb25nIHRoZSBYIChvciBZKSBheGlzIGJldHdlZW4gdGhlIGluaXRpYWwgYW5kIHRoZSBjdXJyZW50IHBvaW50IHdoZW4gZHJhZ2dpbmcgdGhlIGJhci5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25Nb3ZpbmcoZGVsdGE6IG51bWJlcikge1xuICAgICAgICBjb25zdCBtaW4gPSBwYXJzZUludCh0aGlzLnBhbmUubWluU2l6ZSwgMTApIHx8IDA7XG4gICAgICAgIGNvbnN0IG1heCA9IHBhcnNlSW50KHRoaXMucGFuZS5tYXhTaXplLCAxMCkgfHwgdGhpcy5pbml0aWFsUGFuZVNpemUgKyB0aGlzLmluaXRpYWxTaWJsaW5nU2l6ZTtcbiAgICAgICAgY29uc3QgbWluU2libGluZyA9IHBhcnNlSW50KHRoaXMuc2libGluZy5taW5TaXplLCAxMCkgfHwgMDtcbiAgICAgICAgY29uc3QgbWF4U2libGluZyA9IHBhcnNlSW50KHRoaXMuc2libGluZy5tYXhTaXplLCAxMCkgfHwgdGhpcy5pbml0aWFsUGFuZVNpemUgKyB0aGlzLmluaXRpYWxTaWJsaW5nU2l6ZTtcblxuICAgICAgICBjb25zdCBwYW5lU2l6ZSA9IHRoaXMuaW5pdGlhbFBhbmVTaXplIC0gZGVsdGE7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdTaXplID0gdGhpcy5pbml0aWFsU2libGluZ1NpemUgKyBkZWx0YTtcbiAgICAgICAgaWYgKHBhbmVTaXplIDwgbWluIHx8IHBhbmVTaXplID4gbWF4IHx8IHNpYmxpbmdTaXplIDwgbWluU2libGluZyB8fCBzaWJsaW5nU2l6ZSA+IG1heFNpYmxpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGFuZS5zaXplID0gcGFuZVNpemUgKyAncHgnO1xuICAgICAgICB0aGlzLnNpYmxpbmcuc2l6ZSA9IHNpYmxpbmdTaXplICsgJ3B4JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIFRoaXMgbWV0aG9kIGFzc2lnbnMgdGhlIG9yZGVyIG9mIGVhY2ggcGFuZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGFzc2lnbkZsZXhPcmRlcigpIHtcbiAgICAgICAgbGV0IGsgPSAwO1xuICAgICAgICB0aGlzLnBhbmVzLmZvckVhY2goKHBhbmU6IElneFNwbGl0dGVyUGFuZUNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgcGFuZS5vcmRlciA9IGs7XG4gICAgICAgICAgICBrICs9IDI7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBnZXRQYW5lU2libGluZ3NCeU9yZGVyKG9yZGVyOiBudW1iZXIsIGJhckluZGV4OiBudW1iZXIpOiBBcnJheTxJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQ+IHtcbiAgICAgICAgY29uc3QgcGFuZXMgPSB0aGlzLnBhbmVzLnRvQXJyYXkoKTtcbiAgICAgICAgY29uc3QgcHJldlBhbmUgPSBwYW5lc1tvcmRlciAtIGJhckluZGV4IC0gMV07XG4gICAgICAgIGNvbnN0IG5leHRQYW5lID0gcGFuZXNbb3JkZXIgLSBiYXJJbmRleF07XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gW3ByZXZQYW5lLCBuZXh0UGFuZV07XG4gICAgICAgIHJldHVybiBzaWJsaW5ncztcbiAgICB9XG59XG4iXX0=