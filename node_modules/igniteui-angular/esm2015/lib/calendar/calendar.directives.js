/**
 * This file contains all the directives used by the @link IgxCalendarComponent.
 * Except for the directives which are used for templating the calendar itself
 * you should generally not use them directly.
 * @preferred
 */
import { Directive, EventEmitter, HostBinding, HostListener, Input, Output, TemplateRef, ElementRef, NgZone } from '@angular/core';
import { fromEvent, Subject, interval } from 'rxjs';
import { takeUntil, debounce, tap } from 'rxjs/operators';
/**
 * @hidden
 */
export class IgxCalendarYearDirective {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.onYearSelection = new EventEmitter();
    }
    get defaultCSS() {
        return !this.isCurrentYear;
    }
    get currentCSS() {
        return this.isCurrentYear;
    }
    get role() {
        return this.isCurrentYear ? 'spinbutton' : null;
    }
    get valuenow() {
        return this.isCurrentYear ? this.date.getFullYear() : null;
    }
    get tabIndex() {
        return this.isCurrentYear ? 0 : -1;
    }
    get isCurrentYear() {
        return this.date.getFullYear() === this.value.getFullYear();
    }
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    onClick() {
        this.onYearSelection.emit(this.value);
    }
}
IgxCalendarYearDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCalendarYear]'
            },] }
];
IgxCalendarYearDirective.ctorParameters = () => [
    { type: ElementRef }
];
IgxCalendarYearDirective.propDecorators = {
    value: [{ type: Input, args: ['igxCalendarYear',] }],
    date: [{ type: Input }],
    onYearSelection: [{ type: Output }],
    defaultCSS: [{ type: HostBinding, args: ['class.igx-calendar__year',] }],
    currentCSS: [{ type: HostBinding, args: ['class.igx-calendar__year--current',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    valuenow: [{ type: HostBinding, args: ['attr.aria-valuenow',] }],
    tabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
export class IgxCalendarMonthDirective {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.onMonthSelection = new EventEmitter();
    }
    get defaultCSS() {
        return !this.isCurrentMonth;
    }
    get currentCSS() {
        return this.isCurrentMonth;
    }
    get isCurrentMonth() {
        return this.date.getMonth() === this.value.getMonth();
    }
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    onClick() {
        const date = new Date(this.value.getFullYear(), this.value.getMonth(), this.date.getDate());
        this.onMonthSelection.emit(date);
    }
}
IgxCalendarMonthDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCalendarMonth]'
            },] }
];
IgxCalendarMonthDirective.ctorParameters = () => [
    { type: ElementRef }
];
IgxCalendarMonthDirective.propDecorators = {
    value: [{ type: Input, args: ['igxCalendarMonth',] }],
    date: [{ type: Input }],
    index: [{ type: Input }],
    onMonthSelection: [{ type: Output }],
    defaultCSS: [{ type: HostBinding, args: ['class.igx-calendar__month',] }],
    currentCSS: [{ type: HostBinding, args: ['class.igx-calendar__month--current',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
/**
 * @hidden
 */
export class IgxCalendarHeaderTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxCalendarHeaderTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCalendarHeader]'
            },] }
];
IgxCalendarHeaderTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * @hidden
 */
export class IgxCalendarSubheaderTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxCalendarSubheaderTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCalendarSubheader]'
            },] }
];
IgxCalendarSubheaderTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * @hidden
 */
export class IgxCalendarScrollMonthDirective {
    constructor(element, zone) {
        this.element = element;
        this.zone = zone;
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        fromEvent(this.element.nativeElement, 'keyup').pipe(debounce(() => interval(100)), takeUntil(this.destroy$)).subscribe((event) => {
            this.stopScroll(event);
        });
        this.zone.runOutsideAngular(() => {
            fromEvent(this.element.nativeElement, 'keydown').pipe(tap((event) => {
                if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            }), debounce(() => interval(100)), takeUntil(this.destroy$)).subscribe((event) => {
                if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                    this.zone.run(() => this.startScroll(true));
                }
            });
        });
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     */
    onMouseDown() {
        this.startScroll();
    }
    /**
     * @hidden
     */
    onMouseUp(event) {
        this.stopScroll(event);
    }
}
IgxCalendarScrollMonthDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCalendarScrollMonth]'
            },] }
];
IgxCalendarScrollMonthDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
IgxCalendarScrollMonthDirective.propDecorators = {
    startScroll: [{ type: Input }],
    stopScroll: [{ type: Input }],
    onMouseDown: [{ type: HostListener, args: ['mousedown',] }],
    onMouseUp: [{ type: HostListener, args: ['mouseup', ['$event'],] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXIuZGlyZWN0aXZlcy5qcyIsInNvdXJjZVJvb3QiOiIvaG9tZS9ydW5uZXIvd29yay9pZ25pdGV1aS1hbmd1bGFyL2lnbml0ZXVpLWFuZ3VsYXIvcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvIiwic291cmNlcyI6WyJsaWIvY2FsZW5kYXIvY2FsZW5kYXIuZGlyZWN0aXZlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7R0FLRztBQUNILE9BQU8sRUFDSCxTQUFTLEVBQ1QsWUFBWSxFQUNaLFdBQVcsRUFDWCxZQUFZLEVBQ1osS0FBSyxFQUNMLE1BQU0sRUFDTixXQUFXLEVBQ1gsVUFBVSxFQUdWLE1BQU0sRUFDVCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDcEQsT0FBTyxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFHMUQ7O0dBRUc7QUFJSCxNQUFNLE9BQU8sd0JBQXdCO0lBNkNqQyxZQUFtQixVQUFzQjtRQUF0QixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBcENsQyxvQkFBZSxHQUFHLElBQUksWUFBWSxFQUFRLENBQUM7SUFvQ04sQ0FBQztJQWxDN0MsSUFDVyxVQUFVO1FBQ2pCLE9BQU8sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDO0lBQy9CLENBQUM7SUFFRCxJQUNXLFVBQVU7UUFDakIsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDO0lBQzlCLENBQUM7SUFFRCxJQUNXLElBQUk7UUFDWCxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0lBQ3BELENBQUM7SUFFRCxJQUNXLFFBQVE7UUFDZixPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxF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QUMsR0FBRyxvQkFBZSxJQUFJLEtBQUssQ0FBQyxHQUFHLDhCQUFrQixJQUFJLEtBQUssQ0FBQyxHQUFHLHdCQUFlLEVBQUU7b0JBQ3JGLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztpQkFDL0M7WUFDTCxDQUFDLENBQUMsQ0FBQztRQUNQLENBQUMsQ0FBQyxDQUFDO0lBRVAsQ0FBQztJQUVEOztPQUVHO0lBQ0ksV0FBVztRQUNkLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3pCLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDN0IsQ0FBQztJQUVEOztPQUVHO0lBRUksV0FBVztRQUNkLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUN2QixDQUFDO0lBRUQ7O09BRUc7SUFFSSxTQUFTLENBQUMsS0FBaUI7UUFDOUIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMzQixDQUFDOzs7WUEvRUosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSwwQkFBMEI7YUFDdkM7OztZQTFJRyxVQUFVO1lBR1YsTUFBTTs7OzBCQThJTCxLQUFLO3lCQU9MLEtBQUs7MEJBb0RMLFlBQVksU0FBQyxXQUFXO3dCQVF4QixZQUFZLFNBQUMsU0FBUyxFQUFFLENBQUMsUUFBUSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgYWxsIHRoZSBkaXJlY3RpdmVzIHVzZWQgYnkgdGhlIEBsaW5rIElneENhbGVuZGFyQ29tcG9uZW50LlxuICogRXhjZXB0IGZvciB0aGUgZGlyZWN0aXZlcyB3aGljaCBhcmUgdXNlZCBmb3IgdGVtcGxhdGluZyB0aGUgY2FsZW5kYXIgaXRzZWxmXG4gKiB5b3Ugc2hvdWxkIGdlbmVyYWxseSBub3QgdXNlIHRoZW0gZGlyZWN0bHkuXG4gKiBAcHJlZmVycmVkXG4gKi9cbmltcG9ydCB7XG4gICAgRGlyZWN0aXZlLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBIb3N0QmluZGluZyxcbiAgICBIb3N0TGlzdGVuZXIsXG4gICAgSW5wdXQsXG4gICAgT3V0cHV0LFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgQWZ0ZXJWaWV3SW5pdCxcbiAgICBPbkRlc3Ryb3ksXG4gICAgTmdab25lXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZnJvbUV2ZW50LCBTdWJqZWN0LCBpbnRlcnZhbCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsLCBkZWJvdW5jZSwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgS0VZUyB9IGZyb20gJy4uL2NvcmUvdXRpbHMnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbaWd4Q2FsZW5kYXJZZWFyXSdcbn0pXG5leHBvcnQgY2xhc3MgSWd4Q2FsZW5kYXJZZWFyRGlyZWN0aXZlIHtcblxuICAgIEBJbnB1dCgnaWd4Q2FsZW5kYXJZZWFyJylcbiAgICBwdWJsaWMgdmFsdWU6IERhdGU7XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBkYXRlOiBEYXRlO1xuXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uWWVhclNlbGVjdGlvbiA9IG5ldyBFdmVudEVtaXR0ZXI8RGF0ZT4oKTtcblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWNhbGVuZGFyX195ZWFyJylcbiAgICBwdWJsaWMgZ2V0IGRlZmF1bHRDU1MoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc0N1cnJlbnRZZWFyO1xuICAgIH1cblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWNhbGVuZGFyX195ZWFyLS1jdXJyZW50JylcbiAgICBwdWJsaWMgZ2V0IGN1cnJlbnRDU1MoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQ3VycmVudFllYXI7XG4gICAgfVxuXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLnJvbGUnKVxuICAgIHB1YmxpYyBnZXQgcm9sZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0N1cnJlbnRZZWFyID8gJ3NwaW5idXR0b24nIDogbnVsbDtcbiAgICB9XG5cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS12YWx1ZW5vdycpXG4gICAgcHVibGljIGdldCB2YWx1ZW5vdygpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0N1cnJlbnRZZWFyID8gdGhpcy5kYXRlLmdldEZ1bGxZZWFyKCkgOiBudWxsO1xuICAgIH1cblxuICAgIEBIb3N0QmluZGluZygnYXR0ci50YWJpbmRleCcpXG4gICAgcHVibGljIGdldCB0YWJJbmRleCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0N1cnJlbnRZZWFyID8gMCA6IC0xO1xuICAgIH1cblxuXG4gICAgcHVibGljIGdldCBpc0N1cnJlbnRZZWFyKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlLmdldEZ1bGxZZWFyKCkgPT09IHRoaXMudmFsdWUuZ2V0RnVsbFllYXIoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IG5hdGl2ZUVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZWxlbWVudFJlZjogRWxlbWVudFJlZikge31cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJylcbiAgICBwdWJsaWMgb25DbGljaygpIHtcbiAgICAgICAgdGhpcy5vblllYXJTZWxlY3Rpb24uZW1pdCh0aGlzLnZhbHVlKTtcbiAgICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2lneENhbGVuZGFyTW9udGhdJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hDYWxlbmRhck1vbnRoRGlyZWN0aXZlIHtcblxuICAgIEBJbnB1dCgnaWd4Q2FsZW5kYXJNb250aCcpXG4gICAgcHVibGljIHZhbHVlOiBEYXRlO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZGF0ZTogRGF0ZTtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGluZGV4O1xuXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uTW9udGhTZWxlY3Rpb24gPSBuZXcgRXZlbnRFbWl0dGVyPERhdGU+KCk7XG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1jYWxlbmRhcl9fbW9udGgnKVxuICAgIHB1YmxpYyBnZXQgZGVmYXVsdENTUygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzQ3VycmVudE1vbnRoO1xuICAgIH1cblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWNhbGVuZGFyX19tb250aC0tY3VycmVudCcpXG4gICAgcHVibGljIGdldCBjdXJyZW50Q1NTKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0N1cnJlbnRNb250aDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGlzQ3VycmVudE1vbnRoKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlLmdldE1vbnRoKCkgPT09IHRoaXMudmFsdWUuZ2V0TW9udGgoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IG5hdGl2ZUVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZWxlbWVudFJlZjogRWxlbWVudFJlZikge31cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJylcbiAgICBwdWJsaWMgb25DbGljaygpIHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRoaXMudmFsdWUuZ2V0RnVsbFllYXIoKSwgdGhpcy52YWx1ZS5nZXRNb250aCgpLCB0aGlzLmRhdGUuZ2V0RGF0ZSgpKTtcbiAgICAgICAgdGhpcy5vbk1vbnRoU2VsZWN0aW9uLmVtaXQoZGF0ZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbaWd4Q2FsZW5kYXJIZWFkZXJdJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hDYWxlbmRhckhlYWRlclRlbXBsYXRlRGlyZWN0aXZlIHtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55Pikge31cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2lneENhbGVuZGFyU3ViaGVhZGVyXSdcbn0pXG5leHBvcnQgY2xhc3MgSWd4Q2FsZW5kYXJTdWJoZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IocHVibGljIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+KSB7fVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbaWd4Q2FsZW5kYXJTY3JvbGxNb250aF0nXG59KVxuZXhwb3J0IGNsYXNzIElneENhbGVuZGFyU2Nyb2xsTW9udGhEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgLyoqXG4gICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIHdoZW4gbW9udGggaW5jcmVtZW50L2RlY3JlbWVudCBzdGFydHMuXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHN0YXJ0U2Nyb2xsOiAoa2V5ZG93bj86IGJvb2xlYW4pID0+IHt9O1xuXG4gICAgLyoqXG4gICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIHdoZW4gbW9udGggaW5jcmVtZW50L2RlY3JlbWVudCBzdG9wcy5cbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc3RvcFNjcm9sbDogKGV2ZW50OiBhbnkpID0+IHt9O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByaXZhdGUgZGVzdHJveSQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50OiBFbGVtZW50UmVmLCBwcml2YXRlIHpvbmU6IE5nWm9uZSkgeyB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcblxuICAgICAgICBmcm9tRXZlbnQodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdrZXl1cCcpLnBpcGUoXG4gICAgICAgICAgICBkZWJvdW5jZSgoKSA9PiBpbnRlcnZhbCgxMDApKSxcbiAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKVxuICAgICAgICApLnN1YnNjcmliZSgoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFNjcm9sbChldmVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBmcm9tRXZlbnQodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdrZXlkb3duJykucGlwZShcbiAgICAgICAgICAgICAgICB0YXAoKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09IEtFWVMuU1BBQ0UgfHwgZXZlbnQua2V5ID09PSBLRVlTLlNQQUNFX0lFIHx8IGV2ZW50LmtleSA9PT0gS0VZUy5FTlRFUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZGVib3VuY2UoKCkgPT4gaW50ZXJ2YWwoMTAwKSksXG4gICAgICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpXG4gICAgICAgICAgICApLnN1YnNjcmliZSgoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSBLRVlTLlNQQUNFIHx8IGV2ZW50LmtleSA9PT0gS0VZUy5TUEFDRV9JRSB8fCBldmVudC5rZXkgPT09IEtFWVMuRU5URVIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB0aGlzLnN0YXJ0U2Nyb2xsKHRydWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLm5leHQodHJ1ZSk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2Vkb3duJylcbiAgICBwdWJsaWMgb25Nb3VzZURvd24oKSB7XG4gICAgICAgIHRoaXMuc3RhcnRTY3JvbGwoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2V1cCcsIFsnJGV2ZW50J10pXG4gICAgcHVibGljIG9uTW91c2VVcChldmVudDogTW91c2VFdmVudCkge1xuICAgICAgICB0aGlzLnN0b3BTY3JvbGwoZXZlbnQpO1xuICAgIH1cbn1cbiJdfQ==