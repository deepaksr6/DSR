import { isIE } from '../core/utils';
import { DatePart } from '../directives/date-time-editor/date-time-editor.common';
import { formatDate, FormatWidth, getLocaleDateFormat } from '@angular/common';
const DATE_CHARS = ['h', 'H', 'm', 's', 'S', 't', 'T'];
const TIME_CHARS = ['d', 'D', 'M', 'y', 'Y'];
/** @hidden */
export class DatePickerUtil {
    /**
     *  TODO: (in issue #6483) Unit tests and docs for all public methods.
     */
    /**
     * Parse a Date value from masked string input based on determined date parts
     * @param inputData masked value to parse
     * @param dateTimeParts Date parts array for the mask
     */
    static parseValueFromMask(inputData, dateTimeParts, promptChar) {
        const parts = {};
        dateTimeParts.forEach(dp => {
            let value = parseInt(this.getCleanVal(inputData, dp, promptChar), 10);
            if (!value) {
                value = dp.type === DatePart.Date || dp.type === DatePart.Month ? 1 : 0;
            }
            parts[dp.type] = value;
        });
        parts[DatePart.Month] -= 1;
        if (parts[DatePart.Month] < 0 || 11 < parts[DatePart.Month]) {
            return null;
        }
        // TODO: Century threshold
        if (parts[DatePart.Year] < 50) {
            parts[DatePart.Year] += 2000;
        }
        if (parts[DatePart.Date] > DatePickerUtil.daysInMonth(parts[DatePart.Year], parts[DatePart.Month])) {
            return null;
        }
        if (parts[DatePart.Hours] > 23 || parts[DatePart.Minutes] > 59 || parts[DatePart.Seconds] > 59) {
            return null;
        }
        return new Date(parts[DatePart.Year] || 2000, parts[DatePart.Month] || 0, parts[DatePart.Date] || 1, parts[DatePart.Hours] || 0, parts[DatePart.Minutes] || 0, parts[DatePart.Seconds] || 0);
    }
    /**
     * Parse the mask into date/time and literal parts
     */
    static parseDateTimeFormat(mask, locale = DatePickerUtil.DEFAULT_LOCALE) {
        const format = mask || DatePickerUtil.getDefaultInputFormat(locale);
        const dateTimeParts = [];
        const formatArray = Array.from(format);
        let currentPart = null;
        let position = 0;
        for (let i = 0; i < formatArray.length; i++, position++) {
            const type = DatePickerUtil.determineDatePart(formatArray[i]);
            if (currentPart) {
                if (currentPart.type === type) {
                    currentPart.format += formatArray[i];
                    if (i < formatArray.length - 1) {
                        continue;
                    }
                }
                DatePickerUtil.ensureLeadingZero(currentPart);
                currentPart.end = currentPart.start + currentPart.format.length;
                position = currentPart.end;
                dateTimeParts.push(currentPart);
            }
            currentPart = {
                start: position,
                end: position + formatArray[i].length,
                type: type,
                format: formatArray[i]
            };
        }
        return dateTimeParts;
    }
    static getDefaultInputFormat(locale) {
        if (!Intl || !Intl.DateTimeFormat || !Intl.DateTimeFormat.prototype.formatToParts) {
            // TODO: fallback with Intl.format for IE?
            return DatePickerUtil.SHORT_DATE_MASK;
        }
        const parts = DatePickerUtil.getDefaultLocaleMask(locale);
        parts.forEach(p => {
            if (p.type !== DatePart.Year && p.type !== DatePickerUtil.SEPARATOR) {
                p.formatType = "2-digit" /* TwoDigits */;
            }
        });
        return DatePickerUtil.getMask(parts);
    }
    static formatDate(value, format, locale, timezone) {
        let formattedDate;
        try {
            formattedDate = formatDate(value, format, locale, timezone);
        }
        catch (_a) {
            this.logMissingLocaleSettings(locale);
            const formatter = new Intl.DateTimeFormat(locale);
            formattedDate = formatter.format(value);
        }
        return formattedDate;
    }
    static getLocaleDateFormat(locale, displayFormat) {
        const formatKeys = Object.keys(FormatWidth);
        const targetKey = formatKeys.find(k => k.toLowerCase() === (displayFormat === null || displayFormat === void 0 ? void 0 : displayFormat.toLowerCase().replace('date', '')));
        if (!targetKey) {
            // if displayFormat is not shortDate, longDate, etc.
            // or if it is not set by the user
            return displayFormat;
        }
        let format;
        try {
            format = getLocaleDateFormat(locale, FormatWidth[targetKey]);
        }
        catch (_a) {
            this.logMissingLocaleSettings(locale);
            format = DatePickerUtil.getDefaultInputFormat(locale);
        }
        return format;
    }
    static isDateOrTimeChar(char) {
        return DATE_CHARS.indexOf(char) !== -1 || TIME_CHARS.indexOf(char) !== -1;
    }
    static spinDate(delta, newDate, isSpinLoop) {
        const maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear(), newDate.getMonth());
        let date = newDate.getDate() + delta;
        if (date > maxDate) {
            date = isSpinLoop ? date % maxDate : maxDate;
        }
        else if (date < 1) {
            date = isSpinLoop ? maxDate + (date % maxDate) : 1;
        }
        newDate.setDate(date);
    }
    static spinMonth(delta, newDate, isSpinLoop) {
        const maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear(), newDate.getMonth() + delta);
        if (newDate.getDate() > maxDate) {
            newDate.setDate(maxDate);
        }
        const maxMonth = 11;
        const minMonth = 0;
        let month = newDate.getMonth() + delta;
        if (month > maxMonth) {
            month = isSpinLoop ? (month % maxMonth) - 1 : maxMonth;
        }
        else if (month < minMonth) {
            month = isSpinLoop ? maxMonth + (month % maxMonth) + 1 : minMonth;
        }
        newDate.setMonth(month);
    }
    static spinYear(delta, newDate) {
        const maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear() + delta, newDate.getMonth());
        if (newDate.getDate() > maxDate) {
            // clip to max to avoid leap year change shifting the entire value
            newDate.setDate(maxDate);
        }
        newDate.setFullYear(newDate.getFullYear() + delta);
    }
    static spinHours(delta, newDate, isSpinLoop) {
        const maxHour = 23;
        const minHour = 0;
        let hours = newDate.getHours() + delta;
        if (hours > maxHour) {
            hours = isSpinLoop ? hours % maxHour - 1 : maxHour;
        }
        else if (hours < minHour) {
            hours = isSpinLoop ? maxHour + (hours % maxHour) + 1 : minHour;
        }
        newDate.setHours(hours);
    }
    static spinMinutes(delta, newDate, isSpinLoop) {
        const maxMinutes = 59;
        const minMinutes = 0;
        let minutes = newDate.getMinutes() + delta;
        if (minutes > maxMinutes) {
            minutes = isSpinLoop ? minutes % maxMinutes - 1 : maxMinutes;
        }
        else if (minutes < minMinutes) {
            minutes = isSpinLoop ? maxMinutes + (minutes % maxMinutes) + 1 : minMinutes;
        }
        newDate.setMinutes(minutes);
    }
    static spinSeconds(delta, newDate, isSpinLoop) {
        const maxSeconds = 59;
        const minSeconds = 0;
        let seconds = newDate.getSeconds() + delta;
        if (seconds > maxSeconds) {
            seconds = isSpinLoop ? seconds % maxSeconds - 1 : maxSeconds;
        }
        else if (seconds < minSeconds) {
            seconds = isSpinLoop ? maxSeconds + (seconds % maxSeconds) + 1 : minSeconds;
        }
        newDate.setSeconds(seconds);
    }
    static spinAmPm(newDate, currentDate, amPmFromMask) {
        switch (amPmFromMask) {
            case 'AM':
                newDate = new Date(newDate.setHours(newDate.getHours() + 12));
                break;
            case 'PM':
                newDate = new Date(newDate.setHours(newDate.getHours() - 12));
                break;
        }
        if (newDate.getDate() !== currentDate.getDate()) {
            return currentDate;
        }
        return newDate;
    }
    /**
     * Determines whether the provided value is greater than the provided max value.
     * @param includeTime set to false if you want to exclude time portion of the two dates
     * @param includeDate set to false if you want to exclude the date portion of the two dates
     * @returns true if provided value is greater than provided maxValue
     */
    static greaterThanMaxValue(value, maxValue, includeTime = true, includeDate = true) {
        // TODO: check if provided dates are valid dates and not Invalid Date
        // if maxValue is Invalid Date and value is valid date this will return:
        // - false if includeDate is true
        // - true if includeDate is false
        if (includeTime && includeDate) {
            return value.getTime() > maxValue.getTime();
        }
        const _value = new Date(value.getTime());
        const _maxValue = new Date(maxValue.getTime());
        if (!includeTime) {
            _value.setHours(0, 0, 0, 0);
            _maxValue.setHours(0, 0, 0, 0);
        }
        if (!includeDate) {
            _value.setFullYear(0, 0, 0);
            _maxValue.setFullYear(0, 0, 0);
        }
        return _value.getTime() > _maxValue.getTime();
    }
    /**
     * Determines whether the provided value is less than the provided min value.
     * @param includeTime set to false if you want to exclude time portion of the two dates
     * @param includeDate set to false if you want to exclude the date portion of the two dates
     * @returns true if provided value is less than provided minValue
     */
    static lessThanMinValue(value, minValue, includeTime = true, includeDate = true) {
        // TODO: check if provided dates are valid dates and not Invalid Date
        // if value is Invalid Date and minValue is valid date this will return:
        // - false if includeDate is true
        // - true if includeDate is false
        if (includeTime && includeDate) {
            return value.getTime() < minValue.getTime();
        }
        const _value = new Date(value.getTime());
        const _minValue = new Date(minValue.getTime());
        if (!includeTime) {
            _value.setHours(0, 0, 0, 0);
            _minValue.setHours(0, 0, 0, 0);
        }
        if (!includeDate) {
            _value.setFullYear(0, 0, 0);
            _minValue.setFullYear(0, 0, 0);
        }
        return _value.getTime() < _minValue.getTime();
    }
    static logMissingLocaleSettings(locale) {
        console.warn(`Missing locale data for the locale ${locale}. Please refer to https://angular.io/guide/i18n#i18n-pipes`);
        console.warn('Using default browser locale settings.');
    }
    static ensureLeadingZero(part) {
        switch (part.type) {
            case DatePart.Date:
            case DatePart.Month:
            case DatePart.Hours:
            case DatePart.Minutes:
            case DatePart.Seconds:
                if (part.format.length === 1) {
                    part.format = part.format.repeat(2);
                }
                break;
        }
    }
    static getCleanVal(inputData, datePart, promptChar) {
        return DatePickerUtil.trimEmptyPlaceholders(inputData.substring(datePart.start, datePart.end), promptChar);
    }
    static determineDatePart(char) {
        switch (char) {
            case 'd':
            case 'D':
                return DatePart.Date;
            case 'M':
                return DatePart.Month;
            case 'y':
            case 'Y':
                return DatePart.Year;
            case 'h':
            case 'H':
                return DatePart.Hours;
            case 'm':
                return DatePart.Minutes;
            case 's':
            case 'S':
                return DatePart.Seconds;
            case 't':
            case 'T':
                return DatePart.AmPm;
            default:
                return DatePart.Literal;
        }
    }
    /**
     * This method generates date parts structure based on editor mask and locale.
     * @param maskValue: string
     * @param locale: string
     * @returns array containing information about date parts - type, position, format
     */
    static parseDateFormat(maskValue, locale = DatePickerUtil.DEFAULT_LOCALE) {
        let dateStruct = [];
        if (maskValue === undefined && !isIE()) {
            dateStruct = DatePickerUtil.getDefaultLocaleMask(locale);
        }
        else {
            const mask = (maskValue) ? maskValue : DatePickerUtil.SHORT_DATE_MASK;
            const maskArray = Array.from(mask);
            const monthInitPosition = mask.indexOf("M" /* MonthChar */);
            const dayInitPosition = mask.indexOf("d" /* DayChar */);
            const yearInitPosition = mask.indexOf("y" /* YearChar */);
            if (yearInitPosition !== -1) {
                dateStruct.push({
                    type: "year" /* Year */,
                    initialPosition: yearInitPosition,
                    formatType: DatePickerUtil.getYearFormatType(mask)
                });
            }
            if (monthInitPosition !== -1) {
                dateStruct.push({
                    type: "month" /* Month */,
                    initialPosition: monthInitPosition,
                    formatType: DatePickerUtil.getMonthFormatType(mask)
                });
            }
            if (dayInitPosition !== -1) {
                dateStruct.push({
                    type: "day" /* Day */,
                    initialPosition: dayInitPosition,
                    formatType: DatePickerUtil.getDayFormatType(mask)
                });
            }
            for (let i = 0; i < maskArray.length; i++) {
                if (!DatePickerUtil.isDateChar(maskArray[i])) {
                    dateStruct.push({
                        type: DatePickerUtil.SEPARATOR,
                        initialPosition: i,
                        value: maskArray[i]
                    });
                }
            }
            dateStruct.sort((a, b) => a.initialPosition - b.initialPosition);
            DatePickerUtil.fillDatePartsPositions(dateStruct);
        }
        return dateStruct;
    }
    /**
     * This method generates input mask based on date parts.
     * @param dateStruct array
     * @returns input mask
     */
    static getInputMask(dateStruct) {
        const inputMask = [];
        for (let i = 0; i < dateStruct.length; i++) {
            if (dateStruct[i].type === DatePickerUtil.SEPARATOR) {
                inputMask.push(dateStruct[i].value);
            }
            else if (dateStruct[i].type === "day" /* Day */ || dateStruct[i].type === "month" /* Month */) {
                inputMask.push('00');
            }
            else if (dateStruct[i].type === "year" /* Year */) {
                switch (dateStruct[i].formatType) {
                    case "numeric" /* Numeric */: {
                        inputMask.push('0000');
                        break;
                    }
                    case "2-digit" /* TwoDigits */: {
                        inputMask.push('00');
                        break;
                    }
                }
            }
        }
        return inputMask.join('');
    }
    /**
     * This method generates editor mask.
     * @param dateStruct
     * @returns editor mask
     */
    static getMask(dateStruct) {
        const mask = [];
        for (let i = 0; i < dateStruct.length; i++) {
            switch (dateStruct[i].formatType) {
                case "numeric" /* Numeric */: {
                    if (dateStruct[i].type === "day" /* Day */) {
                        mask.push('d');
                    }
                    else if (dateStruct[i].type === "month" /* Month */) {
                        mask.push('M');
                    }
                    else {
                        mask.push('yyyy');
                    }
                    break;
                }
                case "2-digit" /* TwoDigits */: {
                    if (dateStruct[i].type === "day" /* Day */) {
                        mask.push('dd');
                    }
                    else if (dateStruct[i].type === "month" /* Month */) {
                        mask.push('MM');
                    }
                    else {
                        mask.push('yy');
                    }
                }
            }
            if (dateStruct[i].type === DatePickerUtil.SEPARATOR) {
                mask.push(dateStruct[i].value);
            }
        }
        return mask.join('');
    }
    /**
     * This method parses an input string base on date parts and returns a date and its validation state.
     * @param dateFormatParts
     * @param prevDateValue
     * @param inputValue
     * @returns object containing a date and its validation state
     */
    static parseDateArray(dateFormatParts, prevDateValue, inputValue) {
        const dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, inputValue);
        const monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue);
        const yearStr = DatePickerUtil.getYearValueFromInput(dateFormatParts, inputValue);
        const yearFormat = DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */).formatType;
        const day = (dayStr !== '') ? parseInt(dayStr, 10) : 1;
        const month = (monthStr !== '') ? parseInt(monthStr, 10) - 1 : 0;
        let year;
        if (yearStr === '') {
            year = (yearFormat === "2-digit" /* TwoDigits */) ? '00' : '2000';
        }
        else {
            year = yearStr;
        }
        let yearPrefix;
        if (prevDateValue) {
            const originalYear = prevDateValue.getFullYear().toString();
            if (originalYear.length === 4) {
                yearPrefix = originalYear.substring(0, 2);
            }
        }
        else {
            yearPrefix = '20';
        }
        const fullYear = (yearFormat === "2-digit" /* TwoDigits */) ? yearPrefix.concat(year) : year;
        if ((month < 0) || (month > 11) || (month === NaN)) {
            return { state: "invalid" /* Invalid */, value: inputValue };
        }
        if ((day < 1) || (day > DatePickerUtil.daysInMonth(fullYear, month)) || (day === NaN)) {
            return { state: "invalid" /* Invalid */, value: inputValue };
        }
        return { state: "valid" /* Valid */, date: new Date(fullYear, month, day) };
    }
    static maskToPromptChars(mask) {
        const result = mask.replace(/0|L/g, DatePickerUtil.PROMPT_CHAR);
        return result;
    }
    /**
     * This method replaces prompt chars with empty string.
     * @param value
     */
    static trimEmptyPlaceholders(value, promptChar) {
        const result = value.replace(new RegExp(promptChar || '_', 'g'), '');
        return result;
    }
    /**
     * This method is used for spinning date parts.
     * @param dateFormatParts
     * @param inputValue
     * @param position
     * @param delta
     * @param isSpinLoop
     * @return modified text input
     */
    static getModifiedDateInput(dateFormatParts, inputValue, position, delta, isSpinLoop) {
        const datePart = DatePickerUtil.getDatePartOnPosition(dateFormatParts, position);
        const datePartType = datePart.type;
        const datePartFormatType = datePart.formatType;
        let newValue;
        const datePartValue = DatePickerUtil.getDateValueFromInput(dateFormatParts, datePartType, inputValue);
        newValue = parseInt(datePartValue, 10);
        let maxValue, minValue;
        const minMax = DatePickerUtil.getMinMaxValue(dateFormatParts, datePart, inputValue);
        minValue = minMax.min;
        maxValue = minMax.max;
        if (isNaN(newValue)) {
            if (minValue === 'infinite') {
                newValue = 2000;
            }
            else {
                newValue = minValue;
            }
        }
        let tempValue = newValue;
        tempValue += delta;
        // Infinite loop for full years
        if (maxValue === 'infinite' && minValue === 'infinite') {
            newValue = tempValue;
        }
        if (isSpinLoop) {
            if (tempValue > maxValue) {
                tempValue = minValue;
            }
            if (tempValue < minValue) {
                tempValue = maxValue;
            }
            newValue = tempValue;
        }
        else {
            if (tempValue <= maxValue && tempValue >= minValue) {
                newValue = tempValue;
            }
        }
        const startIdx = datePart.position[0];
        const endIdx = datePart.position[1];
        const start = inputValue.slice(0, startIdx);
        const end = inputValue.slice(endIdx, inputValue.length);
        let changedPart;
        const prefix = DatePickerUtil.getNumericFormatPrefix(datePartFormatType);
        changedPart = (newValue < 10) ? `${prefix}${newValue}` : `${newValue}`;
        return `${start}${changedPart}${end}`;
    }
    /**
     * This method returns date input with prompt chars.
     * @param dateFormatParts
     * @param date
     * @param inputValue
     * @returns date input including prompt chars
     */
    static addPromptCharsEditMode(dateFormatParts, date, inputValue) {
        const dateArray = Array.from(inputValue);
        for (let i = 0; i < dateFormatParts.length; i++) {
            if (dateFormatParts[i].formatType === "numeric" /* Numeric */) {
                if ((dateFormatParts[i].type === "day" /* Day */ && date.getDate() < 10)
                    || (dateFormatParts[i].type === "month" /* Month */ && date.getMonth() + 1 < 10)) {
                    dateArray.splice(dateFormatParts[i].position[0], 0, DatePickerUtil.PROMPT_CHAR);
                    dateArray.join('');
                }
            }
        }
        return dateArray.join('');
    }
    /**
     * This method checks if date input is done.
     * @param dateFormatParts
     * @param input
     * @returns input completeness
     */
    static checkForCompleteDateInput(dateFormatParts, input) {
        const dayValue = DatePickerUtil.getDayValueFromInput(dateFormatParts, input);
        const monthValue = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input);
        const yearValue = DatePickerUtil.getYearValueFromInput(dateFormatParts, input);
        const dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, input, false);
        const monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input, false);
        if (DatePickerUtil.isFullInput(dayValue, dayStr)
            && DatePickerUtil.isFullInput(monthValue, monthStr)
            && DatePickerUtil.isFullYearInput(dateFormatParts, yearValue)) {
            return 'complete';
        }
        else if (dayValue === '' && monthValue === '' && yearValue === '') {
            return 'empty';
        }
        else if (dayValue === '' || monthValue === '' || yearValue === '') {
            return 'partial';
        }
        return '';
    }
    static daysInMonth(fullYear, month) {
        return new Date(fullYear, month + 1, 0).getDate();
    }
    /**
     * Parse provided input to Date.
     * @param value input to parse
     * @returns Date if parse succeed or null
     */
    static parseDate(value) {
        if (typeof value === 'number') {
            return new Date(value);
        }
        // if value is Invalid Date we should return null
        if (this.isDate(value)) {
            return this.isValidDate(value) ? value : null;
        }
        return value ? new Date(Date.parse(value)) : null;
    }
    /**
     * Returns whether provided input is date
     * @param value input to check
     * @returns true if provided input is date
     */
    static isDate(value) {
        return Object.prototype.toString.call(value) === '[object Date]';
    }
    /**
     * Returns whether the input is valid date
     * @param value input to check
     * @returns true if provided input is a valid date
     */
    static isValidDate(value) {
        if (this.isDate(value)) {
            return !isNaN(value.getTime());
        }
        return false;
    }
    static getYearFormatType(format) {
        switch (format.match(new RegExp("y" /* YearChar */, 'g')).length) {
            case 1: {
                // y (2020)
                return "numeric" /* Numeric */;
            }
            case 4: {
                // yyyy (2020)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // yy (20)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    static getMonthFormatType(format) {
        switch (format.match(new RegExp("M" /* MonthChar */, 'g')).length) {
            case 1: {
                // M (8)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // MM (08)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    static getDayFormatType(format) {
        switch (format.match(new RegExp("d" /* DayChar */, 'g')).length) {
            case 1: {
                // d (6)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // dd (06)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    static getDefaultLocaleMask(locale) {
        const dateStruct = [];
        const formatter = new Intl.DateTimeFormat(locale);
        const formatToParts = formatter.formatToParts(new Date());
        for (let i = 0; i < formatToParts.length; i++) {
            if (formatToParts[i].type === DatePickerUtil.SEPARATOR) {
                dateStruct.push({
                    type: DatePickerUtil.SEPARATOR,
                    value: formatToParts[i].value
                });
            }
            else {
                dateStruct.push({
                    type: formatToParts[i].type
                });
            }
        }
        const formatterOptions = formatter.resolvedOptions();
        for (let i = 0; i < dateStruct.length; i++) {
            switch (dateStruct[i].type) {
                case "day" /* Day */: {
                    dateStruct[i].formatType = formatterOptions.day;
                    break;
                }
                case "month" /* Month */: {
                    dateStruct[i].formatType = formatterOptions.month;
                    break;
                }
                case "year" /* Year */: {
                    dateStruct[i].formatType = formatterOptions.year;
                    break;
                }
            }
        }
        DatePickerUtil.fillDatePartsPositions(dateStruct);
        return dateStruct;
    }
    static isDateChar(char) {
        return (char === "y" /* YearChar */ || char === "M" /* MonthChar */ || char === "d" /* DayChar */);
    }
    static getNumericFormatPrefix(formatType) {
        switch (formatType) {
            case "2-digit" /* TwoDigits */: {
                return '0';
            }
            case "numeric" /* Numeric */: {
                return DatePickerUtil.PROMPT_CHAR;
            }
        }
    }
    static getMinMaxValue(dateFormatParts, datePart, inputValue) {
        let maxValue, minValue;
        switch (datePart.type) {
            case "month" /* Month */: {
                minValue = 1;
                maxValue = DatePickerUtil.NUMBER_OF_MONTHS;
                break;
            }
            case "day" /* Day */: {
                minValue = 1;
                maxValue = DatePickerUtil.daysInMonth(DatePickerUtil.getFullYearFromString(DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */), inputValue), parseInt(DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue), 10));
                break;
            }
            case "year" /* Year */: {
                if (datePart.formatType === "2-digit" /* TwoDigits */) {
                    minValue = 0;
                    maxValue = 99;
                }
                else {
                    // Infinite loop
                    minValue = 'infinite';
                    maxValue = 'infinite';
                }
                break;
            }
        }
        return { min: minValue, max: maxValue };
    }
    static getDateValueFromInput(dateFormatParts, type, inputValue, trim = true) {
        const partPosition = DatePickerUtil.getDateFormatPart(dateFormatParts, type).position;
        const result = inputValue.substring(partPosition[0], partPosition[1]);
        return (trim) ? DatePickerUtil.trimEmptyPlaceholders(result) : result;
    }
    static getDayValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "day" /* Day */, inputValue, trim);
    }
    static getMonthValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "month" /* Month */, inputValue, trim);
    }
    static getYearValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "year" /* Year */, inputValue, trim);
    }
    static getDateFormatPart(dateFormatParts, type) {
        const result = dateFormatParts.filter((datePart) => (datePart.type === type))[0];
        return result;
    }
    static isFullInput(value, input) {
        return (value !== '' && input.length === 2 && input.charAt(1) !== DatePickerUtil.PROMPT_CHAR);
    }
    static isFullYearInput(dateFormatParts, value) {
        switch (DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */).formatType) {
            case "numeric" /* Numeric */: {
                return (value !== '' && value.length === 4);
            }
            case "2-digit" /* TwoDigits */: {
                return (value !== '' && value.length === 2);
            }
            default: {
                return false;
            }
        }
    }
    static getDatePartOnPosition(dateFormatParts, position) {
        const result = dateFormatParts.filter((element) => element.position[0] <= position && position <= element.position[1] && element.type !== DatePickerUtil.SEPARATOR)[0];
        return result;
    }
    static getFullYearFromString(yearPart, inputValue) {
        return parseInt(inputValue.substring(yearPart.position[0], yearPart.position[1]), 10);
    }
    static fillDatePartsPositions(dateArray) {
        let currentPos = 0;
        for (let i = 0; i < dateArray.length; i++) {
            // Day|Month part positions
            if (dateArray[i].type === "day" /* Day */ || dateArray[i].type === "month" /* Month */) {
                // Offset 2 positions for number
                dateArray[i].position = [currentPos, currentPos + 2];
                currentPos += 2;
            }
            else if (dateArray[i].type === "year" /* Year */) {
                // Year part positions
                switch (dateArray[i].formatType) {
                    case "numeric" /* Numeric */: {
                        // Offset 4 positions for full year
                        dateArray[i].position = [currentPos, currentPos + 4];
                        currentPos += 4;
                        break;
                    }
                    case "2-digit" /* TwoDigits */: {
                        // Offset 2 positions for short year
                        dateArray[i].position = [currentPos, currentPos + 2];
                        currentPos += 2;
                        break;
                    }
                }
            }
            else if (dateArray[i].type === DatePickerUtil.SEPARATOR) {
                // Separator positions
                dateArray[i].position = [currentPos, currentPos + 1];
                currentPos++;
            }
        }
    }
}
DatePickerUtil.DEFAULT_INPUT_FORMAT = 'MM/dd/yyyy';
// TODO: this is the def mask for the date-picker, should remove it during refactoring
DatePickerUtil.SHORT_DATE_MASK = 'MM/dd/yy';
DatePickerUtil.SEPARATOR = 'literal';
DatePickerUtil.NUMBER_OF_MONTHS = 12;
DatePickerUtil.PROMPT_CHAR = '_';
DatePickerUtil.DEFAULT_LOCALE = 'en';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1waWNrZXIudXRpbHMuanMiLCJzb3VyY2VSb290IjoiL2hvbWUvcnVubmVyL3dvcmsvaWduaXRldWktYW5ndWxhci9pZ25pdGV1aS1hbmd1bGFyL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjLyIsInNvdXJjZXMiOlsibGliL2RhdGUtcGlja2VyL2RhdGUtcGlja2VyLnV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckMsT0FBTyxFQUFFLFFBQVEsRUFBZ0IsTUFBTSx3REFBd0QsQ0FBQztBQUNoRyxPQUFPLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxtQkFBbUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBeUIvRSxNQUFNLFVBQVUsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ3ZELE1BQU0sVUFBVSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBVTdDLGNBQWM7QUFDZCxNQUFNLE9BQWdCLGNBQWM7SUFXaEM7O09BRUc7SUFJSDs7OztPQUlHO0lBQ0ksTUFBTSxDQUFDLGtCQUFrQixDQUFDLFNBQWlCLEVBQUUsYUFBNkIsRUFBRSxVQUFtQjtRQUNsRyxNQUFNLEtBQUssR0FBa0MsRUFBUyxDQUFDO1FBQ3ZELGFBQWEsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLEVBQUU7WUFDdkIsSUFBSSxLQUFLLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxFQUFFLEVBQUUsRUFBRSxVQUFVLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUN0RSxJQUFJLENBQUMsS0FBSyxFQUFFO2dCQUNSLEtBQUssR0FBRyxFQUFFLENBQUMsSUFBSSxLQUFLLFFBQVEs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QUFDO0FBQzNELHNGQUFzRjtBQUM5RCw4QkFBZSxHQUFHLFVBQVUsQ0FBQztBQUM3Qix3QkFBUyxHQUFHLFNBQVMsQ0FBQztBQUN0QiwrQkFBZ0IsR0FBRyxFQUFFLENBQUM7QUFDdEIsMEJBQVcsR0FBRyxHQUFHLENBQUM7QUFDbEIsNkJBQWMsR0FBRyxJQUFJLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0lFIH0gZnJvbSAnLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBEYXRlUGFydCwgRGF0ZVBhcnRJbmZvIH0gZnJvbSAnLi4vZGlyZWN0aXZlcy9kYXRlLXRpbWUtZWRpdG9yL2RhdGUtdGltZS1lZGl0b3IuY29tbW9uJztcbmltcG9ydCB7IGZvcm1hdERhdGUsIEZvcm1hdFdpZHRoLCBnZXRMb2NhbGVEYXRlRm9ybWF0IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuLyoqXG4gKiBUaGlzIGVudW0gaXMgdXNlZCB0byBrZWVwIHRoZSBkYXRlIHZhbGlkYXRpb24gcmVzdWx0LlxuICpcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gRGF0ZVN0YXRlIHtcbiAgICBWYWxpZCA9ICd2YWxpZCcsXG4gICAgSW52YWxpZCA9ICdpbnZhbGlkJyxcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IGVudW0gRm9ybWF0RGVzYyB7XG4gICAgTnVtZXJpYyA9ICdudW1lcmljJyxcbiAgICBUd29EaWdpdHMgPSAnMi1kaWdpdCdcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IGVudW0gRGF0ZUNoYXJzIHtcbiAgICBZZWFyQ2hhciA9ICd5JyxcbiAgICBNb250aENoYXIgPSAnTScsXG4gICAgRGF5Q2hhciA9ICdkJ1xufVxuXG5jb25zdCBEQVRFX0NIQVJTID0gWydoJywgJ0gnLCAnbScsICdzJywgJ1MnLCAndCcsICdUJ107XG5jb25zdCBUSU1FX0NIQVJTID0gWydkJywgJ0QnLCAnTScsICd5JywgJ1knXTtcblxuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IGVudW0gRGF0ZVBhcnRzIHtcbiAgICBEYXkgPSAnZGF5JyxcbiAgICBNb250aCA9ICdtb250aCcsXG4gICAgWWVhciA9ICd5ZWFyJ1xufVxuXG5cbi8qKiBAaGlkZGVuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRGF0ZVBpY2tlclV0aWwge1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgREVGQVVMVF9JTlBVVF9GT1JNQVQgPSAnTU0vZGQveXl5eSc7XG4gICAgLy8gVE9ETzogdGhpcyBpcyB0aGUgZGVmIG1hc2sgZm9yIHRoZSBkYXRlLXBpY2tlciwgc2hvdWxkIHJlbW92ZSBpdCBkdXJpbmcgcmVmYWN0b3JpbmdcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBTSE9SVF9EQVRFX01BU0sgPSAnTU0vZGQveXknO1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFNFUEFSQVRPUiA9ICdsaXRlcmFsJztcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBOVU1CRVJfT0ZfTU9OVEhTID0gMTI7XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgUFJPTVBUX0NIQVIgPSAnXyc7XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgREVGQVVMVF9MT0NBTEUgPSAnZW4nO1xuXG5cblxuICAgIC8qKlxuICAgICAqICBUT0RPOiAoaW4gaXNzdWUgIzY0ODMpIFVuaXQgdGVzdHMgYW5kIGRvY3MgZm9yIGFsbCBwdWJsaWMgbWV0aG9kcy5cbiAgICAgKi9cblxuXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBhIERhdGUgdmFsdWUgZnJvbSBtYXNrZWQgc3RyaW5nIGlucHV0IGJhc2VkIG9uIGRldGVybWluZWQgZGF0ZSBwYXJ0c1xuICAgICAqIEBwYXJhbSBpbnB1dERhdGEgbWFza2VkIHZhbHVlIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIGRhdGVUaW1lUGFydHMgRGF0ZSBwYXJ0cyBhcnJheSBmb3IgdGhlIG1hc2tcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHBhcnNlVmFsdWVGcm9tTWFzayhpbnB1dERhdGE6IHN0cmluZywgZGF0ZVRpbWVQYXJ0czogRGF0ZVBhcnRJbmZvW10sIHByb21wdENoYXI/OiBzdHJpbmcpOiBEYXRlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHBhcnRzOiB7IFtrZXkgaW4gRGF0ZVBhcnRdOiBudW1iZXIgfSA9IHt9IGFzIGFueTtcbiAgICAgICAgZGF0ZVRpbWVQYXJ0cy5mb3JFYWNoKGRwID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHBhcnNlSW50KHRoaXMuZ2V0Q2xlYW5WYWwoaW5wdXREYXRhLCBkcCwgcHJvbXB0Q2hhciksIDEwKTtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRwLnR5cGUgPT09IERhdGVQYXJ0LkRhdGUgfHwgZHAudHlwZSA9PT0gRGF0ZVBhcnQuTW9udGggPyAxIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnRzW2RwLnR5cGVdID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJ0c1tEYXRlUGFydC5Nb250aF0gLT0gMTtcblxuICAgICAgICBpZiAocGFydHNbRGF0ZVBhcnQuTW9udGhdIDwgMCB8fCAxMSA8IHBhcnRzW0RhdGVQYXJ0Lk1vbnRoXSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBDZW50dXJ5IHRocmVzaG9sZFxuICAgICAgICBpZiAocGFydHNbRGF0ZVBhcnQuWWVhcl0gPCA1MCkge1xuICAgICAgICAgICAgcGFydHNbRGF0ZVBhcnQuWWVhcl0gKz0gMjAwMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0c1tEYXRlUGFydC5EYXRlXSA+IERhdGVQaWNrZXJVdGlsLmRheXNJbk1vbnRoKHBhcnRzW0RhdGVQYXJ0LlllYXJdLCBwYXJ0c1tEYXRlUGFydC5Nb250aF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0c1tEYXRlUGFydC5Ib3Vyc10gPiAyMyB8fCBwYXJ0c1tEYXRlUGFydC5NaW51dGVzXSA+IDU5IHx8IHBhcnRzW0RhdGVQYXJ0LlNlY29uZHNdID4gNTkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKFxuICAgICAgICAgICAgcGFydHNbRGF0ZVBhcnQuWWVhcl0gfHwgMjAwMCxcbiAgICAgICAgICAgIHBhcnRzW0RhdGVQYXJ0Lk1vbnRoXSB8fCAwLFxuICAgICAgICAgICAgcGFydHNbRGF0ZVBhcnQuRGF0ZV0gfHwgMSxcbiAgICAgICAgICAgIHBhcnRzW0RhdGVQYXJ0LkhvdXJzXSB8fCAwLFxuICAgICAgICAgICAgcGFydHNbRGF0ZVBhcnQuTWludXRlc10gfHwgMCxcbiAgICAgICAgICAgIHBhcnRzW0RhdGVQYXJ0LlNlY29uZHNdIHx8IDBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgbWFzayBpbnRvIGRhdGUvdGltZSBhbmQgbGl0ZXJhbCBwYXJ0c1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcGFyc2VEYXRlVGltZUZvcm1hdChtYXNrOiBzdHJpbmcsIGxvY2FsZTogc3RyaW5nID0gRGF0ZVBpY2tlclV0aWwuREVGQVVMVF9MT0NBTEUpOiBEYXRlUGFydEluZm9bXSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IG1hc2sgfHwgRGF0ZVBpY2tlclV0aWwuZ2V0RGVmYXVsdElucHV0Rm9ybWF0KGxvY2FsZSk7XG4gICAgICAgIGNvbnN0IGRhdGVUaW1lUGFydHM6IERhdGVQYXJ0SW5mb1tdID0gW107XG4gICAgICAgIGNvbnN0IGZvcm1hdEFycmF5ID0gQXJyYXkuZnJvbShmb3JtYXQpO1xuICAgICAgICBsZXQgY3VycmVudFBhcnQ6IERhdGVQYXJ0SW5mbyA9IG51bGw7XG4gICAgICAgIGxldCBwb3NpdGlvbiA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JtYXRBcnJheS5sZW5ndGg7IGkrKywgcG9zaXRpb24rKykge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IERhdGVQaWNrZXJVdGlsLmRldGVybWluZURhdGVQYXJ0KGZvcm1hdEFycmF5W2ldKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGFydCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGFydC50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJ0LmZvcm1hdCArPSBmb3JtYXRBcnJheVtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBmb3JtYXRBcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIERhdGVQaWNrZXJVdGlsLmVuc3VyZUxlYWRpbmdaZXJvKGN1cnJlbnRQYXJ0KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFydC5lbmQgPSBjdXJyZW50UGFydC5zdGFydCArIGN1cnJlbnRQYXJ0LmZvcm1hdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBjdXJyZW50UGFydC5lbmQ7XG4gICAgICAgICAgICAgICAgZGF0ZVRpbWVQYXJ0cy5wdXNoKGN1cnJlbnRQYXJ0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudFBhcnQgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIGVuZDogcG9zaXRpb24gKyBmb3JtYXRBcnJheVtpXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IGZvcm1hdEFycmF5W2ldXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGVUaW1lUGFydHM7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBnZXREZWZhdWx0SW5wdXRGb3JtYXQobG9jYWxlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBpZiAoIUludGwgfHwgIUludGwuRGF0ZVRpbWVGb3JtYXQgfHwgIUludGwuRGF0ZVRpbWVGb3JtYXQucHJvdG90eXBlLmZvcm1hdFRvUGFydHMpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGZhbGxiYWNrIHdpdGggSW50bC5mb3JtYXQgZm9yIElFP1xuICAgICAgICAgICAgcmV0dXJuIERhdGVQaWNrZXJVdGlsLlNIT1JUX0RBVEVfTUFTSztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0cyA9IERhdGVQaWNrZXJVdGlsLmdldERlZmF1bHRMb2NhbGVNYXNrKGxvY2FsZSk7XG4gICAgICAgIHBhcnRzLmZvckVhY2gocCA9PiB7XG4gICAgICAgICAgICBpZiAocC50eXBlICE9PSBEYXRlUGFydC5ZZWFyICYmIHAudHlwZSAhPT0gRGF0ZVBpY2tlclV0aWwuU0VQQVJBVE9SKSB7XG4gICAgICAgICAgICAgICAgcC5mb3JtYXRUeXBlID0gRm9ybWF0RGVzYy5Ud29EaWdpdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBEYXRlUGlja2VyVXRpbC5nZXRNYXNrKHBhcnRzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGZvcm1hdERhdGUodmFsdWU6IG51bWJlciB8IERhdGUsIGZvcm1hdDogc3RyaW5nLCBsb2NhbGU6IHN0cmluZywgdGltZXpvbmU/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBsZXQgZm9ybWF0dGVkRGF0ZTogc3RyaW5nO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9ybWF0dGVkRGF0ZSA9IGZvcm1hdERhdGUodmFsdWUsIGZvcm1hdCwgbG9jYWxlLCB0aW1lem9uZSk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgdGhpcy5sb2dNaXNzaW5nTG9jYWxlU2V0dGluZ3MobG9jYWxlKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSk7XG4gICAgICAgICAgICBmb3JtYXR0ZWREYXRlID0gZm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkRGF0ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldExvY2FsZURhdGVGb3JtYXQobG9jYWxlOiBzdHJpbmcsIGRpc3BsYXlGb3JtYXQ/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBmb3JtYXRLZXlzID0gT2JqZWN0LmtleXMoRm9ybWF0V2lkdGgpIGFzIChrZXlvZiBGb3JtYXRXaWR0aClbXTtcbiAgICAgICAgY29uc3QgdGFyZ2V0S2V5ID0gZm9ybWF0S2V5cy5maW5kKGsgPT4gay50b0xvd2VyQ2FzZSgpID09PSBkaXNwbGF5Rm9ybWF0Py50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ2RhdGUnLCAnJykpO1xuICAgICAgICBpZiAoIXRhcmdldEtleSkge1xuICAgICAgICAgICAgLy8gaWYgZGlzcGxheUZvcm1hdCBpcyBub3Qgc2hvcnREYXRlLCBsb25nRGF0ZSwgZXRjLlxuICAgICAgICAgICAgLy8gb3IgaWYgaXQgaXMgbm90IHNldCBieSB0aGUgdXNlclxuICAgICAgICAgICAgcmV0dXJuIGRpc3BsYXlGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZvcm1hdDogc3RyaW5nO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZ2V0TG9jYWxlRGF0ZUZvcm1hdChsb2NhbGUsIEZvcm1hdFdpZHRoW3RhcmdldEtleV0pO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHRoaXMubG9nTWlzc2luZ0xvY2FsZVNldHRpbmdzKGxvY2FsZSk7XG4gICAgICAgICAgICBmb3JtYXQgPSBEYXRlUGlja2VyVXRpbC5nZXREZWZhdWx0SW5wdXRGb3JtYXQobG9jYWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBpc0RhdGVPclRpbWVDaGFyKGNoYXI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gREFURV9DSEFSUy5pbmRleE9mKGNoYXIpICE9PSAtMSB8fCBUSU1FX0NIQVJTLmluZGV4T2YoY2hhcikgIT09IC0xO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgc3BpbkRhdGUoZGVsdGE6IG51bWJlciwgbmV3RGF0ZTogRGF0ZSwgaXNTcGluTG9vcDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBjb25zdCBtYXhEYXRlID0gRGF0ZVBpY2tlclV0aWwuZGF5c0luTW9udGgobmV3RGF0ZS5nZXRGdWxsWWVhcigpLCBuZXdEYXRlLmdldE1vbnRoKCkpO1xuICAgICAgICBsZXQgZGF0ZSA9IG5ld0RhdGUuZ2V0RGF0ZSgpICsgZGVsdGE7XG4gICAgICAgIGlmIChkYXRlID4gbWF4RGF0ZSkge1xuICAgICAgICAgICAgZGF0ZSA9IGlzU3Bpbkxvb3AgPyBkYXRlICUgbWF4RGF0ZSA6IG1heERhdGU7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0ZSA8IDEpIHtcbiAgICAgICAgICAgIGRhdGUgPSBpc1NwaW5Mb29wID8gbWF4RGF0ZSArIChkYXRlICUgbWF4RGF0ZSkgOiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3RGF0ZS5zZXREYXRlKGRhdGUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgc3Bpbk1vbnRoKGRlbHRhOiBudW1iZXIsIG5ld0RhdGU6IERhdGUsIGlzU3Bpbkxvb3A6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbWF4RGF0ZSA9IERhdGVQaWNrZXJVdGlsLmRheXNJbk1vbnRoKG5ld0RhdGUuZ2V0RnVsbFllYXIoKSwgbmV3RGF0ZS5nZXRNb250aCgpICsgZGVsdGEpO1xuICAgICAgICBpZiAobmV3RGF0ZS5nZXREYXRlKCkgPiBtYXhEYXRlKSB7XG4gICAgICAgICAgICBuZXdEYXRlLnNldERhdGUobWF4RGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtYXhNb250aCA9IDExO1xuICAgICAgICBjb25zdCBtaW5Nb250aCA9IDA7XG4gICAgICAgIGxldCBtb250aCA9IG5ld0RhdGUuZ2V0TW9udGgoKSArIGRlbHRhO1xuICAgICAgICBpZiAobW9udGggPiBtYXhNb250aCkge1xuICAgICAgICAgICAgbW9udGggPSBpc1NwaW5Mb29wID8gKG1vbnRoICUgbWF4TW9udGgpIC0gMSA6IG1heE1vbnRoO1xuICAgICAgICB9IGVsc2UgaWYgKG1vbnRoIDwgbWluTW9udGgpIHtcbiAgICAgICAgICAgIG1vbnRoID0gaXNTcGluTG9vcCA/IG1heE1vbnRoICsgKG1vbnRoICUgbWF4TW9udGgpICsgMSA6IG1pbk1vbnRoO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3RGF0ZS5zZXRNb250aChtb250aCk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBzcGluWWVhcihkZWx0YTogbnVtYmVyLCBuZXdEYXRlOiBEYXRlKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG1heERhdGUgPSBEYXRlUGlja2VyVXRpbC5kYXlzSW5Nb250aChuZXdEYXRlLmdldEZ1bGxZZWFyKCkgKyBkZWx0YSwgbmV3RGF0ZS5nZXRNb250aCgpKTtcbiAgICAgICAgaWYgKG5ld0RhdGUuZ2V0RGF0ZSgpID4gbWF4RGF0ZSkge1xuICAgICAgICAgICAgLy8gY2xpcCB0byBtYXggdG8gYXZvaWQgbGVhcCB5ZWFyIGNoYW5nZSBzaGlmdGluZyB0aGUgZW50aXJlIHZhbHVlXG4gICAgICAgICAgICBuZXdEYXRlLnNldERhdGUobWF4RGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3RGF0ZS5zZXRGdWxsWWVhcihuZXdEYXRlLmdldEZ1bGxZZWFyKCkgKyBkZWx0YSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBzcGluSG91cnMoZGVsdGE6IG51bWJlciwgbmV3RGF0ZTogRGF0ZSwgaXNTcGluTG9vcDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBjb25zdCBtYXhIb3VyID0gMjM7XG4gICAgICAgIGNvbnN0IG1pbkhvdXIgPSAwO1xuICAgICAgICBsZXQgaG91cnMgPSBuZXdEYXRlLmdldEhvdXJzKCkgKyBkZWx0YTtcbiAgICAgICAgaWYgKGhvdXJzID4gbWF4SG91cikge1xuICAgICAgICAgICAgaG91cnMgPSBpc1NwaW5Mb29wID8gaG91cnMgJSBtYXhIb3VyIC0gMSA6IG1heEhvdXI7XG4gICAgICAgIH0gZWxzZSBpZiAoaG91cnMgPCBtaW5Ib3VyKSB7XG4gICAgICAgICAgICBob3VycyA9IGlzU3Bpbkxvb3AgPyBtYXhIb3VyICsgKGhvdXJzICUgbWF4SG91cikgKyAxIDogbWluSG91cjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0RhdGUuc2V0SG91cnMoaG91cnMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgc3Bpbk1pbnV0ZXMoZGVsdGE6IG51bWJlciwgbmV3RGF0ZTogRGF0ZSwgaXNTcGluTG9vcDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBjb25zdCBtYXhNaW51dGVzID0gNTk7XG4gICAgICAgIGNvbnN0IG1pbk1pbnV0ZXMgPSAwO1xuICAgICAgICBsZXQgbWludXRlcyA9IG5ld0RhdGUuZ2V0TWludXRlcygpICsgZGVsdGE7XG4gICAgICAgIGlmIChtaW51dGVzID4gbWF4TWludXRlcykge1xuICAgICAgICAgICAgbWludXRlcyA9IGlzU3Bpbkxvb3AgPyBtaW51dGVzICUgbWF4TWludXRlcyAtIDEgOiBtYXhNaW51dGVzO1xuICAgICAgICB9IGVsc2UgaWYgKG1pbnV0ZXMgPCBtaW5NaW51dGVzKSB7XG4gICAgICAgICAgICBtaW51dGVzID0gaXNTcGluTG9vcCA/IG1heE1pbnV0ZXMgKyAobWludXRlcyAlIG1heE1pbnV0ZXMpICsgMSA6IG1pbk1pbnV0ZXM7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdEYXRlLnNldE1pbnV0ZXMobWludXRlcyk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBzcGluU2Vjb25kcyhkZWx0YTogbnVtYmVyLCBuZXdEYXRlOiBEYXRlLCBpc1NwaW5Mb29wOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG1heFNlY29uZHMgPSA1OTtcbiAgICAgICAgY29uc3QgbWluU2Vjb25kcyA9IDA7XG4gICAgICAgIGxldCBzZWNvbmRzID0gbmV3RGF0ZS5nZXRTZWNvbmRzKCkgKyBkZWx0YTtcbiAgICAgICAgaWYgKHNlY29uZHMgPiBtYXhTZWNvbmRzKSB7XG4gICAgICAgICAgICBzZWNvbmRzID0gaXNTcGluTG9vcCA/IHNlY29uZHMgJSBtYXhTZWNvbmRzIC0gMSA6IG1heFNlY29uZHM7XG4gICAgICAgIH0gZWxzZSBpZiAoc2Vjb25kcyA8IG1pblNlY29uZHMpIHtcbiAgICAgICAgICAgIHNlY29uZHMgPSBpc1NwaW5Mb29wID8gbWF4U2Vjb25kcyArIChzZWNvbmRzICUgbWF4U2Vjb25kcykgKyAxIDogbWluU2Vjb25kcztcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0RhdGUuc2V0U2Vjb25kcyhzZWNvbmRzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHNwaW5BbVBtKG5ld0RhdGU6IERhdGUsIGN1cnJlbnREYXRlOiBEYXRlLCBhbVBtRnJvbU1hc2s6IHN0cmluZyk6IERhdGUge1xuICAgICAgICBzd2l0Y2ggKGFtUG1Gcm9tTWFzaykge1xuICAgICAgICAgICAgY2FzZSAnQU0nOlxuICAgICAgICAgICAgICAgIG5ld0RhdGUgPSBuZXcgRGF0ZShuZXdEYXRlLnNldEhvdXJzKG5ld0RhdGUuZ2V0SG91cnMoKSArIDEyKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdQTSc6XG4gICAgICAgICAgICAgICAgbmV3RGF0ZSA9IG5ldyBEYXRlKG5ld0RhdGUuc2V0SG91cnMobmV3RGF0ZS5nZXRIb3VycygpIC0gMTIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3RGF0ZS5nZXREYXRlKCkgIT09IGN1cnJlbnREYXRlLmdldERhdGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld0RhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHByb3ZpZGVkIG1heCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gaW5jbHVkZVRpbWUgc2V0IHRvIGZhbHNlIGlmIHlvdSB3YW50IHRvIGV4Y2x1ZGUgdGltZSBwb3J0aW9uIG9mIHRoZSB0d28gZGF0ZXNcbiAgICAgKiBAcGFyYW0gaW5jbHVkZURhdGUgc2V0IHRvIGZhbHNlIGlmIHlvdSB3YW50IHRvIGV4Y2x1ZGUgdGhlIGRhdGUgcG9ydGlvbiBvZiB0aGUgdHdvIGRhdGVzXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBwcm92aWRlZCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gcHJvdmlkZWQgbWF4VmFsdWVcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdyZWF0ZXJUaGFuTWF4VmFsdWUodmFsdWU6IERhdGUsIG1heFZhbHVlOiBEYXRlLCBpbmNsdWRlVGltZSA9IHRydWUsIGluY2x1ZGVEYXRlID0gdHJ1ZSk6IGJvb2xlYW4ge1xuICAgICAgICAvLyBUT0RPOiBjaGVjayBpZiBwcm92aWRlZCBkYXRlcyBhcmUgdmFsaWQgZGF0ZXMgYW5kIG5vdCBJbnZhbGlkIERhdGVcbiAgICAgICAgLy8gaWYgbWF4VmFsdWUgaXMgSW52YWxpZCBEYXRlIGFuZCB2YWx1ZSBpcyB2YWxpZCBkYXRlIHRoaXMgd2lsbCByZXR1cm46XG4gICAgICAgIC8vIC0gZmFsc2UgaWYgaW5jbHVkZURhdGUgaXMgdHJ1ZVxuICAgICAgICAvLyAtIHRydWUgaWYgaW5jbHVkZURhdGUgaXMgZmFsc2VcbiAgICAgICAgaWYgKGluY2x1ZGVUaW1lICYmIGluY2x1ZGVEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuZ2V0VGltZSgpID4gbWF4VmFsdWUuZ2V0VGltZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgX3ZhbHVlID0gbmV3IERhdGUodmFsdWUuZ2V0VGltZSgpKTtcbiAgICAgICAgY29uc3QgX21heFZhbHVlID0gbmV3IERhdGUobWF4VmFsdWUuZ2V0VGltZSgpKTtcbiAgICAgICAgaWYgKCFpbmNsdWRlVGltZSkge1xuICAgICAgICAgICAgX3ZhbHVlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICAgICAgX21heFZhbHVlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW5jbHVkZURhdGUpIHtcbiAgICAgICAgICAgIF92YWx1ZS5zZXRGdWxsWWVhcigwLCAwLCAwKTtcbiAgICAgICAgICAgIF9tYXhWYWx1ZS5zZXRGdWxsWWVhcigwLCAwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdmFsdWUuZ2V0VGltZSgpID4gX21heFZhbHVlLmdldFRpbWUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgcHJvdmlkZWQgbWluIHZhbHVlLlxuICAgICAqIEBwYXJhbSBpbmNsdWRlVGltZSBzZXQgdG8gZmFsc2UgaWYgeW91IHdhbnQgdG8gZXhjbHVkZSB0aW1lIHBvcnRpb24gb2YgdGhlIHR3byBkYXRlc1xuICAgICAqIEBwYXJhbSBpbmNsdWRlRGF0ZSBzZXQgdG8gZmFsc2UgaWYgeW91IHdhbnQgdG8gZXhjbHVkZSB0aGUgZGF0ZSBwb3J0aW9uIG9mIHRoZSB0d28gZGF0ZXNcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHByb3ZpZGVkIHZhbHVlIGlzIGxlc3MgdGhhbiBwcm92aWRlZCBtaW5WYWx1ZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgbGVzc1RoYW5NaW5WYWx1ZSh2YWx1ZTogRGF0ZSwgbWluVmFsdWU6IERhdGUsIGluY2x1ZGVUaW1lID0gdHJ1ZSwgaW5jbHVkZURhdGUgPSB0cnVlKTogYm9vbGVhbiB7XG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGlmIHByb3ZpZGVkIGRhdGVzIGFyZSB2YWxpZCBkYXRlcyBhbmQgbm90IEludmFsaWQgRGF0ZVxuICAgICAgICAvLyBpZiB2YWx1ZSBpcyBJbnZhbGlkIERhdGUgYW5kIG1pblZhbHVlIGlzIHZhbGlkIGRhdGUgdGhpcyB3aWxsIHJldHVybjpcbiAgICAgICAgLy8gLSBmYWxzZSBpZiBpbmNsdWRlRGF0ZSBpcyB0cnVlXG4gICAgICAgIC8vIC0gdHJ1ZSBpZiBpbmNsdWRlRGF0ZSBpcyBmYWxzZVxuICAgICAgICBpZiAoaW5jbHVkZVRpbWUgJiYgaW5jbHVkZURhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5nZXRUaW1lKCkgPCBtaW5WYWx1ZS5nZXRUaW1lKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBfdmFsdWUgPSBuZXcgRGF0ZSh2YWx1ZS5nZXRUaW1lKCkpO1xuICAgICAgICBjb25zdCBfbWluVmFsdWUgPSBuZXcgRGF0ZShtaW5WYWx1ZS5nZXRUaW1lKCkpO1xuICAgICAgICBpZiAoIWluY2x1ZGVUaW1lKSB7XG4gICAgICAgICAgICBfdmFsdWUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICBfbWluVmFsdWUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbmNsdWRlRGF0ZSkge1xuICAgICAgICAgICAgX3ZhbHVlLnNldEZ1bGxZZWFyKDAsIDAsIDApO1xuICAgICAgICAgICAgX21pblZhbHVlLnNldEZ1bGxZZWFyKDAsIDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF92YWx1ZS5nZXRUaW1lKCkgPCBfbWluVmFsdWUuZ2V0VGltZSgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGxvZ01pc3NpbmdMb2NhbGVTZXR0aW5ncyhsb2NhbGU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBjb25zb2xlLndhcm4oYE1pc3NpbmcgbG9jYWxlIGRhdGEgZm9yIHRoZSBsb2NhbGUgJHtsb2NhbGV9LiBQbGVhc2UgcmVmZXIgdG8gaHR0cHM6Ly9hbmd1bGFyLmlvL2d1aWRlL2kxOG4jaTE4bi1waXBlc2ApO1xuICAgICAgICBjb25zb2xlLndhcm4oJ1VzaW5nIGRlZmF1bHQgYnJvd3NlciBsb2NhbGUgc2V0dGluZ3MuJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZW5zdXJlTGVhZGluZ1plcm8ocGFydDogRGF0ZVBhcnRJbmZvKSB7XG4gICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIERhdGVQYXJ0LkRhdGU6XG4gICAgICAgICAgICBjYXNlIERhdGVQYXJ0Lk1vbnRoOlxuICAgICAgICAgICAgY2FzZSBEYXRlUGFydC5Ib3VyczpcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnQuTWludXRlczpcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnQuU2Vjb25kczpcbiAgICAgICAgICAgICAgICBpZiAocGFydC5mb3JtYXQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnQuZm9ybWF0ID0gcGFydC5mb3JtYXQucmVwZWF0KDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldENsZWFuVmFsKGlucHV0RGF0YTogc3RyaW5nLCBkYXRlUGFydDogRGF0ZVBhcnRJbmZvLCBwcm9tcHRDaGFyPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIERhdGVQaWNrZXJVdGlsLnRyaW1FbXB0eVBsYWNlaG9sZGVycyhpbnB1dERhdGEuc3Vic3RyaW5nKGRhdGVQYXJ0LnN0YXJ0LCBkYXRlUGFydC5lbmQpLCBwcm9tcHRDaGFyKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBkZXRlcm1pbmVEYXRlUGFydChjaGFyOiBzdHJpbmcpOiBEYXRlUGFydCB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICBjYXNlICdEJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZVBhcnQuRGF0ZTtcbiAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlUGFydC5Nb250aDtcbiAgICAgICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgICAgY2FzZSAnWSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVQYXJ0LlllYXI7XG4gICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlUGFydC5Ib3VycztcbiAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlUGFydC5NaW51dGVzO1xuICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZVBhcnQuU2Vjb25kcztcbiAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVQYXJ0LkFtUG07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlUGFydC5MaXRlcmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgZ2VuZXJhdGVzIGRhdGUgcGFydHMgc3RydWN0dXJlIGJhc2VkIG9uIGVkaXRvciBtYXNrIGFuZCBsb2NhbGUuXG4gICAgICogQHBhcmFtIG1hc2tWYWx1ZTogc3RyaW5nXG4gICAgICogQHBhcmFtIGxvY2FsZTogc3RyaW5nXG4gICAgICogQHJldHVybnMgYXJyYXkgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCBkYXRlIHBhcnRzIC0gdHlwZSwgcG9zaXRpb24sIGZvcm1hdFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcGFyc2VEYXRlRm9ybWF0KG1hc2tWYWx1ZTogc3RyaW5nLCBsb2NhbGU6IHN0cmluZyA9IERhdGVQaWNrZXJVdGlsLkRFRkFVTFRfTE9DQUxFKTogYW55W10ge1xuICAgICAgICBsZXQgZGF0ZVN0cnVjdCA9IFtdO1xuICAgICAgICBpZiAobWFza1ZhbHVlID09PSB1bmRlZmluZWQgJiYgIWlzSUUoKSkge1xuICAgICAgICAgICAgZGF0ZVN0cnVjdCA9IERhdGVQaWNrZXJVdGlsLmdldERlZmF1bHRMb2NhbGVNYXNrKGxvY2FsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtYXNrID0gKG1hc2tWYWx1ZSkgPyBtYXNrVmFsdWUgOiBEYXRlUGlja2VyVXRpbC5TSE9SVF9EQVRFX01BU0s7XG4gICAgICAgICAgICBjb25zdCBtYXNrQXJyYXkgPSBBcnJheS5mcm9tKG1hc2spO1xuICAgICAgICAgICAgY29uc3QgbW9udGhJbml0UG9zaXRpb24gPSBtYXNrLmluZGV4T2YoRGF0ZUNoYXJzLk1vbnRoQ2hhcik7XG4gICAgICAgICAgICBjb25zdCBkYXlJbml0UG9zaXRpb24gPSBtYXNrLmluZGV4T2YoRGF0ZUNoYXJzLkRheUNoYXIpO1xuICAgICAgICAgICAgY29uc3QgeWVhckluaXRQb3NpdGlvbiA9IG1hc2suaW5kZXhPZihEYXRlQ2hhcnMuWWVhckNoYXIpO1xuXG4gICAgICAgICAgICBpZiAoeWVhckluaXRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBkYXRlU3RydWN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBEYXRlUGFydHMuWWVhcixcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFBvc2l0aW9uOiB5ZWFySW5pdFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRUeXBlOiBEYXRlUGlja2VyVXRpbC5nZXRZZWFyRm9ybWF0VHlwZShtYXNrKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobW9udGhJbml0UG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZGF0ZVN0cnVjdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRGF0ZVBhcnRzLk1vbnRoLFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsUG9zaXRpb246IG1vbnRoSW5pdFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRUeXBlOiBEYXRlUGlja2VyVXRpbC5nZXRNb250aEZvcm1hdFR5cGUobWFzaylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRheUluaXRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBkYXRlU3RydWN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBEYXRlUGFydHMuRGF5LFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsUG9zaXRpb246IGRheUluaXRQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0VHlwZTogRGF0ZVBpY2tlclV0aWwuZ2V0RGF5Rm9ybWF0VHlwZShtYXNrKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hc2tBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghRGF0ZVBpY2tlclV0aWwuaXNEYXRlQ2hhcihtYXNrQXJyYXlbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVTdHJ1Y3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBEYXRlUGlja2VyVXRpbC5TRVBBUkFUT1IsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsUG9zaXRpb246IGksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWFza0FycmF5W2ldXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0ZVN0cnVjdC5zb3J0KChhLCBiKSA9PiBhLmluaXRpYWxQb3NpdGlvbiAtIGIuaW5pdGlhbFBvc2l0aW9uKTtcbiAgICAgICAgICAgIERhdGVQaWNrZXJVdGlsLmZpbGxEYXRlUGFydHNQb3NpdGlvbnMoZGF0ZVN0cnVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVTdHJ1Y3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgZ2VuZXJhdGVzIGlucHV0IG1hc2sgYmFzZWQgb24gZGF0ZSBwYXJ0cy5cbiAgICAgKiBAcGFyYW0gZGF0ZVN0cnVjdCBhcnJheVxuICAgICAqIEByZXR1cm5zIGlucHV0IG1hc2tcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdldElucHV0TWFzayhkYXRlU3RydWN0OiBhbnlbXSk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGlucHV0TWFzayA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGVTdHJ1Y3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChkYXRlU3RydWN0W2ldLnR5cGUgPT09IERhdGVQaWNrZXJVdGlsLlNFUEFSQVRPUikge1xuICAgICAgICAgICAgICAgIGlucHV0TWFzay5wdXNoKGRhdGVTdHJ1Y3RbaV0udmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRlU3RydWN0W2ldLnR5cGUgPT09IERhdGVQYXJ0cy5EYXkgfHwgZGF0ZVN0cnVjdFtpXS50eXBlID09PSBEYXRlUGFydHMuTW9udGgpIHtcbiAgICAgICAgICAgICAgICBpbnB1dE1hc2sucHVzaCgnMDAnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0ZVN0cnVjdFtpXS50eXBlID09PSBEYXRlUGFydHMuWWVhcikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZGF0ZVN0cnVjdFtpXS5mb3JtYXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRm9ybWF0RGVzYy5OdW1lcmljOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dE1hc2sucHVzaCgnMDAwMCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBGb3JtYXREZXNjLlR3b0RpZ2l0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRNYXNrLnB1c2goJzAwJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXRNYXNrLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGdlbmVyYXRlcyBlZGl0b3IgbWFzay5cbiAgICAgKiBAcGFyYW0gZGF0ZVN0cnVjdFxuICAgICAqIEByZXR1cm5zIGVkaXRvciBtYXNrXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRNYXNrKGRhdGVTdHJ1Y3Q6IGFueVtdKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgbWFzayA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGVTdHJ1Y3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZGF0ZVN0cnVjdFtpXS5mb3JtYXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBGb3JtYXREZXNjLk51bWVyaWM6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGVTdHJ1Y3RbaV0udHlwZSA9PT0gRGF0ZVBhcnRzLkRheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzay5wdXNoKCdkJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0ZVN0cnVjdFtpXS50eXBlID09PSBEYXRlUGFydHMuTW9udGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2sucHVzaCgnTScpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzay5wdXNoKCd5eXl5Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgRm9ybWF0RGVzYy5Ud29EaWdpdHM6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGVTdHJ1Y3RbaV0udHlwZSA9PT0gRGF0ZVBhcnRzLkRheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzay5wdXNoKCdkZCcpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGVTdHJ1Y3RbaV0udHlwZSA9PT0gRGF0ZVBhcnRzLk1vbnRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrLnB1c2goJ01NJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrLnB1c2goJ3l5Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRlU3RydWN0W2ldLnR5cGUgPT09IERhdGVQaWNrZXJVdGlsLlNFUEFSQVRPUikge1xuICAgICAgICAgICAgICAgIG1hc2sucHVzaChkYXRlU3RydWN0W2ldLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXNrLmpvaW4oJycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBwYXJzZXMgYW4gaW5wdXQgc3RyaW5nIGJhc2Ugb24gZGF0ZSBwYXJ0cyBhbmQgcmV0dXJucyBhIGRhdGUgYW5kIGl0cyB2YWxpZGF0aW9uIHN0YXRlLlxuICAgICAqIEBwYXJhbSBkYXRlRm9ybWF0UGFydHNcbiAgICAgKiBAcGFyYW0gcHJldkRhdGVWYWx1ZVxuICAgICAqIEBwYXJhbSBpbnB1dFZhbHVlXG4gICAgICogQHJldHVybnMgb2JqZWN0IGNvbnRhaW5pbmcgYSBkYXRlIGFuZCBpdHMgdmFsaWRhdGlvbiBzdGF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcGFyc2VEYXRlQXJyYXkoZGF0ZUZvcm1hdFBhcnRzOiBhbnlbXSwgcHJldkRhdGVWYWx1ZTogRGF0ZSwgaW5wdXRWYWx1ZTogc3RyaW5nKTogYW55IHtcbiAgICAgICAgY29uc3QgZGF5U3RyID0gRGF0ZVBpY2tlclV0aWwuZ2V0RGF5VmFsdWVGcm9tSW5wdXQoZGF0ZUZvcm1hdFBhcnRzLCBpbnB1dFZhbHVlKTtcbiAgICAgICAgY29uc3QgbW9udGhTdHIgPSBEYXRlUGlja2VyVXRpbC5nZXRNb250aFZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0cywgaW5wdXRWYWx1ZSk7XG4gICAgICAgIGNvbnN0IHllYXJTdHIgPSBEYXRlUGlja2VyVXRpbC5nZXRZZWFyVmFsdWVGcm9tSW5wdXQoZGF0ZUZvcm1hdFBhcnRzLCBpbnB1dFZhbHVlKTtcbiAgICAgICAgY29uc3QgeWVhckZvcm1hdCA9IERhdGVQaWNrZXJVdGlsLmdldERhdGVGb3JtYXRQYXJ0KGRhdGVGb3JtYXRQYXJ0cywgRGF0ZVBhcnRzLlllYXIpLmZvcm1hdFR5cGU7XG4gICAgICAgIGNvbnN0IGRheSA9IChkYXlTdHIgIT09ICcnKSA/IHBhcnNlSW50KGRheVN0ciwgMTApIDogMTtcbiAgICAgICAgY29uc3QgbW9udGggPSAobW9udGhTdHIgIT09ICcnKSA/IHBhcnNlSW50KG1vbnRoU3RyLCAxMCkgLSAxIDogMDtcblxuICAgICAgICBsZXQgeWVhcjtcbiAgICAgICAgaWYgKHllYXJTdHIgPT09ICcnKSB7XG4gICAgICAgICAgICB5ZWFyID0gKHllYXJGb3JtYXQgPT09IEZvcm1hdERlc2MuVHdvRGlnaXRzKSA/ICcwMCcgOiAnMjAwMCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5ZWFyID0geWVhclN0cjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeWVhclByZWZpeDtcbiAgICAgICAgaWYgKHByZXZEYXRlVmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsWWVhciA9IHByZXZEYXRlVmFsdWUuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsWWVhci5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICB5ZWFyUHJlZml4ID0gb3JpZ2luYWxZZWFyLnN1YnN0cmluZygwLCAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHllYXJQcmVmaXggPSAnMjAnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bGxZZWFyID0gKHllYXJGb3JtYXQgPT09IEZvcm1hdERlc2MuVHdvRGlnaXRzKSA/IHllYXJQcmVmaXguY29uY2F0KHllYXIpIDogeWVhcjtcblxuICAgICAgICBpZiAoKG1vbnRoIDwgMCkgfHwgKG1vbnRoID4gMTEpIHx8IChtb250aCA9PT0gTmFOKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IERhdGVTdGF0ZS5JbnZhbGlkLCB2YWx1ZTogaW5wdXRWYWx1ZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChkYXkgPCAxKSB8fCAoZGF5ID4gRGF0ZVBpY2tlclV0aWwuZGF5c0luTW9udGgoZnVsbFllYXIsIG1vbnRoKSkgfHwgKGRheSA9PT0gTmFOKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IERhdGVTdGF0ZS5JbnZhbGlkLCB2YWx1ZTogaW5wdXRWYWx1ZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IERhdGVTdGF0ZS5WYWxpZCwgZGF0ZTogbmV3IERhdGUoZnVsbFllYXIsIG1vbnRoLCBkYXkpIH07XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBtYXNrVG9Qcm9tcHRDaGFycyhtYXNrOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBtYXNrLnJlcGxhY2UoLzB8TC9nLCBEYXRlUGlja2VyVXRpbC5QUk9NUFRfQ0hBUik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmVwbGFjZXMgcHJvbXB0IGNoYXJzIHdpdGggZW1wdHkgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgdHJpbUVtcHR5UGxhY2Vob2xkZXJzKHZhbHVlOiBzdHJpbmcsIHByb21wdENoYXI/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5yZXBsYWNlKG5ldyBSZWdFeHAocHJvbXB0Q2hhciB8fCAnXycsICdnJyksICcnKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGZvciBzcGlubmluZyBkYXRlIHBhcnRzLlxuICAgICAqIEBwYXJhbSBkYXRlRm9ybWF0UGFydHNcbiAgICAgKiBAcGFyYW0gaW5wdXRWYWx1ZVxuICAgICAqIEBwYXJhbSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBkZWx0YVxuICAgICAqIEBwYXJhbSBpc1NwaW5Mb29wXG4gICAgICogQHJldHVybiBtb2RpZmllZCB0ZXh0IGlucHV0XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRNb2RpZmllZERhdGVJbnB1dChkYXRlRm9ybWF0UGFydHM6IGFueVtdLFxuICAgICAgICBpbnB1dFZhbHVlOiBzdHJpbmcsXG4gICAgICAgIHBvc2l0aW9uOiBudW1iZXIsXG4gICAgICAgIGRlbHRhOiBudW1iZXIsXG4gICAgICAgIGlzU3Bpbkxvb3A6IGJvb2xlYW4pOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBkYXRlUGFydCA9IERhdGVQaWNrZXJVdGlsLmdldERhdGVQYXJ0T25Qb3NpdGlvbihkYXRlRm9ybWF0UGFydHMsIHBvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgZGF0ZVBhcnRUeXBlID0gZGF0ZVBhcnQudHlwZTtcbiAgICAgICAgY29uc3QgZGF0ZVBhcnRGb3JtYXRUeXBlID0gZGF0ZVBhcnQuZm9ybWF0VHlwZTtcbiAgICAgICAgbGV0IG5ld1ZhbHVlO1xuXG4gICAgICAgIGNvbnN0IGRhdGVQYXJ0VmFsdWUgPSBEYXRlUGlja2VyVXRpbC5nZXREYXRlVmFsdWVGcm9tSW5wdXQoZGF0ZUZvcm1hdFBhcnRzLCBkYXRlUGFydFR5cGUsIGlucHV0VmFsdWUpO1xuICAgICAgICBuZXdWYWx1ZSA9IHBhcnNlSW50KGRhdGVQYXJ0VmFsdWUsIDEwKTtcblxuICAgICAgICBsZXQgbWF4VmFsdWUsIG1pblZhbHVlO1xuICAgICAgICBjb25zdCBtaW5NYXggPSBEYXRlUGlja2VyVXRpbC5nZXRNaW5NYXhWYWx1ZShkYXRlRm9ybWF0UGFydHMsIGRhdGVQYXJ0LCBpbnB1dFZhbHVlKTtcbiAgICAgICAgbWluVmFsdWUgPSBtaW5NYXgubWluO1xuICAgICAgICBtYXhWYWx1ZSA9IG1pbk1heC5tYXg7XG5cbiAgICAgICAgaWYgKGlzTmFOKG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKG1pblZhbHVlID09PSAnaW5maW5pdGUnKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSAyMDAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG1pblZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0ZW1wVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgdGVtcFZhbHVlICs9IGRlbHRhO1xuXG4gICAgICAgIC8vIEluZmluaXRlIGxvb3AgZm9yIGZ1bGwgeWVhcnNcbiAgICAgICAgaWYgKG1heFZhbHVlID09PSAnaW5maW5pdGUnICYmIG1pblZhbHVlID09PSAnaW5maW5pdGUnKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRlbXBWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1NwaW5Mb29wKSB7XG4gICAgICAgICAgICBpZiAodGVtcFZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0ZW1wVmFsdWUgPSBtaW5WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZW1wVmFsdWUgPCBtaW5WYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRlbXBWYWx1ZSA9IG1heFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VmFsdWUgPSB0ZW1wVmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGVtcFZhbHVlIDw9IG1heFZhbHVlICYmIHRlbXBWYWx1ZSA+PSBtaW5WYWx1ZSkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGVtcFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhcnRJZHggPSBkYXRlUGFydC5wb3NpdGlvblswXTtcbiAgICAgICAgY29uc3QgZW5kSWR4ID0gZGF0ZVBhcnQucG9zaXRpb25bMV07XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gaW5wdXRWYWx1ZS5zbGljZSgwLCBzdGFydElkeCk7XG4gICAgICAgIGNvbnN0IGVuZCA9IGlucHV0VmFsdWUuc2xpY2UoZW5kSWR4LCBpbnB1dFZhbHVlLmxlbmd0aCk7XG4gICAgICAgIGxldCBjaGFuZ2VkUGFydDogc3RyaW5nO1xuXG4gICAgICAgIGNvbnN0IHByZWZpeCA9IERhdGVQaWNrZXJVdGlsLmdldE51bWVyaWNGb3JtYXRQcmVmaXgoZGF0ZVBhcnRGb3JtYXRUeXBlKTtcbiAgICAgICAgY2hhbmdlZFBhcnQgPSAobmV3VmFsdWUgPCAxMCkgPyBgJHtwcmVmaXh9JHtuZXdWYWx1ZX1gIDogYCR7bmV3VmFsdWV9YDtcblxuICAgICAgICByZXR1cm4gYCR7c3RhcnR9JHtjaGFuZ2VkUGFydH0ke2VuZH1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgZGF0ZSBpbnB1dCB3aXRoIHByb21wdCBjaGFycy5cbiAgICAgKiBAcGFyYW0gZGF0ZUZvcm1hdFBhcnRzXG4gICAgICogQHBhcmFtIGRhdGVcbiAgICAgKiBAcGFyYW0gaW5wdXRWYWx1ZVxuICAgICAqIEByZXR1cm5zIGRhdGUgaW5wdXQgaW5jbHVkaW5nIHByb21wdCBjaGFyc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYWRkUHJvbXB0Q2hhcnNFZGl0TW9kZShkYXRlRm9ybWF0UGFydHM6IGFueVtdLCBkYXRlOiBEYXRlLCBpbnB1dFZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBkYXRlQXJyYXkgPSBBcnJheS5mcm9tKGlucHV0VmFsdWUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGVGb3JtYXRQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGRhdGVGb3JtYXRQYXJ0c1tpXS5mb3JtYXRUeXBlID09PSBGb3JtYXREZXNjLk51bWVyaWMpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGRhdGVGb3JtYXRQYXJ0c1tpXS50eXBlID09PSBEYXRlUGFydHMuRGF5ICYmIGRhdGUuZ2V0RGF0ZSgpIDwgMTApXG4gICAgICAgICAgICAgICAgICAgIHx8IChkYXRlRm9ybWF0UGFydHNbaV0udHlwZSA9PT0gRGF0ZVBhcnRzLk1vbnRoICYmIGRhdGUuZ2V0TW9udGgoKSArIDEgPCAxMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUFycmF5LnNwbGljZShkYXRlRm9ybWF0UGFydHNbaV0ucG9zaXRpb25bMF0sIDAsIERhdGVQaWNrZXJVdGlsLlBST01QVF9DSEFSKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUFycmF5LmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZUFycmF5LmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGNoZWNrcyBpZiBkYXRlIGlucHV0IGlzIGRvbmUuXG4gICAgICogQHBhcmFtIGRhdGVGb3JtYXRQYXJ0c1xuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqIEByZXR1cm5zIGlucHV0IGNvbXBsZXRlbmVzc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgY2hlY2tGb3JDb21wbGV0ZURhdGVJbnB1dChkYXRlRm9ybWF0UGFydHM6IGFueVtdLCBpbnB1dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgZGF5VmFsdWUgPSBEYXRlUGlja2VyVXRpbC5nZXREYXlWYWx1ZUZyb21JbnB1dChkYXRlRm9ybWF0UGFydHMsIGlucHV0KTtcbiAgICAgICAgY29uc3QgbW9udGhWYWx1ZSA9IERhdGVQaWNrZXJVdGlsLmdldE1vbnRoVmFsdWVGcm9tSW5wdXQoZGF0ZUZvcm1hdFBhcnRzLCBpbnB1dCk7XG4gICAgICAgIGNvbnN0IHllYXJWYWx1ZSA9IERhdGVQaWNrZXJVdGlsLmdldFllYXJWYWx1ZUZyb21JbnB1dChkYXRlRm9ybWF0UGFydHMsIGlucHV0KTtcbiAgICAgICAgY29uc3QgZGF5U3RyID0gRGF0ZVBpY2tlclV0aWwuZ2V0RGF5VmFsdWVGcm9tSW5wdXQoZGF0ZUZvcm1hdFBhcnRzLCBpbnB1dCwgZmFsc2UpO1xuICAgICAgICBjb25zdCBtb250aFN0ciA9IERhdGVQaWNrZXJVdGlsLmdldE1vbnRoVmFsdWVGcm9tSW5wdXQoZGF0ZUZvcm1hdFBhcnRzLCBpbnB1dCwgZmFsc2UpO1xuXG4gICAgICAgIGlmIChEYXRlUGlja2VyVXRpbC5pc0Z1bGxJbnB1dChkYXlWYWx1ZSwgZGF5U3RyKVxuICAgICAgICAgICAgJiYgRGF0ZVBpY2tlclV0aWwuaXNGdWxsSW5wdXQobW9udGhWYWx1ZSwgbW9udGhTdHIpXG4gICAgICAgICAgICAmJiBEYXRlUGlja2VyVXRpbC5pc0Z1bGxZZWFySW5wdXQoZGF0ZUZvcm1hdFBhcnRzLCB5ZWFyVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NvbXBsZXRlJztcbiAgICAgICAgfSBlbHNlIGlmIChkYXlWYWx1ZSA9PT0gJycgJiYgbW9udGhWYWx1ZSA9PT0gJycgJiYgeWVhclZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuICdlbXB0eSc7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF5VmFsdWUgPT09ICcnIHx8IG1vbnRoVmFsdWUgPT09ICcnIHx8IHllYXJWYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiAncGFydGlhbCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZGF5c0luTW9udGgoZnVsbFllYXI6IG51bWJlciwgbW9udGg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShmdWxsWWVhciwgbW9udGggKyAxLCAwKS5nZXREYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgcHJvdmlkZWQgaW5wdXQgdG8gRGF0ZS5cbiAgICAgKiBAcGFyYW0gdmFsdWUgaW5wdXQgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJucyBEYXRlIGlmIHBhcnNlIHN1Y2NlZWQgb3IgbnVsbFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcGFyc2VEYXRlKHZhbHVlOiBhbnkpOiBEYXRlIHwgbnVsbCB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdmFsdWUgaXMgSW52YWxpZCBEYXRlIHdlIHNob3VsZCByZXR1cm4gbnVsbFxuICAgICAgICBpZiAodGhpcy5pc0RhdGUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkRGF0ZSh2YWx1ZSkgPyB2YWx1ZSA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWUgPyBuZXcgRGF0ZShEYXRlLnBhcnNlKHZhbHVlKSkgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBwcm92aWRlZCBpbnB1dCBpcyBkYXRlXG4gICAgICogQHBhcmFtIHZhbHVlIGlucHV0IHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBwcm92aWRlZCBpbnB1dCBpcyBkYXRlXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBpc0RhdGUodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgaW5wdXQgaXMgdmFsaWQgZGF0ZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBpbnB1dCB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIHRydWUgaWYgcHJvdmlkZWQgaW5wdXQgaXMgYSB2YWxpZCBkYXRlXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBpc1ZhbGlkRGF0ZSh2YWx1ZTogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzLmlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAhaXNOYU4odmFsdWUuZ2V0VGltZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRZZWFyRm9ybWF0VHlwZShmb3JtYXQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHN3aXRjaCAoZm9ybWF0Lm1hdGNoKG5ldyBSZWdFeHAoRGF0ZUNoYXJzLlllYXJDaGFyLCAnZycpKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIC8vIHkgKDIwMjApXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZvcm1hdERlc2MuTnVtZXJpYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgICAgIC8vIHl5eXkgKDIwMjApXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZvcm1hdERlc2MuTnVtZXJpYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgIC8vIHl5ICgyMClcbiAgICAgICAgICAgICAgICByZXR1cm4gRm9ybWF0RGVzYy5Ud29EaWdpdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRNb250aEZvcm1hdFR5cGUoZm9ybWF0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBzd2l0Y2ggKGZvcm1hdC5tYXRjaChuZXcgUmVnRXhwKERhdGVDaGFycy5Nb250aENoYXIsICdnJykpLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgLy8gTSAoOClcbiAgICAgICAgICAgICAgICByZXR1cm4gRm9ybWF0RGVzYy5OdW1lcmljO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgLy8gTU0gKDA4KVxuICAgICAgICAgICAgICAgIHJldHVybiBGb3JtYXREZXNjLlR3b0RpZ2l0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldERheUZvcm1hdFR5cGUoZm9ybWF0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBzd2l0Y2ggKGZvcm1hdC5tYXRjaChuZXcgUmVnRXhwKERhdGVDaGFycy5EYXlDaGFyLCAnZycpKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIC8vIGQgKDYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZvcm1hdERlc2MuTnVtZXJpYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgIC8vIGRkICgwNilcbiAgICAgICAgICAgICAgICByZXR1cm4gRm9ybWF0RGVzYy5Ud29EaWdpdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXREZWZhdWx0TG9jYWxlTWFzayhsb2NhbGU6IHN0cmluZykge1xuICAgICAgICBjb25zdCBkYXRlU3RydWN0ID0gW107XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSk7XG4gICAgICAgIGNvbnN0IGZvcm1hdFRvUGFydHMgPSBmb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyhuZXcgRGF0ZSgpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JtYXRUb1BhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9QYXJ0c1tpXS50eXBlID09PSBEYXRlUGlja2VyVXRpbC5TRVBBUkFUT1IpIHtcbiAgICAgICAgICAgICAgICBkYXRlU3RydWN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBEYXRlUGlja2VyVXRpbC5TRVBBUkFUT1IsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmb3JtYXRUb1BhcnRzW2ldLnZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGVTdHJ1Y3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGZvcm1hdFRvUGFydHNbaV0udHlwZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlck9wdGlvbnMgPSBmb3JtYXR0ZXIucmVzb2x2ZWRPcHRpb25zKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0ZVN0cnVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3dpdGNoIChkYXRlU3RydWN0W2ldLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIERhdGVQYXJ0cy5EYXk6IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVN0cnVjdFtpXS5mb3JtYXRUeXBlID0gZm9ybWF0dGVyT3B0aW9ucy5kYXk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIERhdGVQYXJ0cy5Nb250aDoge1xuICAgICAgICAgICAgICAgICAgICBkYXRlU3RydWN0W2ldLmZvcm1hdFR5cGUgPSBmb3JtYXR0ZXJPcHRpb25zLm1vbnRoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBEYXRlUGFydHMuWWVhcjoge1xuICAgICAgICAgICAgICAgICAgICBkYXRlU3RydWN0W2ldLmZvcm1hdFR5cGUgPSBmb3JtYXR0ZXJPcHRpb25zLnllYXI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBEYXRlUGlja2VyVXRpbC5maWxsRGF0ZVBhcnRzUG9zaXRpb25zKGRhdGVTdHJ1Y3QpO1xuICAgICAgICByZXR1cm4gZGF0ZVN0cnVjdDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBpc0RhdGVDaGFyKGNoYXI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKGNoYXIgPT09IERhdGVDaGFycy5ZZWFyQ2hhciB8fCBjaGFyID09PSBEYXRlQ2hhcnMuTW9udGhDaGFyIHx8IGNoYXIgPT09IERhdGVDaGFycy5EYXlDaGFyKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXROdW1lcmljRm9ybWF0UHJlZml4KGZvcm1hdFR5cGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHN3aXRjaCAoZm9ybWF0VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBGb3JtYXREZXNjLlR3b0RpZ2l0czoge1xuICAgICAgICAgICAgICAgIHJldHVybiAnMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEZvcm1hdERlc2MuTnVtZXJpYzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlUGlja2VyVXRpbC5QUk9NUFRfQ0hBUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldE1pbk1heFZhbHVlKGRhdGVGb3JtYXRQYXJ0czogYW55W10sIGRhdGVQYXJ0LCBpbnB1dFZhbHVlOiBzdHJpbmcpOiBhbnkge1xuICAgICAgICBsZXQgbWF4VmFsdWUsIG1pblZhbHVlO1xuICAgICAgICBzd2l0Y2ggKGRhdGVQYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnRzLk1vbnRoOiB7XG4gICAgICAgICAgICAgICAgbWluVmFsdWUgPSAxO1xuICAgICAgICAgICAgICAgIG1heFZhbHVlID0gRGF0ZVBpY2tlclV0aWwuTlVNQkVSX09GX01PTlRIUztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnRzLkRheToge1xuICAgICAgICAgICAgICAgIG1pblZhbHVlID0gMTtcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IERhdGVQaWNrZXJVdGlsLmRheXNJbk1vbnRoKFxuICAgICAgICAgICAgICAgICAgICBEYXRlUGlja2VyVXRpbC5nZXRGdWxsWWVhckZyb21TdHJpbmcoRGF0ZVBpY2tlclV0aWwuZ2V0RGF0ZUZvcm1hdFBhcnQoZGF0ZUZvcm1hdFBhcnRzLCBEYXRlUGFydHMuWWVhciksIGlucHV0VmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChEYXRlUGlja2VyVXRpbC5nZXRNb250aFZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0cywgaW5wdXRWYWx1ZSksIDEwKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIERhdGVQYXJ0cy5ZZWFyOiB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVQYXJ0LmZvcm1hdFR5cGUgPT09IEZvcm1hdERlc2MuVHdvRGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pblZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbWF4VmFsdWUgPSA5OTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbmZpbml0ZSBsb29wXG4gICAgICAgICAgICAgICAgICAgIG1pblZhbHVlID0gJ2luZmluaXRlJztcbiAgICAgICAgICAgICAgICAgICAgbWF4VmFsdWUgPSAnaW5maW5pdGUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtaW46IG1pblZhbHVlLCBtYXg6IG1heFZhbHVlIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0RGF0ZVZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0czogYW55W10sIHR5cGU6IERhdGVQYXJ0cywgaW5wdXRWYWx1ZTogc3RyaW5nLCB0cmltOiBib29sZWFuID0gdHJ1ZSk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHBhcnRQb3NpdGlvbiA9IERhdGVQaWNrZXJVdGlsLmdldERhdGVGb3JtYXRQYXJ0KGRhdGVGb3JtYXRQYXJ0cywgdHlwZSkucG9zaXRpb247XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGlucHV0VmFsdWUuc3Vic3RyaW5nKHBhcnRQb3NpdGlvblswXSwgcGFydFBvc2l0aW9uWzFdKTtcbiAgICAgICAgcmV0dXJuICh0cmltKSA/IERhdGVQaWNrZXJVdGlsLnRyaW1FbXB0eVBsYWNlaG9sZGVycyhyZXN1bHQpIDogcmVzdWx0O1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldERheVZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0czogYW55W10sIGlucHV0VmFsdWU6IHN0cmluZywgdHJpbTogYm9vbGVhbiA9IHRydWUpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gRGF0ZVBpY2tlclV0aWwuZ2V0RGF0ZVZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0cywgRGF0ZVBhcnRzLkRheSwgaW5wdXRWYWx1ZSwgdHJpbSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0TW9udGhWYWx1ZUZyb21JbnB1dChkYXRlRm9ybWF0UGFydHM6IGFueVtdLCBpbnB1dFZhbHVlOiBzdHJpbmcsIHRyaW06IGJvb2xlYW4gPSB0cnVlKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIERhdGVQaWNrZXJVdGlsLmdldERhdGVWYWx1ZUZyb21JbnB1dChkYXRlRm9ybWF0UGFydHMsIERhdGVQYXJ0cy5Nb250aCwgaW5wdXRWYWx1ZSwgdHJpbSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0WWVhclZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0czogYW55W10sIGlucHV0VmFsdWU6IHN0cmluZywgdHJpbTogYm9vbGVhbiA9IHRydWUpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gRGF0ZVBpY2tlclV0aWwuZ2V0RGF0ZVZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0cywgRGF0ZVBhcnRzLlllYXIsIGlucHV0VmFsdWUsIHRyaW0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldERhdGVGb3JtYXRQYXJ0KGRhdGVGb3JtYXRQYXJ0czogYW55W10sIHR5cGU6IERhdGVQYXJ0cyk6IGFueSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGRhdGVGb3JtYXRQYXJ0cy5maWx0ZXIoKGRhdGVQYXJ0KSA9PiAoZGF0ZVBhcnQudHlwZSA9PT0gdHlwZSkpWzBdO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGlzRnVsbElucHV0KHZhbHVlOiBhbnksIGlucHV0OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAhPT0gJycgJiYgaW5wdXQubGVuZ3RoID09PSAyICYmIGlucHV0LmNoYXJBdCgxKSAhPT0gRGF0ZVBpY2tlclV0aWwuUFJPTVBUX0NIQVIpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGlzRnVsbFllYXJJbnB1dChkYXRlRm9ybWF0UGFydHM6IGFueVtdLCB2YWx1ZTogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIHN3aXRjaCAoRGF0ZVBpY2tlclV0aWwuZ2V0RGF0ZUZvcm1hdFBhcnQoZGF0ZUZvcm1hdFBhcnRzLCBEYXRlUGFydHMuWWVhcikuZm9ybWF0VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBGb3JtYXREZXNjLk51bWVyaWM6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZhbHVlICE9PSAnJyAmJiB2YWx1ZS5sZW5ndGggPT09IDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBGb3JtYXREZXNjLlR3b0RpZ2l0czoge1xuICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWUgIT09ICcnICYmIHZhbHVlLmxlbmd0aCA9PT0gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0RGF0ZVBhcnRPblBvc2l0aW9uKGRhdGVGb3JtYXRQYXJ0czogYW55W10sIHBvc2l0aW9uOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZGF0ZUZvcm1hdFBhcnRzLmZpbHRlcigoZWxlbWVudCkgPT5cbiAgICAgICAgICAgIGVsZW1lbnQucG9zaXRpb25bMF0gPD0gcG9zaXRpb24gJiYgcG9zaXRpb24gPD0gZWxlbWVudC5wb3NpdGlvblsxXSAmJiBlbGVtZW50LnR5cGUgIT09IERhdGVQaWNrZXJVdGlsLlNFUEFSQVRPUilbMF07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0RnVsbFllYXJGcm9tU3RyaW5nKHllYXJQYXJ0LCBpbnB1dFZhbHVlKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0VmFsdWUuc3Vic3RyaW5nKHllYXJQYXJ0LnBvc2l0aW9uWzBdLCB5ZWFyUGFydC5wb3NpdGlvblsxXSksIDEwKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBmaWxsRGF0ZVBhcnRzUG9zaXRpb25zKGRhdGVBcnJheTogYW55W10pOiB2b2lkIHtcbiAgICAgICAgbGV0IGN1cnJlbnRQb3MgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0ZUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBEYXl8TW9udGggcGFydCBwb3NpdGlvbnNcbiAgICAgICAgICAgIGlmIChkYXRlQXJyYXlbaV0udHlwZSA9PT0gRGF0ZVBhcnRzLkRheSB8fCBkYXRlQXJyYXlbaV0udHlwZSA9PT0gRGF0ZVBhcnRzLk1vbnRoKSB7XG4gICAgICAgICAgICAgICAgLy8gT2Zmc2V0IDIgcG9zaXRpb25zIGZvciBudW1iZXJcbiAgICAgICAgICAgICAgICBkYXRlQXJyYXlbaV0ucG9zaXRpb24gPSBbY3VycmVudFBvcywgY3VycmVudFBvcyArIDJdO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgKz0gMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0ZUFycmF5W2ldLnR5cGUgPT09IERhdGVQYXJ0cy5ZZWFyKSB7XG4gICAgICAgICAgICAgICAgLy8gWWVhciBwYXJ0IHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZGF0ZUFycmF5W2ldLmZvcm1hdFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBGb3JtYXREZXNjLk51bWVyaWM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9mZnNldCA0IHBvc2l0aW9ucyBmb3IgZnVsbCB5ZWFyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlQXJyYXlbaV0ucG9zaXRpb24gPSBbY3VycmVudFBvcywgY3VycmVudFBvcyArIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvcyArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBGb3JtYXREZXNjLlR3b0RpZ2l0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2Zmc2V0IDIgcG9zaXRpb25zIGZvciBzaG9ydCB5ZWFyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlQXJyYXlbaV0ucG9zaXRpb24gPSBbY3VycmVudFBvcywgY3VycmVudFBvcyArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvcyArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGVBcnJheVtpXS50eXBlID09PSBEYXRlUGlja2VyVXRpbC5TRVBBUkFUT1IpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXBhcmF0b3IgcG9zaXRpb25zXG4gICAgICAgICAgICAgICAgZGF0ZUFycmF5W2ldLnBvc2l0aW9uID0gW2N1cnJlbnRQb3MsIGN1cnJlbnRQb3MgKyAxXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbiJdfQ==