import { IgxGridNavigationService } from '../grid-navigation.service';
import { first } from 'rxjs/operators';
import { SUPPORTED_KEYS, NAVIGATION_KEYS } from '../../core/utils';
import { Injectable } from '@angular/core';
import { IgxChildGridRowComponent } from './child-grid-row.component';
export class IgxHierarchicalGridNavigationService extends IgxGridNavigationService {
    constructor() {
        super(...arguments);
        this._pendingNavigation = false;
    }
    dispatchEvent(event) {
        const key = event.key.toLowerCase();
        if (!this.activeNode || !(SUPPORTED_KEYS.has(key) || (key === 'tab' && this.grid.crudService.cell)) &&
            !this.grid.crudService.rowEditingBlocked && !this.grid.rowInEditMode) {
            return;
        }
        const targetGrid = this.getClosestElemByTag(event.target, 'igx-hierarchical-grid');
        if (targetGrid !== this.grid.nativeElement) {
            return;
        }
        if (this._pendingNavigation && NAVIGATION_KEYS.has(key)) {
            // In case focus needs to be moved from one grid to another, however there is a pending scroll operation
            // which is an async operation, any additional navigation keys should be ignored
            // untill operation complete.
            event.preventDefault();
            return;
        }
        super.dispatchEvent(event);
    }
    navigateInBody(rowIndex, visibleColIndex, cb = null) {
        const rec = this.grid.dataView[rowIndex];
        if (rec && this.grid.isChildGridRecord(rec)) {
            // target is child grid
            const virtState = this.grid.verticalScrollContainer.state;
            const inView = rowIndex >= virtState.startIndex && rowIndex <= virtState.startIndex + virtState.chunkSize;
            const isNext = this.activeNode.row < rowIndex;
            const targetLayoutIndex = isNext ? null : this.grid.childLayoutKeys.length - 1;
            if (inView) {
                this._moveToChild(rowIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
            }
            else {
                let scrollAmount = this.grid.verticalScrollContainer.getScrollForIndex(rowIndex, !isNext);
                scrollAmount += isNext ? 1 : -1;
                this.grid.verticalScrollContainer.getScroll().scrollTop = scrollAmount;
                this._pendingNavigation = true;
                this.grid.verticalScrollContainer.onChunkLoad.pipe(first()).subscribe(() => {
                    this._moveToChild(rowIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
                    this._pendingNavigation = false;
                });
            }
            return;
        }
        const isLast = rowIndex === this.grid.dataView.length;
        if ((rowIndex === -1 || isLast) &&
            this.grid.parent !== null) {
            // reached end of child grid
            const nextSiblingIndex = this.nextSiblingIndex(isLast);
            if (nextSiblingIndex !== null) {
                this.grid.parent.navigation._moveToChild(this.grid.childRow.index, visibleColIndex, isLast, nextSiblingIndex, cb);
            }
            else {
                this._moveToParent(isLast, visibleColIndex, cb);
            }
            return;
        }
        if (this.grid.parent) {
            const isNext = this.activeNode && typeof this.activeNode.row === 'number' ? rowIndex > this.activeNode.row : false;
            const cbHandler = (args) => {
                this._handleScrollInChild(rowIndex, isNext);
                cb(args);
            };
            if (!this.activeNode) {
                this.activeNode = { row: null, column: null };
            }
            super.navigateInBody(rowIndex, visibleColIndex, cbHandler);
            return;
        }
        if (!this.activeNode) {
            this.activeNode = { row: null, column: null };
        }
        super.navigateInBody(rowIndex, visibleColIndex, cb);
    }
    shouldPerformVerticalScroll(index, visibleColumnIndex = -1, isNext) {
        const targetRec = this.grid.dataView[index];
        if (this.grid.isChildGridRecord(targetRec)) {
            const scrollAmount = this.grid.verticalScrollContainer.getScrollForIndex(index, !isNext);
            const currScroll = this.grid.verticalScrollContainer.getScroll().scrollTop;
            const shouldScroll = !isNext ? scrollAmount > currScroll : currScroll < scrollAmount;
            return shouldScroll;
        }
        else {
            return super.shouldPerformVerticalScroll(index, visibleColumnIndex);
        }
    }
    focusTbody(event) {
        if (!this.activeNode || this.activeNode.row === null) {
            this.activeNode = {
                row: 0,
                column: 0
            };
            this.grid.navigateTo(0, 0, (obj) => {
                this.grid.clearCellSelection();
                obj.target.activate(event);
            });
        }
        else {
            super.focusTbody(event);
        }
    }
    nextSiblingIndex(isNext) {
        const layoutKey = this.grid.childRow.layout.key;
        const layoutIndex = this.grid.parent.childLayoutKeys.indexOf(layoutKey);
        const nextIndex = isNext ? layoutIndex + 1 : layoutIndex - 1;
        if (nextIndex <= this.grid.parent.childLayoutKeys.length - 1 && nextIndex > -1) {
            return nextIndex;
        }
        else {
            return null;
        }
    }
    /**
     * Handles scrolling in child grid and ensures target child row is in main grid view port.
     * @param rowIndex The row index which should be in view.
     * @param isNext  Optional. Whether we are navigating to next. Used to determine scroll direction.
     * @param cb  Optional.Callback function called when operation is complete.
     */
    _handleScrollInChild(rowIndex, isNext, cb) {
        const shouldScroll = this.shouldPerformVerticalScroll(rowIndex, -1, isNext);
        if (shouldScroll) {
            this.grid.navigation.performVerticalScrollToCell(rowIndex, -1, () => {
                this.positionInParent(rowIndex, isNext, cb);
            });
        }
        else {
            this.positionInParent(rowIndex, isNext, cb);
        }
    }
    /**
     *
     * @param rowIndex Row index that should come in view.
     * @param isNext  Whether we are navigating to next. Used to determine scroll direction.
     * @param cb  Optional.Callback function called when operation is complete.
     */
    positionInParent(rowIndex, isNext, cb) {
        const rowObj = this.grid.getRowByIndex(rowIndex);
        if (!rowObj) {
            if (cb) {
                cb();
            }
            return;
        }
        const positionInfo = this.getPositionInfo(rowObj, isNext);
        if (!positionInfo.inView) {
            // stop event from triggering multiple times before scrolling is complete.
            this._pendingNavigation = true;
            const scrollableGrid = isNext ? this.getNextScrollableDown(this.grid) : this.getNextScrollableUp(this.grid);
            scrollableGrid.grid.verticalScrollContainer.recalcUpdateSizes();
            scrollableGrid.grid.verticalScrollContainer.addScrollTop(positionInfo.offset);
            scrollableGrid.grid.verticalScrollContainer.onChunkLoad.pipe(first()).subscribe(() => {
                this._pendingNavigation = false;
                if (cb) {
                    cb();
                }
            });
        }
        else {
            if (cb) {
                cb();
            }
        }
    }
    /**
     * Moves navigation to child grid.
     * @param parentRowIndex The parent row index, at which the child grid is rendered.
     * @param childLayoutIndex Optional. The index of the child row island to which the child grid belongs to. Uses first if not set.
     */
    _moveToChild(parentRowIndex, visibleColIndex, isNext, childLayoutIndex, cb) {
        const ri = typeof childLayoutIndex !== 'number' ?
            this.grid.childLayoutList.first : this.grid.childLayoutList.toArray()[childLayoutIndex];
        const rowId = this.grid.dataView[parentRowIndex].rowID;
        const pathSegment = {
            rowID: rowId,
            rowIslandKey: ri.key
        };
        const childGrid = this.grid.hgridAPI.getChildGrid([pathSegment]);
        const targetIndex = isNext ? 0 : childGrid.dataView.length - 1;
        const targetRec = childGrid.dataView[targetIndex];
        if (!targetRec) {
            // if no target rec, then move on in next sibling or parent
            childGrid.navigation.navigateInBody(targetIndex, visibleColIndex, cb);
            return;
        }
        if (childGrid.isChildGridRecord(targetRec)) {
            // if target is a child grid record should move into it.
            this.grid.navigation.activeNode.row = null;
            childGrid.navigation.activeNode = { row: targetIndex, column: this.activeNode.column };
            childGrid.navigation._handleScrollInChild(targetIndex, isNext, () => {
                const targetLayoutIndex = isNext ? 0 : childGrid.childLayoutList.toArray().length - 1;
                childGrid.navigation._moveToChild(targetIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
            });
            return;
        }
        const childGridNav = childGrid.navigation;
        this.clearActivation();
        const lastVisibleIndex = childGridNav.lastColumnIndex;
        const columnIndex = visibleColIndex <= lastVisibleIndex ? visibleColIndex : lastVisibleIndex;
        childGridNav.activeNode = { row: targetIndex, column: columnIndex };
        childGrid.tbody.nativeElement.focus({ preventScroll: true });
        this._pendingNavigation = false;
        childGrid.navigation._handleScrollInChild(targetIndex, isNext, () => {
            childGrid.navigateTo(targetIndex, columnIndex, cb);
        });
    }
    /**
     * Moves navigation back to parent grid.
     * @param rowIndex
     */
    _moveToParent(isNext, columnIndex, cb) {
        const indexInParent = this.grid.childRow.index;
        const hasNextTarget = this.hasNextTarget(this.grid.parent, indexInParent, isNext);
        if (!hasNextTarget) {
            return;
        }
        this.clearActivation();
        const targetRowIndex = isNext ? indexInParent + 1 : indexInParent - 1;
        const lastVisibleIndex = this.grid.parent.navigation.lastColumnIndex;
        const nextColumnIndex = columnIndex <= lastVisibleIndex ? columnIndex : lastVisibleIndex;
        this._pendingNavigation = true;
        const cbFunc = (args) => {
            this._pendingNavigation = false;
            cb(args);
            args.target.grid.tbody.nativeElement.focus();
        };
        this.grid.parent.navigation.navigateInBody(targetRowIndex, nextColumnIndex, cbFunc);
    }
    /**
     * Gets information on the row position relative to the root grid view port.
     * Returns whether the row is in view and its offset.
     * @param rowObj
     * @param isNext
     */
    getPositionInfo(rowObj, isNext) {
        let rowElem = rowObj.nativeElement;
        if (rowObj instanceof IgxChildGridRowComponent) {
            const childLayoutKeys = this.grid.childLayoutKeys;
            const riKey = isNext ? childLayoutKeys[0] : childLayoutKeys[childLayoutKeys.length - 1];
            const pathSegment = {
                rowID: rowObj.rowData.rowID,
                rowIslandKey: riKey
            };
            const childGrid = this.grid.hgridAPI.getChildGrid([pathSegment]);
            rowElem = childGrid.tfoot.nativeElement;
        }
        const gridBottom = this._getMinBottom(this.grid);
        const diffBottom = rowElem.getBoundingClientRect().bottom - gridBottom;
        const gridTop = this._getMaxTop(this.grid);
        const diffTop = rowElem.getBoundingClientRect().bottom -
            rowElem.offsetHeight - gridTop;
        const isInView = isNext ? diffBottom <= 0 : diffTop >= 0;
        const calcOffset = isNext ? diffBottom : diffTop;
        return { inView: isInView, offset: calcOffset };
    }
    clearActivation() {
        // clear if previous activation exists.
        if (this.activeNode) {
            this.activeNode.row = null;
        }
    }
    hasNextTarget(grid, index, isNext) {
        const targetRowIndex = isNext ? index + 1 : index - 1;
        const hasTargetRecord = !!grid.dataView[targetRowIndex];
        if (hasTargetRecord) {
            return true;
        }
        else {
            let hasTargetRecordInParent = false;
            if (grid.parent) {
                const indexInParent = grid.childRow.index;
                hasTargetRecordInParent = this.hasNextTarget(grid.parent, indexInParent, isNext);
            }
            return hasTargetRecordInParent;
        }
    }
    /**
     * Gets closest element by its tag name.
     * @param sourceElem The element from which to start the search.
     * @param targetTag The target element tag name, for which to search.
     */
    getClosestElemByTag(sourceElem, targetTag) {
        let result = sourceElem;
        while (result !== null && result.nodeType === 1) {
            if (result.tagName.toLowerCase() === targetTag.toLowerCase()) {
                return result;
            }
            result = result.parentNode;
        }
        return null;
    }
    /**
     * Gets the max top view in the current grid hierarchy.
     * @param grid
     */
    _getMaxTop(grid) {
        let currGrid = grid;
        let top = currGrid.tbody.nativeElement.getBoundingClientRect().top;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
            const pinnedRowsHeight = currGrid.hasPinnedRecords && currGrid.isRowPinningToTop ? currGrid.pinnedRowHeight : 0;
            top = Math.max(top, currGrid.tbody.nativeElement.getBoundingClientRect().top + pinnedRowsHeight);
        }
        return top;
    }
    /**
     * Gets the min bottom view in the current grid hierarchy.
     * @param grid
     */
    _getMinBottom(grid) {
        let currGrid = grid;
        let bottom = currGrid.tbody.nativeElement.getBoundingClientRect().bottom;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
            const pinnedRowsHeight = currGrid.hasPinnedRecords && !currGrid.isRowPinningToTop ? currGrid.pinnedRowHeight : 0;
            bottom = Math.min(bottom, currGrid.tbody.nativeElement.getBoundingClientRect().bottom - pinnedRowsHeight);
        }
        return bottom;
    }
    /**
     * Finds the next grid that allows scrolling down.
     * @param grid The grid from which to begin the search.
     */
    getNextScrollableDown(grid) {
        let currGrid = grid.parent;
        if (!currGrid) {
            return { grid: grid, prev: null };
        }
        let scrollTop = currGrid.verticalScrollContainer.scrollPosition;
        let scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
        let nonScrollable = scrollHeight === 0 ||
            Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
        let prev = grid;
        while (nonScrollable && currGrid.parent !== null) {
            prev = currGrid;
            currGrid = currGrid.parent;
            scrollTop = currGrid.verticalScrollContainer.scrollPosition;
            scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
            nonScrollable = scrollHeight === 0 ||
                Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
        }
        return { grid: currGrid, prev: prev };
    }
    /**
     * Finds the next grid that allows scrolling up.
     * @param grid The grid from which to begin the search.
     */
    getNextScrollableUp(grid) {
        let currGrid = grid.parent;
        if (!currGrid) {
            return { grid: grid, prev: null };
        }
        let nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
        let prev = grid;
        while (nonScrollable && currGrid.parent !== null) {
            prev = currGrid;
            currGrid = currGrid.parent;
            nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
        }
        return { grid: currGrid, prev: prev };
    }
}
IgxHierarchicalGridNavigationService.decorators = [
    { type: Injectable }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGllcmFyY2hpY2FsLWdyaWQtbmF2aWdhdGlvbi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Ii9ob21lL3J1bm5lci93b3JrL2lnbml0ZXVpLWFuZ3VsYXIvaWduaXRldWktYW5ndWxhci9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy8iLCJzb3VyY2VzIjpbImxpYi9ncmlkcy9oaWVyYXJjaGljYWwtZ3JpZC9oaWVyYXJjaGljYWwtZ3JpZC1uYXZpZ2F0aW9uLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFFdEUsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3ZDLE9BQU8sRUFBRSxjQUFjLEVBQUUsZUFBZSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDbkUsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQU10RSxNQUFNLE9BQU8sb0NBQXFDLFNBQVEsd0JBQXdCO0lBRGxGOztRQUljLHVCQUFrQixHQUFHLEtBQUssQ0FBQztJQXlYekMsQ0FBQztJQXRYRyxhQUFhLENBQUMsS0FBb0I7UUFDOUIsTUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUNwQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxLQUFLLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDbkcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxpQkFBaUIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFO1lBQUUsT0FBTztT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bnRlbnQiOlsiaW1wb3J0IHsgSWd4R3JpZE5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vZ3JpZC1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4SGllcmFyY2hpY2FsR3JpZENvbXBvbmVudCB9IGZyb20gJy4vaGllcmFyY2hpY2FsLWdyaWQuY29tcG9uZW50JztcbmltcG9ydCB7IGZpcnN0IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU1VQUE9SVEVEX0tFWVMsIE5BVklHQVRJT05fS0VZUyB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4Q2hpbGRHcmlkUm93Q29tcG9uZW50IH0gZnJvbSAnLi9jaGlsZC1ncmlkLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4Um93RGlyZWN0aXZlLCBJZ3hHcmlkQmFzZURpcmVjdGl2ZSB9IGZyb20gJy4uL2dyaWQvcHVibGljX2FwaSc7XG5pbXBvcnQgeyBHcmlkVHlwZSB9IGZyb20gJy4uL2NvbW1vbi9ncmlkLmludGVyZmFjZSc7XG5pbXBvcnQgeyBJUGF0aFNlZ21lbnQgfSBmcm9tICcuL2hpZXJhcmNoaWNhbC1ncmlkLWJhc2UuZGlyZWN0aXZlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIElneEhpZXJhcmNoaWNhbEdyaWROYXZpZ2F0aW9uU2VydmljZSBleHRlbmRzIElneEdyaWROYXZpZ2F0aW9uU2VydmljZSB7XG4gICAgcHVibGljIGdyaWQ6IElneEhpZXJhcmNoaWNhbEdyaWRDb21wb25lbnQ7XG5cbiAgICBwcm90ZWN0ZWQgX3BlbmRpbmdOYXZpZ2F0aW9uID0gZmFsc2U7XG5cblxuICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZXZlbnQua2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVOb2RlIHx8ICEoU1VQUE9SVEVEX0tFWVMuaGFzKGtleSkgfHwgKGtleSA9PT0gJ3RhYicgJiYgdGhpcy5ncmlkLmNydWRTZXJ2aWNlLmNlbGwpKSAmJlxuICAgICAgICAhdGhpcy5ncmlkLmNydWRTZXJ2aWNlLnJvd0VkaXRpbmdCbG9ja2VkICYmICF0aGlzLmdyaWQucm93SW5FZGl0TW9kZSkgeyByZXR1cm47IH1cblxuICAgICAgICBjb25zdCB0YXJnZXRHcmlkID0gdGhpcy5nZXRDbG9zZXN0RWxlbUJ5VGFnKGV2ZW50LnRhcmdldCwgJ2lneC1oaWVyYXJjaGljYWwtZ3JpZCcpO1xuICAgICAgICBpZiAodGFyZ2V0R3JpZCAhPT0gdGhpcy5ncmlkLm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9wZW5kaW5nTmF2aWdhdGlvbiAmJiBOQVZJR0FUSU9OX0tFWVMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIC8vIEluIGNhc2UgZm9jdXMgbmVlZHMgdG8gYmUgbW92ZWQgZnJvbSBvbmUgZ3JpZCB0byBhbm90aGVyLCBob3dldmVyIHRoZXJlIGlzIGEgcGVuZGluZyBzY3JvbGwgb3BlcmF0aW9uXG4gICAgICAgICAgICAvLyB3aGljaCBpcyBhbiBhc3luYyBvcGVyYXRpb24sIGFueSBhZGRpdGlvbmFsIG5hdmlnYXRpb24ga2V5cyBzaG91bGQgYmUgaWdub3JlZFxuICAgICAgICAgICAgLy8gdW50aWxsIG9wZXJhdGlvbiBjb21wbGV0ZS5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfVxuXG4gICAgcHVibGljIG5hdmlnYXRlSW5Cb2R5KHJvd0luZGV4LCB2aXNpYmxlQ29sSW5kZXgsIGNiOiBGdW5jdGlvbiA9IG51bGwpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgcmVjID0gdGhpcy5ncmlkLmRhdGFWaWV3W3Jvd0luZGV4XTtcbiAgICAgICAgaWYgKHJlYyAmJiB0aGlzLmdyaWQuaXNDaGlsZEdyaWRSZWNvcmQocmVjKSkge1xuICAgICAgICAgICAgIC8vIHRhcmdldCBpcyBjaGlsZCBncmlkXG4gICAgICAgICAgICBjb25zdCB2aXJ0U3RhdGUgPSB0aGlzLmdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuc3RhdGU7XG4gICAgICAgICAgICAgY29uc3QgaW5WaWV3ID0gcm93SW5kZXggPj0gdmlydFN0YXRlLnN0YXJ0SW5kZXggJiYgcm93SW5kZXggPD0gdmlydFN0YXRlLnN0YXJ0SW5kZXggKyB2aXJ0U3RhdGUuY2h1bmtTaXplO1xuICAgICAgICAgICAgIGNvbnN0IGlzTmV4dCA9ICB0aGlzLmFjdGl2ZU5vZGUucm93IDwgcm93SW5kZXg7XG4gICAgICAgICAgICAgY29uc3QgdGFyZ2V0TGF5b3V0SW5kZXggPSBpc05leHQgPyBudWxsIDogdGhpcy5ncmlkLmNoaWxkTGF5b3V0S2V5cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgIGlmIChpblZpZXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3ZlVG9DaGlsZChyb3dJbmRleCwgdmlzaWJsZUNvbEluZGV4LCBpc05leHQsIHRhcmdldExheW91dEluZGV4LCBjYik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBzY3JvbGxBbW91bnQgPSB0aGlzLmdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuZ2V0U2Nyb2xsRm9ySW5kZXgocm93SW5kZXgsICFpc05leHQpO1xuICAgICAgICAgICAgICAgIHNjcm9sbEFtb3VudCArPSBpc05leHQgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLmdldFNjcm9sbCgpLnNjcm9sbFRvcCA9IHNjcm9sbEFtb3VudDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nTmF2aWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLm9uQ2h1bmtMb2FkLnBpcGUoZmlyc3QoKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW92ZVRvQ2hpbGQocm93SW5kZXgsIHZpc2libGVDb2xJbmRleCwgaXNOZXh0LCB0YXJnZXRMYXlvdXRJbmRleCwgY2IpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nTmF2aWdhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNMYXN0ID0gcm93SW5kZXggPT09IHRoaXMuZ3JpZC5kYXRhVmlldy5sZW5ndGg7XG4gICAgICAgIGlmICgocm93SW5kZXggPT09IC0xIHx8IGlzTGFzdCkgJiZcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5wYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHJlYWNoZWQgZW5kIG9mIGNoaWxkIGdyaWRcbiAgICAgICAgICAgIGNvbnN0IG5leHRTaWJsaW5nSW5kZXggPSB0aGlzLm5leHRTaWJsaW5nSW5kZXgoaXNMYXN0KTtcbiAgICAgICAgICAgIGlmIChuZXh0U2libGluZ0luZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLnBhcmVudC5uYXZpZ2F0aW9uLl9tb3ZlVG9DaGlsZCh0aGlzLmdyaWQuY2hpbGRSb3cuaW5kZXgsIHZpc2libGVDb2xJbmRleCwgaXNMYXN0LCBuZXh0U2libGluZ0luZGV4LCBjYik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVUb1BhcmVudChpc0xhc3QsIHZpc2libGVDb2xJbmRleCwgY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5wYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzTmV4dCA9IHRoaXMuYWN0aXZlTm9kZSAmJiB0eXBlb2YgdGhpcy5hY3RpdmVOb2RlLnJvdyA9PT0gJ251bWJlcicgPyByb3dJbmRleCA+IHRoaXMuYWN0aXZlTm9kZS5yb3cgOiBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGNiSGFuZGxlciA9IChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlU2Nyb2xsSW5DaGlsZChyb3dJbmRleCwgaXNOZXh0KTtcbiAgICAgICAgICAgICAgICBjYihhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlTm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlTm9kZSA9IHsgcm93OiBudWxsLCBjb2x1bW46IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1cGVyLm5hdmlnYXRlSW5Cb2R5KHJvd0luZGV4LCB2aXNpYmxlQ29sSW5kZXgsIGNiSGFuZGxlcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVOb2RlID0geyByb3c6IG51bGwsIGNvbHVtbjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLm5hdmlnYXRlSW5Cb2R5KHJvd0luZGV4LCB2aXNpYmxlQ29sSW5kZXgsIGNiKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2hvdWxkUGVyZm9ybVZlcnRpY2FsU2Nyb2xsKGluZGV4LCB2aXNpYmxlQ29sdW1uSW5kZXggPSAtMSwgaXNOZXh0Pykge1xuICAgICAgICBjb25zdCB0YXJnZXRSZWMgPSB0aGlzLmdyaWQuZGF0YVZpZXdbaW5kZXhdO1xuICAgICAgICBpZiAodGhpcy5ncmlkLmlzQ2hpbGRHcmlkUmVjb3JkKHRhcmdldFJlYykpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbEFtb3VudCA9IHRoaXMuZ3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5nZXRTY3JvbGxGb3JJbmRleChpbmRleCwgIWlzTmV4dCk7XG4gICAgICAgICAgICBjb25zdCBjdXJyU2Nyb2xsID0gdGhpcy5ncmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLmdldFNjcm9sbCgpLnNjcm9sbFRvcDtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNjcm9sbCA9ICFpc05leHQgPyBzY3JvbGxBbW91bnQgPiBjdXJyU2Nyb2xsIDogY3VyclNjcm9sbCA8IHNjcm9sbEFtb3VudDtcbiAgICAgICAgICAgIHJldHVybiBzaG91bGRTY3JvbGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuc2hvdWxkUGVyZm9ybVZlcnRpY2FsU2Nyb2xsKGluZGV4LCB2aXNpYmxlQ29sdW1uSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9jdXNUYm9keShldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlTm9kZSB8fCB0aGlzLmFjdGl2ZU5vZGUucm93ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZU5vZGUgPSB7XG4gICAgICAgICAgICAgICAgcm93OiAwLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogMFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5ncmlkLm5hdmlnYXRlVG8oMCwgMCwgKG9iaikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5jbGVhckNlbGxTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBvYmoudGFyZ2V0LmFjdGl2YXRlKGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5mb2N1c1Rib2R5KGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBuZXh0U2libGluZ0luZGV4KGlzTmV4dCkge1xuICAgICAgICBjb25zdCBsYXlvdXRLZXkgPSB0aGlzLmdyaWQuY2hpbGRSb3cubGF5b3V0LmtleTtcbiAgICAgICAgY29uc3QgbGF5b3V0SW5kZXggPSB0aGlzLmdyaWQucGFyZW50LmNoaWxkTGF5b3V0S2V5cy5pbmRleE9mKGxheW91dEtleSk7XG4gICAgICAgIGNvbnN0IG5leHRJbmRleCA9IGlzTmV4dCA/IGxheW91dEluZGV4ICsgMSA6IGxheW91dEluZGV4IC0gMTtcbiAgICAgICAgaWYgKG5leHRJbmRleCA8PSB0aGlzLmdyaWQucGFyZW50LmNoaWxkTGF5b3V0S2V5cy5sZW5ndGggLSAxICYmIG5leHRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHNjcm9sbGluZyBpbiBjaGlsZCBncmlkIGFuZCBlbnN1cmVzIHRhcmdldCBjaGlsZCByb3cgaXMgaW4gbWFpbiBncmlkIHZpZXcgcG9ydC5cbiAgICAgKiBAcGFyYW0gcm93SW5kZXggVGhlIHJvdyBpbmRleCB3aGljaCBzaG91bGQgYmUgaW4gdmlldy5cbiAgICAgKiBAcGFyYW0gaXNOZXh0ICBPcHRpb25hbC4gV2hldGhlciB3ZSBhcmUgbmF2aWdhdGluZyB0byBuZXh0LiBVc2VkIHRvIGRldGVybWluZSBzY3JvbGwgZGlyZWN0aW9uLlxuICAgICAqIEBwYXJhbSBjYiAgT3B0aW9uYWwuQ2FsbGJhY2sgZnVuY3Rpb24gY2FsbGVkIHdoZW4gb3BlcmF0aW9uIGlzIGNvbXBsZXRlLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfaGFuZGxlU2Nyb2xsSW5DaGlsZChyb3dJbmRleDogbnVtYmVyLCBpc05leHQ/OiBib29sZWFuLCBjYj86IEZ1bmN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZFNjcm9sbCA9IHRoaXMuc2hvdWxkUGVyZm9ybVZlcnRpY2FsU2Nyb2xsKHJvd0luZGV4LCAtMSwgaXNOZXh0KTtcbiAgICAgICAgaWYgKHNob3VsZFNjcm9sbCkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLm5hdmlnYXRpb24ucGVyZm9ybVZlcnRpY2FsU2Nyb2xsVG9DZWxsKHJvd0luZGV4LCAtMSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb25JblBhcmVudChyb3dJbmRleCwgaXNOZXh0LCBjYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25JblBhcmVudChyb3dJbmRleCwgaXNOZXh0LCBjYik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb3dJbmRleCBSb3cgaW5kZXggdGhhdCBzaG91bGQgY29tZSBpbiB2aWV3LlxuICAgICAqIEBwYXJhbSBpc05leHQgIFdoZXRoZXIgd2UgYXJlIG5hdmlnYXRpbmcgdG8gbmV4dC4gVXNlZCB0byBkZXRlcm1pbmUgc2Nyb2xsIGRpcmVjdGlvbi5cbiAgICAgKiBAcGFyYW0gY2IgIE9wdGlvbmFsLkNhbGxiYWNrIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIG9wZXJhdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcG9zaXRpb25JblBhcmVudChyb3dJbmRleCwgaXNOZXh0LCBjYj86IEZ1bmN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHJvd09iaiA9IHRoaXMuZ3JpZC5nZXRSb3dCeUluZGV4KHJvd0luZGV4KTtcbiAgICAgICAgaWYgKCFyb3dPYmopIHtcbiAgICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zaXRpb25JbmZvID0gdGhpcy5nZXRQb3NpdGlvbkluZm8ocm93T2JqLCBpc05leHQpO1xuICAgICAgICBpZiAoIXBvc2l0aW9uSW5mby5pblZpZXcpIHtcbiAgICAgICAgICAgIC8vIHN0b3AgZXZlbnQgZnJvbSB0cmlnZ2VyaW5nIG11bHRpcGxlIHRpbWVzIGJlZm9yZSBzY3JvbGxpbmcgaXMgY29tcGxldGUuXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nTmF2aWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxhYmxlR3JpZCA9IGlzTmV4dCA/IHRoaXMuZ2V0TmV4dFNjcm9sbGFibGVEb3duKHRoaXMuZ3JpZCkgOiB0aGlzLmdldE5leHRTY3JvbGxhYmxlVXAodGhpcy5ncmlkKTtcbiAgICAgICAgICAgIHNjcm9sbGFibGVHcmlkLmdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIucmVjYWxjVXBkYXRlU2l6ZXMoKTtcbiAgICAgICAgICAgIHNjcm9sbGFibGVHcmlkLmdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuYWRkU2Nyb2xsVG9wKHBvc2l0aW9uSW5mby5vZmZzZXQpO1xuICAgICAgICAgICAgc2Nyb2xsYWJsZUdyaWQuZ3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5vbkNodW5rTG9hZC5waXBlKGZpcnN0KCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ05hdmlnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBuYXZpZ2F0aW9uIHRvIGNoaWxkIGdyaWQuXG4gICAgICogQHBhcmFtIHBhcmVudFJvd0luZGV4IFRoZSBwYXJlbnQgcm93IGluZGV4LCBhdCB3aGljaCB0aGUgY2hpbGQgZ3JpZCBpcyByZW5kZXJlZC5cbiAgICAgKiBAcGFyYW0gY2hpbGRMYXlvdXRJbmRleCBPcHRpb25hbC4gVGhlIGluZGV4IG9mIHRoZSBjaGlsZCByb3cgaXNsYW5kIHRvIHdoaWNoIHRoZSBjaGlsZCBncmlkIGJlbG9uZ3MgdG8uIFVzZXMgZmlyc3QgaWYgbm90IHNldC5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX21vdmVUb0NoaWxkKHBhcmVudFJvd0luZGV4OiBudW1iZXIsIHZpc2libGVDb2xJbmRleDogbnVtYmVyLCBpc05leHQ6IGJvb2xlYW4sIGNoaWxkTGF5b3V0SW5kZXg/OiBudW1iZXIsIGNiPzogRnVuY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcmkgPSB0eXBlb2YgY2hpbGRMYXlvdXRJbmRleCAhPT0gJ251bWJlcicgP1xuICAgICAgICAgdGhpcy5ncmlkLmNoaWxkTGF5b3V0TGlzdC5maXJzdCA6IHRoaXMuZ3JpZC5jaGlsZExheW91dExpc3QudG9BcnJheSgpW2NoaWxkTGF5b3V0SW5kZXhdO1xuICAgICAgICBjb25zdCByb3dJZCA9IHRoaXMuZ3JpZC5kYXRhVmlld1twYXJlbnRSb3dJbmRleF0ucm93SUQ7XG4gICAgICAgIGNvbnN0IHBhdGhTZWdtZW50OiBJUGF0aFNlZ21lbnQgPSB7XG4gICAgICAgICAgICByb3dJRDogcm93SWQsXG4gICAgICAgICAgICByb3dJc2xhbmRLZXk6IHJpLmtleVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjaGlsZEdyaWQgPSAgdGhpcy5ncmlkLmhncmlkQVBJLmdldENoaWxkR3JpZChbcGF0aFNlZ21lbnRdKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0SW5kZXggPSBpc05leHQgPyAwIDogY2hpbGRHcmlkLmRhdGFWaWV3Lmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IHRhcmdldFJlYyA9ICBjaGlsZEdyaWQuZGF0YVZpZXdbdGFyZ2V0SW5kZXhdO1xuICAgICAgICBpZiAoIXRhcmdldFJlYykge1xuICAgICAgICAgICAgLy8gaWYgbm8gdGFyZ2V0IHJlYywgdGhlbiBtb3ZlIG9uIGluIG5leHQgc2libGluZyBvciBwYXJlbnRcbiAgICAgICAgICAgIGNoaWxkR3JpZC5uYXZpZ2F0aW9uLm5hdmlnYXRlSW5Cb2R5KHRhcmdldEluZGV4LCB2aXNpYmxlQ29sSW5kZXgsIGNiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRHcmlkLmlzQ2hpbGRHcmlkUmVjb3JkKHRhcmdldFJlYykpIHtcbiAgICAgICAgICAgIC8vIGlmIHRhcmdldCBpcyBhIGNoaWxkIGdyaWQgcmVjb3JkIHNob3VsZCBtb3ZlIGludG8gaXQuXG4gICAgICAgICAgICB0aGlzLmdyaWQubmF2aWdhdGlvbi5hY3RpdmVOb2RlLnJvdyA9IG51bGw7XG4gICAgICAgICAgICBjaGlsZEdyaWQubmF2aWdhdGlvbi5hY3RpdmVOb2RlID0geyByb3c6IHRhcmdldEluZGV4LCBjb2x1bW46IHRoaXMuYWN0aXZlTm9kZS5jb2x1bW59O1xuICAgICAgICAgICAgY2hpbGRHcmlkLm5hdmlnYXRpb24uX2hhbmRsZVNjcm9sbEluQ2hpbGQodGFyZ2V0SW5kZXgsIGlzTmV4dCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldExheW91dEluZGV4ID0gaXNOZXh0ID8gMCA6IGNoaWxkR3JpZC5jaGlsZExheW91dExpc3QudG9BcnJheSgpLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgY2hpbGRHcmlkLm5hdmlnYXRpb24uX21vdmVUb0NoaWxkKHRhcmdldEluZGV4LCB2aXNpYmxlQ29sSW5kZXgsIGlzTmV4dCwgdGFyZ2V0TGF5b3V0SW5kZXgsIGNiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2hpbGRHcmlkTmF2ID0gIGNoaWxkR3JpZC5uYXZpZ2F0aW9uO1xuICAgICAgICB0aGlzLmNsZWFyQWN0aXZhdGlvbigpO1xuICAgICAgICBjb25zdCBsYXN0VmlzaWJsZUluZGV4ID0gY2hpbGRHcmlkTmF2Lmxhc3RDb2x1bW5JbmRleDtcbiAgICAgICAgY29uc3QgY29sdW1uSW5kZXggPSB2aXNpYmxlQ29sSW5kZXggPD0gbGFzdFZpc2libGVJbmRleCA/IHZpc2libGVDb2xJbmRleCA6IGxhc3RWaXNpYmxlSW5kZXg7XG4gICAgICAgIGNoaWxkR3JpZE5hdi5hY3RpdmVOb2RlID0geyByb3c6IHRhcmdldEluZGV4LCBjb2x1bW46IGNvbHVtbkluZGV4fTtcbiAgICAgICAgY2hpbGRHcmlkLnRib2R5Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoe3ByZXZlbnRTY3JvbGw6IHRydWV9KTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ05hdmlnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgY2hpbGRHcmlkLm5hdmlnYXRpb24uX2hhbmRsZVNjcm9sbEluQ2hpbGQodGFyZ2V0SW5kZXgsIGlzTmV4dCwgKCkgPT4ge1xuICAgICAgICAgICAgY2hpbGRHcmlkLm5hdmlnYXRlVG8odGFyZ2V0SW5kZXgsIGNvbHVtbkluZGV4LCBjYik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIG5hdmlnYXRpb24gYmFjayB0byBwYXJlbnQgZ3JpZC5cbiAgICAgKiBAcGFyYW0gcm93SW5kZXhcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX21vdmVUb1BhcmVudChpc05leHQ6IGJvb2xlYW4sIGNvbHVtbkluZGV4LCBjYj8pIHtcbiAgICAgICAgY29uc3QgaW5kZXhJblBhcmVudCA9IHRoaXMuZ3JpZC5jaGlsZFJvdy5pbmRleDtcbiAgICAgICAgY29uc3QgaGFzTmV4dFRhcmdldCA9IHRoaXMuaGFzTmV4dFRhcmdldCh0aGlzLmdyaWQucGFyZW50LCBpbmRleEluUGFyZW50LCBpc05leHQpO1xuICAgICAgICBpZiAoIWhhc05leHRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyQWN0aXZhdGlvbigpO1xuICAgICAgICBjb25zdCB0YXJnZXRSb3dJbmRleCA9ICBpc05leHQgPyBpbmRleEluUGFyZW50ICsgMSA6IGluZGV4SW5QYXJlbnQgLSAxO1xuICAgICAgICBjb25zdCBsYXN0VmlzaWJsZUluZGV4ID0gdGhpcy5ncmlkLnBhcmVudC5uYXZpZ2F0aW9uLmxhc3RDb2x1bW5JbmRleDtcbiAgICAgICAgY29uc3QgbmV4dENvbHVtbkluZGV4ID0gY29sdW1uSW5kZXggPD0gbGFzdFZpc2libGVJbmRleCA/IGNvbHVtbkluZGV4IDogbGFzdFZpc2libGVJbmRleDtcbiAgICAgICAgdGhpcy5fcGVuZGluZ05hdmlnYXRpb24gPSB0cnVlO1xuICAgICAgICBjb25zdCBjYkZ1bmMgPSAoYXJncykgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ05hdmlnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIGNiKGFyZ3MpO1xuICAgICAgICAgICAgYXJncy50YXJnZXQuZ3JpZC50Ym9keS5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ3JpZC5wYXJlbnQubmF2aWdhdGlvbi5uYXZpZ2F0ZUluQm9keSh0YXJnZXRSb3dJbmRleCwgbmV4dENvbHVtbkluZGV4LCBjYkZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgaW5mb3JtYXRpb24gb24gdGhlIHJvdyBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgcm9vdCBncmlkIHZpZXcgcG9ydC5cbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHJvdyBpcyBpbiB2aWV3IGFuZCBpdHMgb2Zmc2V0LlxuICAgICAqIEBwYXJhbSByb3dPYmpcbiAgICAgKiBAcGFyYW0gaXNOZXh0XG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldFBvc2l0aW9uSW5mbyhyb3dPYmo6IElneFJvd0RpcmVjdGl2ZTxJZ3hHcmlkQmFzZURpcmVjdGl2ZSAmIEdyaWRUeXBlPiwgaXNOZXh0OiBib29sZWFuKSB7XG4gICAgICAgIGxldCByb3dFbGVtID0gcm93T2JqLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmIChyb3dPYmogaW5zdGFuY2VvZiBJZ3hDaGlsZEdyaWRSb3dDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTGF5b3V0S2V5cyA9IHRoaXMuZ3JpZC5jaGlsZExheW91dEtleXM7XG4gICAgICAgICAgICBjb25zdCByaUtleSA9IGlzTmV4dCA/IGNoaWxkTGF5b3V0S2V5c1swXSA6IGNoaWxkTGF5b3V0S2V5c1tjaGlsZExheW91dEtleXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBwYXRoU2VnbWVudDogSVBhdGhTZWdtZW50ID0ge1xuICAgICAgICAgICAgICAgIHJvd0lEOiByb3dPYmoucm93RGF0YS5yb3dJRCxcbiAgICAgICAgICAgICAgICByb3dJc2xhbmRLZXk6IHJpS2V5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2hpbGRHcmlkID0gIHRoaXMuZ3JpZC5oZ3JpZEFQSS5nZXRDaGlsZEdyaWQoW3BhdGhTZWdtZW50XSk7XG4gICAgICAgICAgICByb3dFbGVtID0gY2hpbGRHcmlkLnRmb290Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ3JpZEJvdHRvbSA9IHRoaXMuX2dldE1pbkJvdHRvbSh0aGlzLmdyaWQpO1xuICAgICAgICBjb25zdCBkaWZmQm90dG9tID1cbiAgICAgICAgcm93RWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20gLSBncmlkQm90dG9tO1xuICAgICAgICBjb25zdCBncmlkVG9wID0gdGhpcy5fZ2V0TWF4VG9wKHRoaXMuZ3JpZCk7XG4gICAgICAgIGNvbnN0IGRpZmZUb3AgPSByb3dFbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSAtXG4gICAgICAgIHJvd0VsZW0ub2Zmc2V0SGVpZ2h0IC0gZ3JpZFRvcDtcbiAgICAgICAgY29uc3QgaXNJblZpZXcgPSBpc05leHQgPyBkaWZmQm90dG9tIDw9IDAgOiBkaWZmVG9wID49IDA7XG4gICAgICAgIGNvbnN0IGNhbGNPZmZzZXQgPSAgaXNOZXh0ID8gZGlmZkJvdHRvbSA6IGRpZmZUb3A7XG5cbiAgICAgICAgcmV0dXJuIHsgaW5WaWV3OiBpc0luVmlldywgb2Zmc2V0OiBjYWxjT2Zmc2V0IH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjbGVhckFjdGl2YXRpb24oKSB7XG4gICAgICAgIC8vIGNsZWFyIGlmIHByZXZpb3VzIGFjdGl2YXRpb24gZXhpc3RzLlxuICAgICAgICBpZiAodGhpcy5hY3RpdmVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZU5vZGUucm93ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaGFzTmV4dFRhcmdldChncmlkLCBpbmRleDogbnVtYmVyLCBpc05leHQ6IGJvb2xlYW4pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0Um93SW5kZXggPSAgaXNOZXh0ID8gaW5kZXggKyAxIDogaW5kZXggLSAxO1xuICAgICAgICBjb25zdCBoYXNUYXJnZXRSZWNvcmQgPSAhIWdyaWQuZGF0YVZpZXdbdGFyZ2V0Um93SW5kZXhdO1xuICAgICAgICBpZiAoaGFzVGFyZ2V0UmVjb3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBoYXNUYXJnZXRSZWNvcmRJblBhcmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGdyaWQucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhJblBhcmVudCA9IGdyaWQuY2hpbGRSb3cuaW5kZXg7XG4gICAgICAgICAgICAgICAgaGFzVGFyZ2V0UmVjb3JkSW5QYXJlbnQgPSB0aGlzLmhhc05leHRUYXJnZXQoZ3JpZC5wYXJlbnQsIGluZGV4SW5QYXJlbnQsIGlzTmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGFzVGFyZ2V0UmVjb3JkSW5QYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNsb3Nlc3QgZWxlbWVudCBieSBpdHMgdGFnIG5hbWUuXG4gICAgICogQHBhcmFtIHNvdXJjZUVsZW0gVGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0byBzdGFydCB0aGUgc2VhcmNoLlxuICAgICAqIEBwYXJhbSB0YXJnZXRUYWcgVGhlIHRhcmdldCBlbGVtZW50IHRhZyBuYW1lLCBmb3Igd2hpY2ggdG8gc2VhcmNoLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRDbG9zZXN0RWxlbUJ5VGFnKHNvdXJjZUVsZW0sIHRhcmdldFRhZykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc291cmNlRWxlbTtcbiAgICAgICAgd2hpbGUgKHJlc3VsdCAhPT0gbnVsbCAmJiByZXN1bHQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSB0YXJnZXRUYWcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtYXggdG9wIHZpZXcgaW4gdGhlIGN1cnJlbnQgZ3JpZCBoaWVyYXJjaHkuXG4gICAgICogQHBhcmFtIGdyaWRcbiAgICAgKi9cbiAgICBwcml2YXRlIF9nZXRNYXhUb3AoZ3JpZCkge1xuICAgICAgICBsZXQgY3VyckdyaWQgPSBncmlkO1xuICAgICAgICBsZXQgdG9wID0gY3VyckdyaWQudGJvZHkubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgICAgIHdoaWxlIChjdXJyR3JpZC5wYXJlbnQpIHtcbiAgICAgICAgICAgIGN1cnJHcmlkID0gY3VyckdyaWQucGFyZW50O1xuICAgICAgICAgICAgY29uc3QgcGlubmVkUm93c0hlaWdodCA9IGN1cnJHcmlkLmhhc1Bpbm5lZFJlY29yZHMgJiYgY3VyckdyaWQuaXNSb3dQaW5uaW5nVG9Ub3AgPyBjdXJyR3JpZC5waW5uZWRSb3dIZWlnaHQgOiAwO1xuICAgICAgICAgICAgdG9wID0gTWF0aC5tYXgodG9wLCBjdXJyR3JpZC50Ym9keS5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHBpbm5lZFJvd3NIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3A7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWluIGJvdHRvbSB2aWV3IGluIHRoZSBjdXJyZW50IGdyaWQgaGllcmFyY2h5LlxuICAgICAqIEBwYXJhbSBncmlkXG4gICAgICovXG4gICAgcHJpdmF0ZSBfZ2V0TWluQm90dG9tKGdyaWQpIHtcbiAgICAgICAgbGV0IGN1cnJHcmlkID0gZ3JpZDtcbiAgICAgICAgbGV0IGJvdHRvbSA9IGN1cnJHcmlkLnRib2R5Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tO1xuICAgICAgICB3aGlsZSAoY3VyckdyaWQucGFyZW50KSB7XG4gICAgICAgICAgICBjdXJyR3JpZCA9IGN1cnJHcmlkLnBhcmVudDtcbiAgICAgICAgICAgIGNvbnN0IHBpbm5lZFJvd3NIZWlnaHQgPSBjdXJyR3JpZC5oYXNQaW5uZWRSZWNvcmRzICYmICFjdXJyR3JpZC5pc1Jvd1Bpbm5pbmdUb1RvcCA/IGN1cnJHcmlkLnBpbm5lZFJvd0hlaWdodCA6IDA7XG4gICAgICAgICAgICBib3R0b20gPSBNYXRoLm1pbihib3R0b20sIGN1cnJHcmlkLnRib2R5Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC0gcGlubmVkUm93c0hlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvdHRvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbmV4dCBncmlkIHRoYXQgYWxsb3dzIHNjcm9sbGluZyBkb3duLlxuICAgICAqIEBwYXJhbSBncmlkIFRoZSBncmlkIGZyb20gd2hpY2ggdG8gYmVnaW4gdGhlIHNlYXJjaC5cbiAgICAgKi9cbiAgICBwcml2YXRlIGdldE5leHRTY3JvbGxhYmxlRG93bihncmlkKSB7XG4gICAgICAgIGxldCBjdXJyR3JpZCA9IGdyaWQucGFyZW50O1xuICAgICAgICBpZiAoIWN1cnJHcmlkKSB7XG4gICAgICAgICAgICByZXR1cm4geyBncmlkOiBncmlkLCBwcmV2OiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IGN1cnJHcmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLnNjcm9sbFBvc2l0aW9uO1xuICAgICAgICBsZXQgc2Nyb2xsSGVpZ2h0ID0gY3VyckdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuZ2V0U2Nyb2xsKCkuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICBsZXQgbm9uU2Nyb2xsYWJsZSA9IHNjcm9sbEhlaWdodCA9PT0gMCB8fFxuICAgICAgICAgICAgTWF0aC5yb3VuZChzY3JvbGxUb3AgKyBjdXJyR3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5pZ3hGb3JDb250YWluZXJTaXplKSA9PT0gc2Nyb2xsSGVpZ2h0O1xuICAgICAgICBsZXQgcHJldiA9IGdyaWQ7XG4gICAgICAgIHdoaWxlIChub25TY3JvbGxhYmxlICYmIGN1cnJHcmlkLnBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJldiA9IGN1cnJHcmlkO1xuICAgICAgICAgICAgY3VyckdyaWQgPSBjdXJyR3JpZC5wYXJlbnQ7XG4gICAgICAgICAgICBzY3JvbGxUb3AgPSBjdXJyR3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5zY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgICAgIHNjcm9sbEhlaWdodCA9IGN1cnJHcmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLmdldFNjcm9sbCgpLnNjcm9sbEhlaWdodDtcbiAgICAgICAgICAgIG5vblNjcm9sbGFibGUgPSBzY3JvbGxIZWlnaHQgPT09IDAgfHxcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKHNjcm9sbFRvcCArIGN1cnJHcmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLmlneEZvckNvbnRhaW5lclNpemUpID09PSBzY3JvbGxIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZ3JpZDogY3VyckdyaWQsIHByZXY6IHByZXYgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbmV4dCBncmlkIHRoYXQgYWxsb3dzIHNjcm9sbGluZyB1cC5cbiAgICAgKiBAcGFyYW0gZ3JpZCBUaGUgZ3JpZCBmcm9tIHdoaWNoIHRvIGJlZ2luIHRoZSBzZWFyY2guXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXROZXh0U2Nyb2xsYWJsZVVwKGdyaWQpIHtcbiAgICAgICAgbGV0IGN1cnJHcmlkID0gZ3JpZC5wYXJlbnQ7XG4gICAgICAgIGlmICghY3VyckdyaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGdyaWQ6IGdyaWQsIHByZXY6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbm9uU2Nyb2xsYWJsZSA9IGN1cnJHcmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLnNjcm9sbFBvc2l0aW9uID09PSAwO1xuICAgICAgICBsZXQgcHJldiA9IGdyaWQ7XG4gICAgICAgIHdoaWxlIChub25TY3JvbGxhYmxlICYmIGN1cnJHcmlkLnBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJldiA9IGN1cnJHcmlkO1xuICAgICAgICAgICAgY3VyckdyaWQgPSBjdXJyR3JpZC5wYXJlbnQ7XG4gICAgICAgICAgICBub25TY3JvbGxhYmxlID0gY3VyckdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuc2Nyb2xsUG9zaXRpb24gPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZ3JpZDogY3VyckdyaWQsIHByZXY6IHByZXYgfTtcbiAgICB9XG59XG4iXX0=