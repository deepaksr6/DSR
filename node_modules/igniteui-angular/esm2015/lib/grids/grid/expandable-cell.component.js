import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, Inject, Input, NgZone, TemplateRef, ViewChild } from '@angular/core';
import { IgxGridCellComponent } from '../cell.component';
import { GridBaseAPIService } from '../api.service';
import { getNodeSizeViaRange, PlatformUtil } from '../../core/utils';
import { DOCUMENT } from '@angular/common';
import { IgxGridSelectionService, IgxGridCRUDService } from '../selection/selection.service';
import { HammerGesturesManager } from '../../core/touch';
export class IgxGridExpandableCellComponent extends IgxGridCellComponent {
    constructor(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, document, platformUtil) {
        super(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, platformUtil);
        this.zone = zone;
        this.document = document;
        this.platformUtil = platformUtil;
        /**
         * @hidden
         */
        this.expanded = false;
    }
    /**
     * @hidden
     */
    toggle(event) {
        event.stopPropagation();
        const expansionState = this.gridAPI.get_row_expansion_state(this.row.rowData);
        this.gridAPI.set_row_expansion_state(this.row.rowID, !expansionState, event);
    }
    /**
     * @hidden
     */
    onIndicatorFocus() {
        this.gridAPI.submit_value();
    }
    /**
     * @hidden
     */
    calculateSizeToFit(range) {
        const indicatorWidth = this.indicator.nativeElement.getBoundingClientRect().width;
        const indicatorStyle = this.document.defaultView.getComputedStyle(this.indicator.nativeElement);
        const indicatorMargin = parseFloat(indicatorStyle.marginRight);
        let leftPadding = 0;
        if (this.indentationDiv) {
            const indentationStyle = this.document.defaultView.getComputedStyle(this.indentationDiv.nativeElement);
            leftPadding = parseFloat(indentationStyle.paddingLeft);
        }
        const largestWidth = Math.max(...Array.from(this.nativeElement.children)
            .map((child) => getNodeSizeViaRange(range, child)));
        return largestWidth + indicatorWidth + indicatorMargin + leftPadding;
    }
    /**
     * @hidden
     */
    get iconTemplate() {
        if (this.expanded) {
            return this.grid.rowExpandedIndicatorTemplate || this.defaultExpandedTemplate;
        }
        else {
            return this.grid.rowCollapsedIndicatorTemplate || this.defaultCollapsedTemplate;
        }
    }
    /**
     * @hidden
     */
    get showExpanderIndicator() {
        const isGhost = this.row.pinned && this.row.disabled;
        return !this.editMode && (!this.row.pinned || isGhost);
    }
}
IgxGridExpandableCellComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'igx-expandable-grid-cell',
                template: "<ng-template #defaultPinnedIndicator>\n    <igx-chip *ngIf=\"displayPinnedChip\" class=\"igx-grid__td--pinned-chip\" [disabled]=\"true\" [displayDensity]=\"'compact'\">{{ grid.resourceStrings.igx_grid_pinned_row_indicator }}</igx-chip>\n</ng-template>\n<ng-template #defaultCell>\n    <div igxTextHighlight class=\"igx-grid__td-text\" style=\"pointer-events: none\"\n        [cssClass]=\"highlightClass\"\n        [activeCssClass]=\"activeHighlightClass\"\n        [groupName]=\"gridID\"\n        [value]=\"formatter ? (value | columnFormatter:formatter) : column.dataType === 'number' ? (value | number:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'date' ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale) : value\"\n        [row]=\"rowData\"\n        [column]=\"this.column.field\"\n        [containerClass]=\"'igx-grid__td-text'\"\n        [metadata]=\"searchMetadata\">{{ formatter ? (value | columnFormatter:formatter) : column.dataType === 'number' ? (value | number:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'date' ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale) : value }}</div>\n</ng-template>\n<ng-template #addRowCell let-cell=\"cell\">\n    <div igxTextHighlight class=\"igx-grid__td-text\" style=\"pointer-events: none\"\n    [cssClass]=\"highlightClass\"\n    [activeCssClass]=\"activeHighlightClass\"\n    [groupName]=\"gridID\"\n    [value]=\"formatter ? (value | columnFormatter:formatter) : column.dataType === 'number' ? (value | number:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'date' ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale) : value\"\n    [row]=\"rowData\"\n    [column]=\"this.column.field\"\n    [containerClass]=\"'igx-grid__td-text'\"\n    [metadata]=\"searchMetadata\">{{\n        value ? value : (column.header || column.field)\n    }}</div>\n</ng-template>\n<ng-template #inlineEditor  let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"true\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"true\"  type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox (change)=\"editValue = $event.checked\" [value]=\"editValue\" [checked]=\"editValue\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker [style.width.%]=\"100\" [outlet]=\"grid.outlet\" mode=\"dropdown\"\n        [locale]=\"grid.locale\" [(value)]=\"editValue\" [igxFocus]=\"true\" [labelVisibility]=\"false\">\n    </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngIf=\"showExpanderIndicator\">\n    <div #indicator\n         class=\"igx-grid__tree-grouping-indicator\"\n         (click)=\"toggle($event)\" (focus)=\"onIndicatorFocus()\">\n         <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit:  this }\">\n        </ng-container>\n    </div>\n</ng-container>\n<ng-container *ngTemplateOutlet=\"pinnedIndicatorTemplate; context: context\">\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n<ng-template #defaultExpandedTemplate>\n        <igx-icon fontSet=\"material\">expand_more</igx-icon>\n</ng-template>\n<ng-template #defaultCollapsedTemplate>\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n</ng-template>\n",
                providers: [HammerGesturesManager]
            },] }
];
IgxGridExpandableCellComponent.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: GridBaseAPIService },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone },
    { type: HammerGesturesManager },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: PlatformUtil }
];
IgxGridExpandableCellComponent.propDecorators = {
    expanded: [{ type: Input }],
    indicator: [{ type: ViewChild, args: ['indicator', { read: ElementRef },] }],
    indentationDiv: [{ type: ViewChild, args: ['indentationDiv', { read: ElementRef },] }],
    defaultExpandedTemplate: [{ type: ViewChild, args: ['defaultExpandedTemplate', { read: TemplateRef, static: true },] }],
    defaultCollapsedTemplate: [{ type: ViewChild, args: ['defaultCollapsedTemplate', { read: TemplateRef, static: true },] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwYW5kYWJsZS1jZWxsLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIvaG9tZS9ydW5uZXIvd29yay9pZ25pdGV1aS1hbmd1bGFyL2lnbml0ZXVpLWFuZ3VsYXIvcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvIiwic291cmNlcyI6WyJsaWIvZ3JpZHMvZ3JpZC9leHBhbmRhYmxlLWNlbGwuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDSCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxVQUFVLEVBQ1YsTUFBTSxFQUNOLEtBQUssRUFDTCxNQUFNLEVBRU4sV0FBVyxFQUNYLFNBQVMsRUFDWixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUN6RCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNwRCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsWUFBWSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDckUsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRTNDLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQzdGLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBU3pELE1BQU0sT0FBTyw4QkFBK0IsU0FBUSxvQkFBb0I7SUFFcEUsWUFDWSxnQkFBeUMsRUFDekMsV0FBK0IsRUFDL0IsT0FBNEQsRUFDNUQsR0FBc0IsRUFDdEIsT0FBbUIsRUFDVCxJQUFZLEVBQ3RCLFlBQW1DLEVBQ1YsUUFBUSxFQUN2QixZQUEwQjtRQUM1QyxLQUFLLENBQUMsZ0JBQWdCLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFKNUUs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VTtZQUdWLE1BQU07WUFXRCxxQkFBcUI7NENBbUJiLE1BQU0sU0FBQyxRQUFRO1lBdkJGLFlBQVk7Ozt1QkErQnJDLEtBQUs7d0JBR0wsU0FBUyxTQUFDLFdBQVcsRUFBRSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUU7NkJBRzNDLFNBQVMsU0FBQyxnQkFBZ0IsRUFBRSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUU7c0NBTWpELFNBQVMsU0FBQyx5QkFBeUIsRUFBRSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTt1Q0FNeEUsU0FBUyxTQUFDLDBCQUEwQixFQUFFLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBDb21wb25lbnQsXG4gICAgRWxlbWVudFJlZixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgTmdab25lLFxuICAgIE9uSW5pdCxcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBWaWV3Q2hpbGRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJZ3hHcmlkQ2VsbENvbXBvbmVudCB9IGZyb20gJy4uL2NlbGwuY29tcG9uZW50JztcbmltcG9ydCB7IEdyaWRCYXNlQVBJU2VydmljZSB9IGZyb20gJy4uL2FwaS5zZXJ2aWNlJztcbmltcG9ydCB7IGdldE5vZGVTaXplVmlhUmFuZ2UsIFBsYXRmb3JtVXRpbCB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgSWd4R3JpZEJhc2VEaXJlY3RpdmUgfSBmcm9tICcuL3B1YmxpY19hcGknO1xuaW1wb3J0IHsgSWd4R3JpZFNlbGVjdGlvblNlcnZpY2UsIElneEdyaWRDUlVEU2VydmljZSB9IGZyb20gJy4uL3NlbGVjdGlvbi9zZWxlY3Rpb24uc2VydmljZSc7XG5pbXBvcnQgeyBIYW1tZXJHZXN0dXJlc01hbmFnZXIgfSBmcm9tICcuLi8uLi9jb3JlL3RvdWNoJztcbmltcG9ydCB7IEdyaWRUeXBlIH0gZnJvbSAnLi4vY29tbW9uL2dyaWQuaW50ZXJmYWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgc2VsZWN0b3I6ICdpZ3gtZXhwYW5kYWJsZS1ncmlkLWNlbGwnLFxuICAgIHRlbXBsYXRlVXJsOiAnZXhwYW5kYWJsZS1jZWxsLmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFtIYW1tZXJHZXN0dXJlc01hbmFnZXJdXG59KVxuZXhwb3J0IGNsYXNzIElneEdyaWRFeHBhbmRhYmxlQ2VsbENvbXBvbmVudCBleHRlbmRzIElneEdyaWRDZWxsQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblNlcnZpY2U6IElneEdyaWRTZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgIGNydWRTZXJ2aWNlOiBJZ3hHcmlkQ1JVRFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgZ3JpZEFQSTogR3JpZEJhc2VBUElTZXJ2aWNlPElneEdyaWRCYXNlRGlyZWN0aXZlICYgR3JpZFR5cGU+LFxuICAgICAgICAgICAgICAgIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogRWxlbWVudFJlZixcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgem9uZTogTmdab25lLFxuICAgICAgICAgICAgICAgIHRvdWNoTWFuYWdlcjogSGFtbWVyR2VzdHVyZXNNYW5hZ2VyLFxuICAgICAgICAgICAgICAgIEBJbmplY3QoRE9DVU1FTlQpIHB1YmxpYyBkb2N1bWVudCxcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGxhdGZvcm1VdGlsOiBQbGF0Zm9ybVV0aWwpIHtcbiAgICAgICAgc3VwZXIoc2VsZWN0aW9uU2VydmljZSwgY3J1ZFNlcnZpY2UsIGdyaWRBUEksIGNkciwgZWxlbWVudCwgem9uZSwgdG91Y2hNYW5hZ2VyLCBwbGF0Zm9ybVV0aWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGV4cGFuZGVkID0gZmFsc2U7XG5cbiAgICBAVmlld0NoaWxkKCdpbmRpY2F0b3InLCB7IHJlYWQ6IEVsZW1lbnRSZWYgfSlcbiAgICBwdWJsaWMgaW5kaWNhdG9yOiBFbGVtZW50UmVmO1xuXG4gICAgQFZpZXdDaGlsZCgnaW5kZW50YXRpb25EaXYnLCB7IHJlYWQ6IEVsZW1lbnRSZWYgfSlcbiAgICBwdWJsaWMgaW5kZW50YXRpb25EaXY6IEVsZW1lbnRSZWY7XG5cbiAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICovXG4gICBAVmlld0NoaWxkKCdkZWZhdWx0RXhwYW5kZWRUZW1wbGF0ZScsIHsgcmVhZDogVGVtcGxhdGVSZWYsIHN0YXRpYzogdHJ1ZSB9KVxuICAgcHJvdGVjdGVkIGRlZmF1bHRFeHBhbmRlZFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqL1xuICAgQFZpZXdDaGlsZCgnZGVmYXVsdENvbGxhcHNlZFRlbXBsYXRlJywgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiB0cnVlIH0pXG4gICBwcm90ZWN0ZWQgZGVmYXVsdENvbGxhcHNlZFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyB0b2dnbGUoZXZlbnQ6IEV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBjb25zdCBleHBhbnNpb25TdGF0ZSA9IHRoaXMuZ3JpZEFQSS5nZXRfcm93X2V4cGFuc2lvbl9zdGF0ZSh0aGlzLnJvdy5yb3dEYXRhKTtcbiAgICAgICAgdGhpcy5ncmlkQVBJLnNldF9yb3dfZXhwYW5zaW9uX3N0YXRlKHRoaXMucm93LnJvd0lELCAhZXhwYW5zaW9uU3RhdGUsIGV2ZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG9uSW5kaWNhdG9yRm9jdXMoKSB7XG4gICAgICAgIHRoaXMuZ3JpZEFQSS5zdWJtaXRfdmFsdWUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGNhbGN1bGF0ZVNpemVUb0ZpdChyYW5nZTogYW55KTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgaW5kaWNhdG9yV2lkdGggPSB0aGlzLmluZGljYXRvci5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICBjb25zdCBpbmRpY2F0b3JTdHlsZSA9IHRoaXMuZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmluZGljYXRvci5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgY29uc3QgaW5kaWNhdG9yTWFyZ2luID0gcGFyc2VGbG9hdChpbmRpY2F0b3JTdHlsZS5tYXJnaW5SaWdodCk7XG4gICAgICAgIGxldCBsZWZ0UGFkZGluZyA9IDA7XG4gICAgICAgIGlmICh0aGlzLmluZGVudGF0aW9uRGl2KSB7XG4gICAgICAgICAgICBjb25zdCBpbmRlbnRhdGlvblN0eWxlID0gdGhpcy5kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuaW5kZW50YXRpb25EaXYubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICBsZWZ0UGFkZGluZyA9IHBhcnNlRmxvYXQoaW5kZW50YXRpb25TdHlsZS5wYWRkaW5nTGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFyZ2VzdFdpZHRoID0gTWF0aC5tYXgoLi4uQXJyYXkuZnJvbSh0aGlzLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW4pXG4gICAgICAgICAgICAubWFwKChjaGlsZCkgPT4gZ2V0Tm9kZVNpemVWaWFSYW5nZShyYW5nZSwgY2hpbGQpKSk7XG4gICAgICAgIHJldHVybiBsYXJnZXN0V2lkdGggKyBpbmRpY2F0b3JXaWR0aCArIGluZGljYXRvck1hcmdpbiArIGxlZnRQYWRkaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGljb25UZW1wbGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdyaWQucm93RXhwYW5kZWRJbmRpY2F0b3JUZW1wbGF0ZSB8fCB0aGlzLmRlZmF1bHRFeHBhbmRlZFRlbXBsYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5yb3dDb2xsYXBzZWRJbmRpY2F0b3JUZW1wbGF0ZSB8fCB0aGlzLmRlZmF1bHRDb2xsYXBzZWRUZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHNob3dFeHBhbmRlckluZGljYXRvcigpIHtcbiAgICAgICAgY29uc3QgaXNHaG9zdCA9IHRoaXMucm93LnBpbm5lZCAmJiB0aGlzLnJvdy5kaXNhYmxlZDtcbiAgICAgICAgcmV0dXJuICF0aGlzLmVkaXRNb2RlICYmICghdGhpcy5yb3cucGlubmVkIHx8IGlzR2hvc3QpO1xuICAgIH1cbn1cbiJdfQ==