import { Directive } from '@angular/core';
import { ConnectedPositioningStrategy } from '../services/public_api';
import { VerticalAlignment } from '../services/overlay/utilities';
import { scaleInVerBottom, scaleInVerTop } from '../animations/main';
import { IgxForOfSyncService } from '../directives/for-of/for_of.sync.service';
export class IgxGridBodyDirective {
}
IgxGridBodyDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxGridBody]',
                providers: [IgxForOfSyncService]
            },] }
];
/**
 * @hidden
 */
export class RowEditPositionStrategy extends ConnectedPositioningStrategy {
    constructor() {
        super(...arguments);
        this.isTop = false;
        this.isTopInitialPosition = null;
    }
    position(contentElement, size, document, initialCall, target) {
        const container = this.settings.container; // grid.tbody
        const targetElement = target || this.settings.target; // current grid.row
        // Position of the overlay depends on the available space in the grid.
        // If the bottom space is not enough then the the row overlay will show at the top of the row.
        // Once shown, either top or bottom, then this position stays until the overlay is closed (isTopInitialPosition property),
        // which means that when scrolling then overlay may hide, while the row is still visible (UX requirement).
        this.isTop = this.isTopInitialPosition !== null ?
            this.isTopInitialPosition :
            container.getBoundingClientRect().bottom <
                targetElement.getBoundingClientRect().bottom + contentElement.getBoundingClientRect().height;
        // Set width of the row editing overlay to equal row width, otherwise it fits 100% of the grid.
        contentElement.style.width = targetElement.clientWidth + 'px';
        this.settings.verticalStartPoint = this.settings.verticalDirection = this.isTop ? VerticalAlignment.Top : VerticalAlignment.Bottom;
        this.settings.openAnimation = this.isTop ? scaleInVerBottom : scaleInVerTop;
        super.position(contentElement, { width: targetElement.clientWidth, height: targetElement.clientHeight }, document, initialCall, targetElement);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC5jb21tb24uanMiLCJzb3VyY2VSb290IjoiL2hvbWUvcnVubmVyL3dvcmsvaWduaXRldWktYW5ndWxhci9pZ25pdGV1aS1hbmd1bGFyL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjLyIsInNvdXJjZXMiOlsibGliL2dyaWRzL2dyaWQuY29tbW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDMUMsT0FBTyxFQUFFLDRCQUE0QixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDdEUsT0FBTyxFQUFFLGlCQUFpQixFQUEyQixNQUFNLCtCQUErQixDQUFDO0FBQzNGLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxhQUFhLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUNyRSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSwwQ0FBMEMsQ0FBQztBQVEvRSxNQUFNLE9BQU8sb0JBQW9COzs7WUFKaEMsU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxlQUFlO2dCQUN6QixTQUFTLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQzthQUNuQzs7QUFtQkQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8sdUJBQXdCLFNBQVEsNEJBQTRCO0lBQXpFOztRQUNJLFVBQUssR0FBRyxLQUFLLENBQUM7UUFDZCx5QkFBb0IsR0FBRyxJQUFJLENBQUM7SUF3QmhDLENBQUM7SUF0QkcsUUFBUSxDQUFDLGNBQTJCLEVBQUUsSUFBdUMsRUFBRSxRQUFtQixFQUFFLFdBQXFCLEVBQ2pILE1BQTRCO1FBQ2hDLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsYUFBYTtRQUN4RCxNQUFNLGFBQWEsR0FBZ0IsTUFBTSxJQUFpQixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLG1CQUFtQjtRQUVuRyxzRUFBc0U7UUFDdEUsOEZBQThGO1FBQzlGLDBIQUEwSDtRQUMxSCwwR0FBMEc7UUFDMUcsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsb0JBQW9CLEtBQUssSUFBSSxDQUFDLENBQUM7WUFDN0MsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUM7WUFDM0IsU0FBUyxDQUFDLHFCQUFxQixFQUFFLENBQUMsTUFBTTtnQkFDcEMsYUFBYSxDQUFDLHFCQUFxQixFQUFFLENBQUMsTUFBTSxHQUFHLGNBQWMsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLE1BQU0sQ0FBQztRQUVyRywrRkFBK0Y7UUFDL0YsY0FBYyxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsYUFBYSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7UUFDOUQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDO1FBQ25JLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUM7UUFFNUUsS0FBSyxDQUFDLFFBQVEsQ0FBQyxjQUFjLEVBQUUsRUFBRSxLQUFLLEVBQUUsYUFBYSxDQUFDLFdBQVcsRUFBRSxNQUFNLEVBQUUsYUFBYSxDQUFDLFlBQVksRUFBRSxFQUMzRixRQUFRLEVBQUUsV0FBVyxFQUFFLGFBQWEsQ0FBQyxDQUFDO0lBQ3RELENBQUM7Q0FDSiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29ubmVjdGVkUG9zaXRpb25pbmdTdHJhdGVneSB9IGZyb20gJy4uL3NlcnZpY2VzL3B1YmxpY19hcGknO1xuaW1wb3J0IHsgVmVydGljYWxBbGlnbm1lbnQsIFBvc2l0aW9uU2V0dGluZ3MsIFBvaW50IH0gZnJvbSAnLi4vc2VydmljZXMvb3ZlcmxheS91dGlsaXRpZXMnO1xuaW1wb3J0IHsgc2NhbGVJblZlckJvdHRvbSwgc2NhbGVJblZlclRvcCB9IGZyb20gJy4uL2FuaW1hdGlvbnMvbWFpbic7XG5pbXBvcnQgeyBJZ3hGb3JPZlN5bmNTZXJ2aWNlIH0gZnJvbSAnLi4vZGlyZWN0aXZlcy9mb3Itb2YvZm9yX29mLnN5bmMuc2VydmljZSc7XG5pbXBvcnQgeyBDb2x1bW5QaW5uaW5nUG9zaXRpb24sIFJvd1Bpbm5pbmdQb3NpdGlvbiB9IGZyb20gJy4vY29tbW9uL2VudW1zJztcblxuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tpZ3hHcmlkQm9keV0nLFxuICAgIHByb3ZpZGVyczogW0lneEZvck9mU3luY1NlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIElneEdyaWRCb2R5RGlyZWN0aXZlIHt9XG5cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm93RWRpdFBvc2l0aW9uU2V0dGluZ3MgZXh0ZW5kcyBQb3NpdGlvblNldHRpbmdzIHtcbiAgICBjb250YWluZXI/OiBIVE1MRWxlbWVudDtcbn1cblxuLyoqXG4gKiBBbiBpbnRlcmZhY2UgZGVzY3JpYmluZyBzZXR0aW5ncyBmb3Igcm93L2NvbHVtbiBwaW5uaW5nIHBvc2l0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElQaW5uaW5nQ29uZmlnIHtcbiAgICBjb2x1bW5zPzogQ29sdW1uUGlubmluZ1Bvc2l0aW9uO1xuICAgIHJvd3M/OiBSb3dQaW5uaW5nUG9zaXRpb247XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgUm93RWRpdFBvc2l0aW9uU3RyYXRlZ3kgZXh0ZW5kcyBDb25uZWN0ZWRQb3NpdGlvbmluZ1N0cmF0ZWd5IHtcbiAgICBpc1RvcCA9IGZhbHNlO1xuICAgIGlzVG9wSW5pdGlhbFBvc2l0aW9uID0gbnVsbDtcbiAgICBwdWJsaWMgc2V0dGluZ3M6IFJvd0VkaXRQb3NpdGlvblNldHRpbmdzO1xuICAgIHBvc2l0aW9uKGNvbnRlbnRFbGVtZW50OiBIVE1MRWxlbWVudCwgc2l6ZTogeyB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9LCBkb2N1bWVudD86IERvY3VtZW50LCBpbml0aWFsQ2FsbD86IGJvb2xlYW4sXG4gICAgICAgICAgICB0YXJnZXQ/OiBQb2ludCB8IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuc2V0dGluZ3MuY29udGFpbmVyOyAvLyBncmlkLnRib2R5XG4gICAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSA8SFRNTEVsZW1lbnQ+dGFyZ2V0IHx8IDxIVE1MRWxlbWVudD50aGlzLnNldHRpbmdzLnRhcmdldDsgLy8gY3VycmVudCBncmlkLnJvd1xuXG4gICAgICAgIC8vIFBvc2l0aW9uIG9mIHRoZSBvdmVybGF5IGRlcGVuZHMgb24gdGhlIGF2YWlsYWJsZSBzcGFjZSBpbiB0aGUgZ3JpZC5cbiAgICAgICAgLy8gSWYgdGhlIGJvdHRvbSBzcGFjZSBpcyBub3QgZW5vdWdoIHRoZW4gdGhlIHRoZSByb3cgb3ZlcmxheSB3aWxsIHNob3cgYXQgdGhlIHRvcCBvZiB0aGUgcm93LlxuICAgICAgICAvLyBPbmNlIHNob3duLCBlaXRoZXIgdG9wIG9yIGJvdHRvbSwgdGhlbiB0aGlzIHBvc2l0aW9uIHN0YXlzIHVudGlsIHRoZSBvdmVybGF5IGlzIGNsb3NlZCAoaXNUb3BJbml0aWFsUG9zaXRpb24gcHJvcGVydHkpLFxuICAgICAgICAvLyB3aGljaCBtZWFucyB0aGF0IHdoZW4gc2Nyb2xsaW5nIHRoZW4gb3ZlcmxheSBtYXkgaGlkZSwgd2hpbGUgdGhlIHJvdyBpcyBzdGlsbCB2aXNpYmxlIChVWCByZXF1aXJlbWVudCkuXG4gICAgICAgIHRoaXMuaXNUb3AgPSB0aGlzLmlzVG9wSW5pdGlhbFBvc2l0aW9uICE9PSBudWxsID9cbiAgICAgICAgICAgIHRoaXMuaXNUb3BJbml0aWFsUG9zaXRpb24gOlxuICAgICAgICAgICAgY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSA8XG4gICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20gKyBjb250ZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG5cbiAgICAgICAgLy8gU2V0IHdpZHRoIG9mIHRoZSByb3cgZWRpdGluZyBvdmVybGF5IHRvIGVxdWFsIHJvdyB3aWR0aCwgb3RoZXJ3aXNlIGl0IGZpdHMgMTAwJSBvZiB0aGUgZ3JpZC5cbiAgICAgICAgY29udGVudEVsZW1lbnQuc3R5bGUud2lkdGggPSB0YXJnZXRFbGVtZW50LmNsaWVudFdpZHRoICsgJ3B4JztcbiAgICAgICAgdGhpcy5zZXR0aW5ncy52ZXJ0aWNhbFN0YXJ0UG9pbnQgPSB0aGlzLnNldHRpbmdzLnZlcnRpY2FsRGlyZWN0aW9uID0gdGhpcy5pc1RvcCA/IFZlcnRpY2FsQWxpZ25tZW50LlRvcCA6IFZlcnRpY2FsQWxpZ25tZW50LkJvdHRvbTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5vcGVuQW5pbWF0aW9uID0gdGhpcy5pc1RvcCA/IHNjYWxlSW5WZXJCb3R0b20gOiBzY2FsZUluVmVyVG9wO1xuXG4gICAgICAgIHN1cGVyLnBvc2l0aW9uKGNvbnRlbnRFbGVtZW50LCB7IHdpZHRoOiB0YXJnZXRFbGVtZW50LmNsaWVudFdpZHRoLCBoZWlnaHQ6IHRhcmdldEVsZW1lbnQuY2xpZW50SGVpZ2h0IH0sXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LCBpbml0aWFsQ2FsbCwgdGFyZ2V0RWxlbWVudCk7XG4gICAgfVxufVxuIl19