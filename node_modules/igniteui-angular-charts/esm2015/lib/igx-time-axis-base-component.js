import * as tslib_1 from "tslib";
import { EventEmitter, Output, forwardRef, Input } from '@angular/core';
import { delegateCombine } from "igniteui-angular-core";
import { IgxCategoryAxisBaseComponent } from "./igx-category-axis-base-component";
import { IgxAxisComponent } from "./igx-axis-component";
import { ensureBool } from "igniteui-angular-core";
/**
 * Represents an category-based horizontal X axis that uses a DateTime scale.
*
* Represents horizontal axis that uses a DateTime scale.
*
* ```html
* <igx-data-chart
*     [dataSource]="data">
*     <igx-time-x-axis
* 		dateTimeMemberPath="date"
* 		#xAxis>
*     </igx-time-x-axis>
* </igx-data-chart>
* ```
*
* ```ts
* let xAxis = new IgxTimeXAxisComponent();
* xAxis.dataTimeMemberPath="date";
* this.chart.axes.add(xAxis);
* ```
*/
export const IgxTimeAxisBaseComponent_PROVIDERS = [{ provide: IgxCategoryAxisBaseComponent, useExisting: forwardRef(() => IgxTimeAxisBaseComponent) }, { provide: IgxAxisComponent, useExisting: forwardRef(() => IgxTimeAxisBaseComponent) }];
export class IgxTimeAxisBaseComponent extends IgxCategoryAxisBaseComponent {
    constructor() {
        super();
        this._actualMinimumValueChange = null;
        this._actualMaximumValueChange = null;
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * Gets or sets the DateTime mapping property for the axis.
    *
    * Use `dateTimeMemberPath` property for DateTime mapping with the axis.
    *
    * ```html
    * <igx-data-chart
    *     [dataSource]="data">
    *     <igx-time-x-axis
    * 		dateTimeMemberPath="date"
    * 		#xAxis>
    *     </igx-time-x-axis>
    * </igx-data-chart>
    * ```
    *
    * ```ts
    * let xAxis = new IgxTimeXAxisComponent();
    * xAxis.dataTimeMemberPath="date";
    * this.chart.axes.add(xAxis);
    * ```
    */
    get dateTimeMemberPath() {
        return this.i.dateTimeMemberPath;
    }
    set dateTimeMemberPath(v) {
        this.i.dateTimeMemberPath = v;
    }
    /**
     * Gets or sets whether the data assigned to the date time axis should be considered pre-sorted by date/time.
    *
    * Use `isDataPreSorted` property to decide if the data assigned to the date time axis should be considered pre-sorted by date/time.
    */
    get isDataPreSorted() {
        return this.i.k9;
    }
    set isDataPreSorted(v) {
        this.i.k9 = ensureBool(v);
    }
    /**
     * Gets the coerced minimum value.
    *
    * Use `actualMinimumValue` to get the coerced maximum value.
    */
    get actualMinimumValue() {
        return this.i.actualMinimumValue;
    }
    set actualMinimumValue(v) {
        this.i.actualMinimumValue = v;
    }
    /**
     * Gets the coerced maximum value.
    *
    * Use `actualMaximumValue` to get the  coerced maximum value
    */
    get actualMaximumValue() {
        return this.i.actualMaximumValue;
    }
    set actualMaximumValue(v) {
        this.i.actualMaximumValue = v;
    }
    /**
     * Gets or sets the axis MinimumValue.
    *
    * Use `minimumValue` property for axis minimum value.
    *
    * ```ts
    * this.timeXAxis.maximumValue="2019-12-26";
    * ```
    */
    get minimumValue() {
        return this.i.minimumValue;
    }
    set minimumValue(v) {
        this.i.minimumValue = v;
    }
    /**
     * Gets or sets the axis MaximumValue.
    *
    * Use `maximumValue` property for axis maximum value.
    *
    * ```ts
    * this.timeXAxis.maximumValue="2019-12-26";
    * ```
    */
    get maximumValue() {
        return this.i.maximumValue;
    }
    set maximumValue(v) {
        this.i.maximumValue = v;
    }
    /**
     * Checks if the axis is of date time axis type
    *
    * Use `isDateTime` property to Checks if the axis is of date time axis type.
    *
    * ```ts
    * const isDT = this.timeXAxis.isDateTime;
    * ```
    */
    get isDateTime() {
        return this.i.b7;
    }
    /**
     * Checks if axis requires sorting of items
    *
    * Use `isSorting` property to Checks if axis requires sorting of items.
    *
    * ```ts
    * const isDT = this.timeXAxis.isDateTime;
    * ```
    */
    get isSorting() {
        return this.i.cf;
    }
    getItemValue(item, memberPathName) {
        let iv = this.i.e6(item, memberPathName);
        return (iv);
    }
    /**
     * Gets the index of the data item with the value nearest the given value.
    
    * @param unscaledValue  * The value to find a value close to.
    */
    getIndexClosestToUnscaledValue(unscaledValue) {
        let iv = this.i.i$f(unscaledValue);
        return (iv);
    }
    /**
     * Updates the axis when the data has been changed.
    
    */
    notifyDataChanged() {
        this.i.i$i();
    }
    get actualMinimumValueChange() {
        if (this._actualMinimumValueChange == null) {
            this._actualMinimumValueChange = new EventEmitter();
            this.i.propertyChanged = delegateCombine(this.i.propertyChanged, (o, e) => {
                let iv = e;
                let ext = this.actualMinimumValue;
                if (this.beforeActualMinimumValueChange) {
                    this.beforeActualMinimumValueChange(this, ext);
                }
                this._actualMinimumValueChange.emit(ext);
            });
        }
        return this._actualMinimumValueChange;
    }
    get actualMaximumValueChange() {
        if (this._actualMaximumValueChange == null) {
            this._actualMaximumValueChange = new EventEmitter();
            this.i.propertyChanged = delegateCombine(this.i.propertyChanged, (o, e) => {
                let iv = e;
                let ext = this.actualMaximumValue;
                if (this.beforeActualMaximumValueChange) {
                    this.beforeActualMaximumValueChange(this, ext);
                }
                this._actualMaximumValueChange.emit(ext);
            });
        }
        return this._actualMaximumValueChange;
    }
}
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [String])
], IgxTimeAxisBaseComponent.prototype, "dateTimeMemberPath", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [Boolean])
], IgxTimeAxisBaseComponent.prototype, "isDataPreSorted", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Date),
    tslib_1.__metadata("design:paramtypes", [Date])
], IgxTimeAxisBaseComponent.prototype, "actualMinimumValue", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Date),
    tslib_1.__metadata("design:paramtypes", [Date])
], IgxTimeAxisBaseComponent.prototype, "actualMaximumValue", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Date),
    tslib_1.__metadata("design:paramtypes", [Date])
], IgxTimeAxisBaseComponent.prototype, "minimumValue", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Date),
    tslib_1.__metadata("design:paramtypes", [Date])
], IgxTimeAxisBaseComponent.prototype, "maximumValue", null);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter),
    tslib_1.__metadata("design:paramtypes", [])
], IgxTimeAxisBaseComponent.prototype, "actualMinimumValueChange", null);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter),
    tslib_1.__metadata("design:paramtypes", [])
], IgxTimeAxisBaseComponent.prototype, "actualMaximumValueChange", null);
//# sourceMappingURL=igx-time-axis-base-component.js.map