import * as tslib_1 from "tslib";
import { EventEmitter, Output, Input } from '@angular/core';
import { delegateCombine } from "igniteui-angular-core";
import { toPoint, ensureBool } from "igniteui-angular-core";
import { TypeRegistrar } from "igniteui-angular-core";
import { IgxStackedSeriesCreatedEventArgs } from './igx-stacked-series-created-event-args';
import { IgxCategorySeriesComponent } from "./igx-category-series-component";
import { ContentChildren, QueryList } from '@angular/core';
import { NotifyCollectionChangedAction } from "igniteui-angular-core";
import { IgxStackedFragmentSeriesComponent } from './igx-stacked-fragment-series-component';
import { CollectionAdapter } from "igniteui-angular-core";
import { IgxStackedSeriesCollection } from './igx-stacked-series-collection';
/**
 * Represents a IgxStackedSeriesBaseComponent base series.
*/
export const IgxStackedSeriesBaseComponent_PROVIDERS = [];
export class IgxStackedSeriesBaseComponent extends IgxCategorySeriesComponent {
    constructor() {
        super();
        this._seriesAdapter = null;
        /**
         * The series actually present in the chart. Do not directly modify this array.
         * This array's contents can be modified by causing Angular to reproject the child content.
         * Or adding and removing series from the manual series collection on the series property.
         */
        this.actualSeries = [];
        this._series = null;
        this._seriesCreated = null;
        //=============================
        this._seriesAdapter = new CollectionAdapter([], this.i.series, this.actualSeries, (c) => c.i, (i) => {
            i.owner = this;
            //(<any>i)._provideRenderer(this._dataSource);
            //i.provideData(this._dataSource);
            //this._ensureDefaultTooltip(i);
            //this._ensureTooltipCreated(i);
        }, (i) => {
            //(<any>i)._provideRenderer(null);
            //i.provideData(null); 
        });
        //=============================
    }
    createImplementation() {
        return null;
    }
    ngOnInit() {
    }
    get i() {
        return this._implementation;
    }
    //=============================
    ngAfterContentInit() {
        this._seriesAdapter.updateQuery(this.fragments);
    }
    /**
     * A collection or manually added series for the chart.
    */
    get series() {
        if (this._series === null) {
            let coll = new IgxStackedSeriesCollection();
            let inner = coll._innerColl;
            inner.addListener((sender, e) => {
                switch (e.action) {
                    case NotifyCollectionChangedAction.Add:
                        this._seriesAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                        break;
                    case NotifyCollectionChangedAction.Remove:
                        this._seriesAdapter.removeManualItemAt(e.oldStartingIndex);
                        break;
                    case NotifyCollectionChangedAction.Replace:
                        this._seriesAdapter.removeManualItemAt(e.oldStartingIndex);
                        this._seriesAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                        break;
                    case NotifyCollectionChangedAction.Reset:
                        this._seriesAdapter.clearManualItems();
                        break;
                }
            });
            this._series = coll;
        }
        return this._series;
    }
    //=============================
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igx" + name + "Component";
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    /**
 * Gets or sets whether series should be automatically generated. Reqiures the use of GroupBy as the ItemsSource.
*/
    get autoGenerateSeries() {
        return this.i.o9;
    }
    set autoGenerateSeries(v) {
        this.i.o9 = ensureBool(v);
    }
    /**
     * Gets or sets whether the order of the fragment series should be reversed in the legend.
    */
    get reverseLegendOrder() {
        return this.i.pa;
    }
    set reverseLegendOrder(v) {
        this.i.pa = ensureBool(v);
    }
    /**
     * Checks if this series is a stacked series
    */
    get isStacked() {
        return this.i.isStacked;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.series != null && this.series.findByName && this.series.findByName(name)) {
            return this.series.findByName(name);
        }
        return null;
    }
    /**
 * Simulates a pointer hover over the series surface.

* @param point  * The pointer position relative to the series viewport over which to hover.
*/
    simulateHover(point) {
        this.i.jl(toPoint(point));
    }
    /**
     * Scrolls the series to display the item for the specified data item.
     * The series is scrolled by the minimum amount required to place the specified data item within
     * the central 80% of the visible axis.
    
    * @param item  * The data item (item) to scroll to.
    */
    scrollIntoView(item) {
        let iv = this.i.c9(item);
        return (iv);
    }
    /**
     * Event raised when a new fragment series is automatically generated.
    */
    get seriesCreated() {
        if (this._seriesCreated == null) {
            this._seriesCreated = new EventEmitter();
            this.i.seriesCreated = delegateCombine(this.i.seriesCreated, (o, e) => {
                this._runInZone(() => {
                    let outerArgs = new IgxStackedSeriesCreatedEventArgs();
                    outerArgs._provideImplementation(e);
                    if (this.beforeSeriesCreated) {
                        this.beforeSeriesCreated(this, outerArgs);
                    }
                    this._seriesCreated.emit({
                        sender: this,
                        args: outerArgs
                    });
                });
            });
        }
        return this._seriesCreated;
    }
}
tslib_1.__decorate([
    ContentChildren(IgxStackedFragmentSeriesComponent),
    tslib_1.__metadata("design:type", QueryList)
], IgxStackedSeriesBaseComponent.prototype, "fragments", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [Boolean])
], IgxStackedSeriesBaseComponent.prototype, "autoGenerateSeries", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [Boolean])
], IgxStackedSeriesBaseComponent.prototype, "reverseLegendOrder", null);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter),
    tslib_1.__metadata("design:paramtypes", [])
], IgxStackedSeriesBaseComponent.prototype, "seriesCreated", null);
//# sourceMappingURL=igx-stacked-series-base-component.js.map