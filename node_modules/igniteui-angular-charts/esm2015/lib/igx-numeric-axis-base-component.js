import * as tslib_1 from "tslib";
import { EventEmitter, Output, forwardRef, Input } from '@angular/core';
import { delegateCombine } from "igniteui-angular-core";
import { IgxAxisComponent } from "./igx-axis-component";
import { ensureBool } from "igniteui-angular-core";
/**
 * Represents the base class for all IgxDataChartComponent numeric axes.
*/
export const IgxNumericAxisBaseComponent_PROVIDERS = [{ provide: IgxAxisComponent, useExisting: forwardRef(() => IgxNumericAxisBaseComponent) }];
export class IgxNumericAxisBaseComponent extends IgxAxisComponent {
    constructor() {
        super();
        this._actualMinimumValueChange = null;
        this._actualMaximumValueChange = null;
        this._actualIntervalChange = null;
        this._actualMinorIntervalChange = null;
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * Gets or sets if the current axis is of numeric axis type
    */
    get isNumeric() {
        return this.i.cc;
    }
    /**
     * Gets or sets the MinimumValue property.
    *
    * Used to set the minimum value of a numeric axis. To get the minimum value in effect on a numeric axis use `actualMinimumValue`.
    *
    * ```ts
    * this.yAxis.minimumValue = 0;
    * ```
    *
    * ```html
    * <igx-data-chart
    *     [dataSource]="data">
    *     <igx-category-x-axis
    *         label="label"
    *         #xAxis>
    *     </igx-category-x-axis>
    *     <igx-numeric-y-axis
    *         minimumValue=0
    *         #yAxis>
    *     </igx-numeric-y-axis>
    *     <igx-column-series
    *         [xAxis]="xAxis"
    *         [yAxis]="yAxis"
    *         valueMemberPath="value">
    *     </igx-column-series>
    * </igx-data-chart>
    * ```
    */
    get minimumValue() {
        return this.i.kj;
    }
    set minimumValue(v) {
        this.i.kj = +v;
    }
    /**
     * Gets the effective minimum value for the current numeric axis object.
    *
    * ```ts
    * let effectiveMinValue: number = yAxis.actualMinimumValue;
    * ```
    */
    get actualMinimumValue() {
        return this.i.kb;
    }
    set actualMinimumValue(v) {
        this.i.kb = +v;
    }
    /**
     * Gets the effective minimum value for the current numeric axis object.
    *
    * The `actualVisibleMinimumValue` is used to get the current visible maximum value for the a numeric axis. Note, at times the `actualVisibleMinimumValue` may differ from the `actualMinimumValue`, for example when the chart is zoomed.
    *
    * ```ts
    * let effectiveVisibleMinValue: number = yAxis.actualVisibleMinimumValue;
    * ```
    */
    get actualVisibleMinimumValue() {
        return this.i.ke;
    }
    set actualVisibleMinimumValue(v) {
        this.i.ke = +v;
    }
    /**
     * Gets or sets the MaximumValue property.
    *
    * Used to set the maximum value of a numeric axis. To get the maximum value in effect on a numeric axis use `actualMaximumValue`.
    *
    * ```ts
    * this.yAxis.maximumValue = 80;
    * ```
    *
    * ```html
    * <igx-data-chart
    *     [dataSource]="data">
    *     <igx-category-x-axis
    *         label="label"
    *         #xAxis>
    *     </igx-category-x-axis>
    *     <igx-numeric-y-axis
    *         maximumValue=80
    *         #yAxis>
    *     </igx-numeric-y-axis>
    *     <igx-line-series
    *         [xAxis]="xAxis"
    *         [yAxis]="yAxis"
    *         valueMemberPath="value">
    *     </igx-line-series>
    * </igx-data-chart>
    * ```
    */
    get maximumValue() {
        return this.i.ki;
    }
    set maximumValue(v) {
        this.i.ki = +v;
    }
    /**
     * Gets the effective maximum value for the current numeric axis object.
    *
    * ```ts
    * let effectiveMaxValue: number = yAxis.actualMaximumValue;
    * ```
    */
    get actualMaximumValue() {
        return this.i.ka;
    }
    set actualMaximumValue(v) {
        this.i.ka = +v;
    }
    /**
     * Gets the effective visible maximum value for the current numeric axis object.
    *
    * The `actualVisibleMaximumValue` is used to get the current visible maximum value for the a numeric axis. Note, at times the `actualVisibleMaximumValue` may differ from the `actualMaximumValue`, for example when the chart is zoomed.
    *
    * ```ts
    * let effectiveVisibleMaxValue: number = yAxis.actualVisibleMaximumValue;
    * ```
    */
    get actualVisibleMaximumValue() {
        return this.i.kd;
    }
    set actualVisibleMaximumValue(v) {
        this.i.kd = +v;
    }
    /**
     * Gets or sets the Interval property.
    *
    * The `interval` is used to get or set the numeric axis major interval which specifies how frequent major gridlines and axis labels are rendered on an axis.
    *
    * ```ts
    * this.yAxis.interval = 20;
    * ```
    *
    * ```html
    * <igx-data-chart
    *       [dataSource]="data">
    *       <igx-category-x-axis
    *         label="label"
    *         #xAxis
    *         >
    *       </igx-category-x-axis>
    *       <igx-numeric-y-axis
    *         interval="20"
    *         #yAxis>
    *       </igx-numeric-y-axis>
    *
    *       <igx-column-series
    *         [xAxis]="xAxis"
    *         [yAxis]="yAxis"
    *         valueMemberPath="value">
    *       </igx-column-series>
    * </igx-data-chart>
    * ```
    */
    get interval() {
        return this.i.kf;
    }
    set interval(v) {
        this.i.kf = +v;
    }
    /**
     * Gets the effective value for the current Interval.
    *
    * ```ts
    * let effectiveInterval: number = yAxis.actualInterval;
    * ```
    */
    get actualInterval() {
        return this.i.j9;
    }
    set actualInterval(v) {
        this.i.j9 = +v;
    }
    /**
     * Gets or sets the MinorInterval property.
    *
    * The `minorInterval` is used to get or set the numeric axis minor interval which specifies how frequent minor gridlines are rendered on an axis. Please note, in order for minor gridlines to be displayed the following may also need to be set: `MinorStroke`, `MinorStrokeThickness`.
    *
    * ```ts
    * this.yAxis.minorInterval = 2.5;
    * this.yAxis.minorStroke = 'blue';
    * this.yAxis.minorStrokeThickness = 1;
    * ```
    *
    * ```html
    * <igx-data-chart
    *     [dataSource]="data" >
    *     <igx-category-x-axis
    *         label="label"
    *         #xAxis>
    *     </igx-category-x-axis>
    *     <igx-numeric-y-axis
    *         minorInterval= 2.5
    *         minorStroke="blue"
    *         #yAxis>
    *     </igx-numeric-y-axis>
    *     <igx-column-series
    *         [xAxis]="xAxis"
    *         [yAxis]="yAxis"
    *         valueMemberPath="value">
    *     </igx-column-series>
    * </igx-data-chart>
    * ```
    */
    get minorInterval() {
        return this.i.kk;
    }
    set minorInterval(v) {
        this.i.kk = +v;
    }
    /**
     * Gets the effective value for the current MinorInterval.
    *
    * ```ts
    * let effectiveMinorInterval: number = yAxis.actualMinorInterval;
    * ```
    */
    get actualMinorInterval() {
        return this.i.kc;
    }
    set actualMinorInterval(v) {
        this.i.kc = +v;
    }
    /**
     * Gets or sets the ReferenceValue property.
    *
    * Used to get or set a reference value on a numeric axis which when used with an area, bar, or column series will result in the series shapes being drawn above or below the specified value.
    *
    * ```ts
    * this.yAxis.referenceValue = 30;
    * ```
    *
    * ```html
    * <igx-data-chart
    *     [dataSource]="data">
    *     <igx-category-x-axis
    *         label="label"
    *         #xAxis>
    *     </igx-category-x-axis>
    *     <igx-numeric-y-axis
    *         referenceValue=30
    *         #yAxis>
    *     </igx-numeric-y-axis>
    *     <igx-column-series
    *         [xAxis]="xAxis"
    *         [yAxis]="yAxis"
    *         valueMemberPath="value">
    *     </igx-column-series>
    * </igx-data-chart>
    * ```
    */
    get referenceValue() {
        return this.i.kl;
    }
    set referenceValue(v) {
        this.i.kl = +v;
    }
    /**
     * Gets or sets the IsLogarithmic property.
    *
    * `isLogarithmic` is used to get or set whether the numeric axis scaler is in linear or logarithmic mode. For logarithmic scaling, this can be used in conjunction with `logarithmBase` to further define the logarithmic scale.
    *
    * ```ts
    * this.yAxis.isLogarithmic= true;
    * this.yAxis.logarithmBase = 2;
    * ```
    *
    * ```html
    * <igx-data-chart
    *       [dataSource]="data">
    *       <igx-category-x-axis
    *         label="label"
    *         #xAxis>
    *       </igx-category-x-axis>
    *       <igx-numeric-y-axis
    *         isLogarithmic=true
    *         logarithmBase=2
    *         #yAxis>
    *       </igx-numeric-y-axis>
    *       <igx-line-series
    *         [xAxis]="xAxis"
    *         [yAxis]="yAxis"
    *         valueMemberPath="value">
    *       </igx-line-series>
    * </igx-data-chart>
    * ```
    */
    get isLogarithmic() {
        return this.i.j0;
    }
    set isLogarithmic(v) {
        this.i.j0 = ensureBool(v);
    }
    /**
     * Determines if the axis has a valid logarithmic scale.
    *
    * ```ts
    * let effectiveLogarithmic: boolean = this.yAxis.actualIsLogarithmic
    * ```
    */
    get actualIsLogarithmic() {
        return this.i.jw;
    }
    set actualIsLogarithmic(v) {
        this.i.jw = ensureBool(v);
    }
    /**
     * Gets or sets the LogarithmBase property.
    *
    * `logarithmBase` is used to get or set logarithm base when a numeric axis is in Logarithmic scale mode. For logarithmic scaling, this is used in conjunction with `isLogarithmic` or `ScaleMode` to set logarithmic scaling.
    *
    * ```ts
    * this.yAxis.scaleMode = NumericScaleMode.Logarithmic;
    * this.yAxis.logarithmBase = 2;
    * ```
    *
    * ```html
    * <igx-data-chart
    *       [dataSource]="data">
    *       <igx-category-x-axis
    *         label="label"
    *         #xAxis>
    *       </igx-category-x-axis>
    *       <igx-numeric-y-axis
    *         scaleMode="Logarithmic"
    *         logarithmBase=2
    *         #yAxis>
    *       </igx-numeric-y-axis>
    *       <igx-line-series
    *         [xAxis]="xAxis"
    *         [yAxis]="yAxis"
    *         valueMemberPath="value">
    *       </igx-line-series>
    * </igx-data-chart>
    * ```
    */
    get logarithmBase() {
        return this.i.kn;
    }
    set logarithmBase(v) {
        this.i.kn = +v;
    }
    /**
     * Determines if the axis has a user-defined minimum.
    *
    *  `hasUserMaximum` is used to determine if a numeric axis has a user definied maximum value.
    *
    * ```ts
    * let hasSetMaximum: boolean = this.yAxis.hasUserMaximum;
    * ```
    */
    get hasUserMinimum() {
        return this.i.jz;
    }
    /**
     * Determines if the axis has a user-defined maximum.
    *
    *  `hasUserMinimum` is used to determine if a numeric axis has a user definied minium value.
    *
    * ```ts
    * let hasSetMinimum: boolean = this.yAxis.hasUserMinimum;
    * ```
    */
    get hasUserMaximum() {
        return this.i.jy;
    }
    /**
     * A boolean indicating whether or not to abbreviate large numbers.
    */
    get abbreviateLargeNumbers() {
        return this.i.jv;
    }
    set abbreviateLargeNumbers(v) {
        this.i.jv = ensureBool(v);
    }
    /**
     * Unscales a value from screen space into axis space.
    
    * @param unscaledValue  * The scaled value in screen coordinates to unscale into axis space.
    *
    * Unscales a value from screen space into axis space.
    *
    * ```ts
    * let dataValue: number = this.yAxis.unscaleValue(pixel);
    * ```
    */
    unscaleValue(unscaledValue) {
        let iv = this.i.km(unscaledValue);
        return (iv);
    }
    get actualMinimumValueChange() {
        if (this._actualMinimumValueChange == null) {
            this._actualMinimumValueChange = new EventEmitter();
            this.i.propertyChanged = delegateCombine(this.i.propertyChanged, (o, e) => {
                let iv = e;
                let ext = this.actualMinimumValue;
                if (this.beforeActualMinimumValueChange) {
                    this.beforeActualMinimumValueChange(this, ext);
                }
                this._actualMinimumValueChange.emit(ext);
            });
        }
        return this._actualMinimumValueChange;
    }
    get actualMaximumValueChange() {
        if (this._actualMaximumValueChange == null) {
            this._actualMaximumValueChange = new EventEmitter();
            this.i.propertyChanged = delegateCombine(this.i.propertyChanged, (o, e) => {
                let iv = e;
                let ext = this.actualMaximumValue;
                if (this.beforeActualMaximumValueChange) {
                    this.beforeActualMaximumValueChange(this, ext);
                }
                this._actualMaximumValueChange.emit(ext);
            });
        }
        return this._actualMaximumValueChange;
    }
    get actualIntervalChange() {
        if (this._actualIntervalChange == null) {
            this._actualIntervalChange = new EventEmitter();
            this.i.propertyChanged = delegateCombine(this.i.propertyChanged, (o, e) => {
                let iv = e;
                let ext = this.actualInterval;
                if (this.beforeActualIntervalChange) {
                    this.beforeActualIntervalChange(this, ext);
                }
                this._actualIntervalChange.emit(ext);
            });
        }
        return this._actualIntervalChange;
    }
    get actualMinorIntervalChange() {
        if (this._actualMinorIntervalChange == null) {
            this._actualMinorIntervalChange = new EventEmitter();
            this.i.propertyChanged = delegateCombine(this.i.propertyChanged, (o, e) => {
                let iv = e;
                let ext = this.actualMinorInterval;
                if (this.beforeActualMinorIntervalChange) {
                    this.beforeActualMinorIntervalChange(this, ext);
                }
                this._actualMinorIntervalChange.emit(ext);
            });
        }
        return this._actualMinorIntervalChange;
    }
}
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], IgxNumericAxisBaseComponent.prototype, "minimumValue", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], IgxNumericAxisBaseComponent.prototype, "actualMinimumValue", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], IgxNumericAxisBaseComponent.prototype, "actualVisibleMinimumValue", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], IgxNumericAxisBaseComponent.prototype, "maximumValue", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], IgxNumericAxisBaseComponent.prototype, "actualMaximumValue", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], IgxNumericAxisBaseComponent.prototype, "actualVisibleMaximumValue", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], IgxNumericAxisBaseComponent.prototype, "interval", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], IgxNumericAxisBaseComponent.prototype, "actualInterval", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], IgxNumericAxisBaseComponent.prototype, "minorInterval", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], IgxNumericAxisBaseComponent.prototype, "actualMinorInterval", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], IgxNumericAxisBaseComponent.prototype, "referenceValue", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [Boolean])
], IgxNumericAxisBaseComponent.prototype, "isLogarithmic", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [Boolean])
], IgxNumericAxisBaseComponent.prototype, "actualIsLogarithmic", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], IgxNumericAxisBaseComponent.prototype, "logarithmBase", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [Boolean])
], IgxNumericAxisBaseComponent.prototype, "abbreviateLargeNumbers", null);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter),
    tslib_1.__metadata("design:paramtypes", [])
], IgxNumericAxisBaseComponent.prototype, "actualMinimumValueChange", null);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter),
    tslib_1.__metadata("design:paramtypes", [])
], IgxNumericAxisBaseComponent.prototype, "actualMaximumValueChange", null);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter),
    tslib_1.__metadata("design:paramtypes", [])
], IgxNumericAxisBaseComponent.prototype, "actualIntervalChange", null);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter),
    tslib_1.__metadata("design:paramtypes", [])
], IgxNumericAxisBaseComponent.prototype, "actualMinorIntervalChange", null);
//# sourceMappingURL=igx-numeric-axis-base-component.js.map