import { Type, EventEmitter } from '@angular/core';
import { IgxCategoryAxisBaseComponent } from "./igx-category-axis-base-component";
import { IgxAxisComponent } from "./igx-axis-component";
import { TimeAxisBase } from "./TimeAxisBase";
/**
 * Represents an category-based horizontal X axis that uses a DateTime scale.
*
* Represents horizontal axis that uses a DateTime scale.
*
* ```html
* <igx-data-chart
*     [dataSource]="data">
*     <igx-time-x-axis
* 		dateTimeMemberPath="date"
* 		#xAxis>
*     </igx-time-x-axis>
* </igx-data-chart>
* ```
*
* ```ts
* let xAxis = new IgxTimeXAxisComponent();
* xAxis.dataTimeMemberPath="date";
* this.chart.axes.add(xAxis);
* ```
*/
export declare const IgxTimeAxisBaseComponent_PROVIDERS: {
    provide: typeof IgxAxisComponent;
    useExisting: Type<any>;
}[];
export declare abstract class IgxTimeAxisBaseComponent extends IgxCategoryAxisBaseComponent {
    /**
                                 * @hidden
                                 */
    readonly i: TimeAxisBase;
    constructor();
    /**
     * Gets or sets the DateTime mapping property for the axis.
    *
    * Use `dateTimeMemberPath` property for DateTime mapping with the axis.
    *
    * ```html
    * <igx-data-chart
    *     [dataSource]="data">
    *     <igx-time-x-axis
    * 		dateTimeMemberPath="date"
    * 		#xAxis>
    *     </igx-time-x-axis>
    * </igx-data-chart>
    * ```
    *
    * ```ts
    * let xAxis = new IgxTimeXAxisComponent();
    * xAxis.dataTimeMemberPath="date";
    * this.chart.axes.add(xAxis);
    * ```
    */
    dateTimeMemberPath: string;
    /**
     * Gets or sets whether the data assigned to the date time axis should be considered pre-sorted by date/time.
    *
    * Use `isDataPreSorted` property to decide if the data assigned to the date time axis should be considered pre-sorted by date/time.
    */
    isDataPreSorted: boolean;
    /**
     * Gets the coerced minimum value.
    *
    * Use `actualMinimumValue` to get the coerced maximum value.
    */
    actualMinimumValue: Date;
    /**
     * Gets the coerced maximum value.
    *
    * Use `actualMaximumValue` to get the  coerced maximum value
    */
    actualMaximumValue: Date;
    /**
     * Gets or sets the axis MinimumValue.
    *
    * Use `minimumValue` property for axis minimum value.
    *
    * ```ts
    * this.timeXAxis.maximumValue="2019-12-26";
    * ```
    */
    minimumValue: Date;
    /**
     * Gets or sets the axis MaximumValue.
    *
    * Use `maximumValue` property for axis maximum value.
    *
    * ```ts
    * this.timeXAxis.maximumValue="2019-12-26";
    * ```
    */
    maximumValue: Date;
    /**
     * Checks if the axis is of date time axis type
    *
    * Use `isDateTime` property to Checks if the axis is of date time axis type.
    *
    * ```ts
    * const isDT = this.timeXAxis.isDateTime;
    * ```
    */
    readonly isDateTime: boolean;
    /**
     * Checks if axis requires sorting of items
    *
    * Use `isSorting` property to Checks if axis requires sorting of items.
    *
    * ```ts
    * const isDT = this.timeXAxis.isDateTime;
    * ```
    */
    readonly isSorting: boolean;
    getItemValue(item: any, memberPathName: string): any;
    /**
     * Gets the index of the data item with the value nearest the given value.
    
    * @param unscaledValue  * The value to find a value close to.
    */
    getIndexClosestToUnscaledValue(unscaledValue: number): number;
    /**
     * Updates the axis when the data has been changed.
    
    */
    notifyDataChanged(): void;
    private _actualMinimumValueChange;
    readonly actualMinimumValueChange: EventEmitter<Date>;
    private _actualMaximumValueChange;
    readonly actualMaximumValueChange: EventEmitter<Date>;
}
