import { __decorate, __metadata } from 'tslib';
import { forwardRef, EventEmitter, ContentChildren, QueryList, ViewChild, ViewContainerRef, Input, Output, Component, ChangeDetectionStrategy, Renderer2, NgZone, ComponentFactoryResolver, Injector, NgModule } from '@angular/core';
import { VerticalLinearScaler, HorizontalLinearScaler, Series, SeriesViewer, SeriesView, NumericXAxis, NumericYAxis, ScalerParams, ChartVisualData, SeriesViewerView, ScatterAreaSeries, IgxSeriesViewerComponent, DataChartStylingDefaults, IgxSeriesCollection, IgxNumericXAxisComponent, IgxNumericYAxisComponent, IgxSeriesComponent, ScatterPolygonSeries, CollisionAvoidanceType_$type, MarkerType_$type, StyleSelector, IgxStyleShapeEventArgs, IgxScatterPolygonSeriesDynamicModule, ScatterPolylineSeries, IgxScatterPolylineSeriesDynamicModule, ShapeSeriesBase, ShapeSeriesViewBase, IgxShapeSeriesBaseComponent, BubbleSeries, BrushScale, SizeScale, IgxSizeScaleComponent, IgxBrushScaleComponent, IgxBubbleSeriesDynamicModule, ScatterSeries, IgxScatterSeriesDynamicModule, IgxColorScaleComponent, IgxScatterAreaSeriesDynamicModule, HighDensityScatterSeries, IgxProgressiveLoadStatusEventArgs, IgxHighDensityScatterSeriesDynamicModule, ScatterContourSeries, ValueBrushScale, ContourValueResolver, IgxValueBrushScaleComponent, IgxContourValueResolverComponent, IgxScatterContourSeriesDynamicModule, IgxSizeScaleModule, IgxValueBrushScaleModule, IgxCustomPaletteColorScaleModule, IgxSizeScaleDynamicModule, IgxValueBrushScaleDynamicModule, IgxCustomPaletteColorScaleDynamicModule } from 'igniteui-angular-charts';
import { markEnum, Rect, markType, EventArgs, TypeRegistrar, PlatformConstants, typeCast, delegateRemove, runOn, delegateCombine, isNaN_, DependencyProperty, Number_$type, PropertyMetadata, Point_$type, fromEnum, MathUtil, intDivide, truncate, ItfConverter, RectData, IMapRenderDeferralHandler_$type, markDep, enumGetBox, Control, PropertyChangedEventArgs, INotifyPropertyChanged_$type, Base, XamMultiScaleImage, Size, Brush, OpenStreetMapTileSource, String_$type, IEnumerable_$type, NamePatcher, AngularRenderer, NotifyCollectionChangedAction, CollectionAdapter, AngularWrapper, IgxDataContext, ensureBool, ensureEnum, fromRect, toRect, toPoint, fromPoint, IgCollection, SyncableObservableCollection$2, IgxCancellingMultiScaleImageEventArgs, IgxDownloadingMultiScaleImageEventArgs, ObservableCollection$1, BingMapsTileSource, stringIsNullOrEmpty, Uri, HttpRequestUtil, List$1, stringEmpty, SyncableObservableCollection$1, IgxGetTileImageUriArgs, ArcGISOnlineTileSource, stringFormat1, stringRemove, stringFormat, Boolean_$type, IgxShapeDataSource, Style, DataTemplate, brushToString, stringToBrush, TileGeneratorTileSource, stringReplace, ITileGenerator_$type, GeometryGroup, RenderingContext, CanvasViewRenderer, IgxTriangulationDataSource, IgxTriangulationStatusEventArgs, Color, colorToString, stringToColor, IgxHeatTileGeneratorModule, IgxShapeDataSourceModule, IgxHeatTileGeneratorDynamicModule, IgxShapeDataSourceDynamicModule } from 'igniteui-angular-core';
import { CommonModule } from '@angular/common';

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Indicates the desired behavior for the map on resizing.
 */
var MapResizeBehavior;
(function (MapResizeBehavior) {
    /**
     * Indicates that the map should decide the desired resize mode automatically.
     */
    MapResizeBehavior[MapResizeBehavior["Auto"] = 0] = "Auto";
    /**
     * Map will attempt to keep the top left position static during resize.
     */
    MapResizeBehavior[MapResizeBehavior["MaintainTopLeftPosition"] = 1] = "MaintainTopLeftPosition";
    /**
     * Map will attempt to keep the center position static during resize.
     */
    MapResizeBehavior[MapResizeBehavior["MaintainCenterPosition"] = 2] = "MaintainCenterPosition";
})(MapResizeBehavior || (MapResizeBehavior = {}));
/**
 * @hidden
 */
let MapResizeBehavior_$type = markEnum('MapResizeBehavior', 'Auto,0|MaintainTopLeftPosition,1|MaintainCenterPosition,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class SphericalMercatorVerticalScaler extends VerticalLinearScaler {
    constructor() {
        super();
        this.au = null;
        this.ai = 0;
        this.aj = 0;
        this.au = new Rect(0, 0, 0, 1, 1);
    }
    q(a, b) {
        if (!b.c.isEmpty) {
            let c = a * b.e.height + b.e.top * b.d.height;
            let d = this.getMercatorUnscaledValue(c, this.au, b.c, b.a);
            return d;
        }
        else {
            return this.getMercatorUnscaledValue(a, b.e, b.d, b.a);
        }
    }
    p(a, b) {
        if (!b.c.isEmpty) {
            let c = this.getMercatorScaledValue1(a, this.au, b.c, b.a);
            c = (c - (b.e.top * b.d.height)) / b.e.height;
            return c;
        }
        else {
            return this.getMercatorScaledValue1(a, b.e, b.d, b.a);
        }
    }
    af(values_) {
        let a = (Array.isArray(values_) ? values_ : null);
        return a;
        return null;
    }
    v(a, b, c, d) {
        let e;
        let f = d.e;
        let g = d.d;
        let h = d.c;
        let i = d.a;
        let j = !h.isEmpty;
        let k = this.m;
        let l = this.o;
        let m = h.top;
        let n = h.height;
        let o = f.top;
        let p = f.height;
        let q = g.top;
        let r = g.height;
        let s = this.au.top;
        let t = this.au.height;
        let u = this.af(a);
        let v = 0.017453292519943295;
        let w;
        let x;
        let y;
        let z;
        let aa;
        let ab = false;
        if (u != null) {
            ab = true;
        }
        for (let ac = b; ac < c; ac++) {
            if (ab) {
                e = u[ac];
            }
            else {
                e = a.item(ac);
            }
            if (j) {
                if (e < SphericalMercatorVerticalScaler.ah) {
                    e = SphericalMercatorVerticalScaler.ah;
                }
                if (e > SphericalMercatorVerticalScaler.ag) {
                    e = SphericalMercatorVerticalScaler.ag;
                }
                w = e * (v);
                x = Math.sin(w);
                y = 0.5 * Math.log((1 + x) / (1 - x));
                z = (this.ai - y) * n / this.aj;
                z = m + z;
                aa = (z - s * n) / t;
                z = (aa - (o * r)) / p;
                if (ab) {
                    u[ac] = z;
                }
                else {
                    a.item(ac, z);
                }
            }
            else {
                if (e < SphericalMercatorVerticalScaler.ah) {
                    e = SphericalMercatorVerticalScaler.ah;
                }
                if (e > SphericalMercatorVerticalScaler.ag) {
                    e = SphericalMercatorVerticalScaler.ag;
                }
                w = e * (v);
                x = Math.sin(w);
                y = 0.5 * Math.log((1 + x) / (1 - x));
                z = (this.ai - y) * r / this.aj;
                z = q + z;
                z = (z - o * r) / p;
                if (ab) {
                    u[ac] = z;
                }
                else {
                    a.item(ac, z);
                }
            }
        }
    }
    t(a, b, c, d, e) {
        d = this.ak(a.kj);
        e = this.ak(a.ki);
        return {
            p3: d,
            p4: e
        };
    }
    w(a, b, c) {
        super.w(a, b, c);
        switch (a) {
            case "ActualMinimumValue":
            case "ActualMaximumValue":
                this.ai = SphericalMercatorVerticalScaler.am(this.n);
                this.aj = SphericalMercatorVerticalScaler.am(this.n) - SphericalMercatorVerticalScaler.am(this.o);
                break;
        }
    }
    static get as() {
        return SphericalMercatorVerticalScaler.ag;
    }
    static get at() {
        return SphericalMercatorVerticalScaler.ah;
    }
    getMercatorUnscaledValue(a, b, c, d) {
        let e = (a - c.top) * b.width + b.top * c.height;
        e = SphericalMercatorVerticalScaler.am(this.n) - e / (c.height / this.aj);
        return SphericalMercatorVerticalScaler.aq(e);
    }
    getMercatorScaledValue1(a, b, c, d) {
        let e = c.top + this.getMercatorScaledValue3(a, c.height);
        return (e - b.top * c.height) / b.width;
    }
    getMercatorScaledValue2(a, b, c, d, e) {
        let f = this.getMercatorScaledValue3(a, d.height);
        return (f - b.top * c.height) / b.width;
    }
    getMercatorScaledValue3(a, b) {
        a = a > SphericalMercatorVerticalScaler.ah ? (a < SphericalMercatorVerticalScaler.ag ? a : SphericalMercatorVerticalScaler.ag) : SphericalMercatorVerticalScaler.ah;
        let c = SphericalMercatorVerticalScaler.am(a);
        let d = (this.ai - c) * b / this.aj;
        return (d);
    }
    static am(a) {
        let b = a * (0.017453292519943295);
        let c = Math.sin(b);
        let d = 0.5 * Math.log((1 + c) / (1 - c));
        return d;
    }
    static aq(a) {
        a = Math.exp(2 * a);
        return Math.asin((a - 1) / (a + 1)) / 0.017453292519943295;
    }
    ak(a) {
        if (a < SphericalMercatorVerticalScaler.ah) {
            return SphericalMercatorVerticalScaler.ah;
        }
        if (a > SphericalMercatorVerticalScaler.ag) {
            return SphericalMercatorVerticalScaler.ag;
        }
        return a;
    }
}
SphericalMercatorVerticalScaler.$t = markType(SphericalMercatorVerticalScaler, 'SphericalMercatorVerticalScaler', VerticalLinearScaler.$);
SphericalMercatorVerticalScaler.ag = 85.05112878;
SphericalMercatorVerticalScaler.ah = -85.05112878;

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class SphericalMercatorHorizontalScaler extends HorizontalLinearScaler {
    constructor() {
        super();
        this.aj = null;
        this.aj = new Rect(0, 0, 0, 1, 1);
    }
    q(a, b) {
        if (!b.c.isEmpty) {
            let c = a * b.e.width + b.e.left * b.d.width;
            let d = this.getMercatorUnscaledValue(c, this.aj, b.c, b.a);
            return d;
        }
        else {
            return this.getMercatorUnscaledValue(a, b.e, b.d, b.a);
        }
    }
    p(a, b) {
        if (!b.c.isEmpty) {
            let c = this.getMercatorScaledValue1(a, this.aj, b.c, b.a);
            let d = (c - (b.e.left * b.d.width)) / b.e.width;
            return d;
        }
        else {
            return this.getMercatorScaledValue1(a, b.e, b.d, b.a);
        }
    }
    af(values_) {
        let a = (Array.isArray(values_) ? values_ : null);
        return a;
        return null;
    }
    v(a, b, c, d) {
        let e;
        let f = d.e;
        let g = d.d;
        let h = d.c;
        let i = d.a;
        let j = !h.isEmpty;
        let k = this.m;
        let l = this.o;
        let m = h.left;
        let n = h.width;
        let o = f.left;
        let p = f.width;
        let q = g.left;
        let r = g.width;
        let s = this.aj.left;
        let t = this.aj.width;
        let u = this.af(a);
        let v = false;
        if (u != null) {
            v = true;
        }
        for (let w = b; w < c; w++) {
            if (v) {
                e = u[w];
            }
            else {
                e = a.item(w);
            }
            if (j) {
                let x = (e - l) / (k);
                if (i) {
                    x = 1 - x;
                }
                x = m + n * (x - s) / t;
                let y = (x - (o * r)) / p;
                if (v) {
                    u[w] = y;
                }
                else {
                    a.item(w, y);
                }
            }
            else {
                let z = (e - l) / (k);
                if (i) {
                    z = 1 - z;
                }
                z = q + r * (z - o) / p;
                if (v) {
                    u[w] = z;
                }
                else {
                    a.item(w, z);
                }
            }
        }
    }
    t(a, b, c, d, e) {
        d = a.kj;
        e = a.ki;
        return {
            p3: d,
            p4: e
        };
    }
    getMercatorUnscaledValue(a, b, c, d) {
        let e = b.left + b.width * (a - c.left) / c.width;
        if (d) {
            e = 1 - e;
        }
        return this.o + e * (this.m);
    }
    getMercatorScaledValue1(a, b, c, d) {
        let e = (a - this.o) / (this.m);
        if (d) {
            e = 1 - e;
        }
        return c.left + c.width * (e - b.left) / b.width;
    }
    getMercatorScaledValue2(a, b, c, d, e) {
        let f = (a - this.o) / (this.m);
        if (e) {
            f = 1 - f;
        }
        return c.left + c.width * (f - b.left) / b.width;
    }
}
SphericalMercatorHorizontalScaler.$t = markType(SphericalMercatorHorizontalScaler, 'SphericalMercatorHorizontalScaler', HorizontalLinearScaler.$);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class ImageTilesReadyEventArgs extends EventArgs {
}
ImageTilesReadyEventArgs.$t = markType(ImageTilesReadyEventArgs, 'ImageTilesReadyEventArgs', EventArgs.$);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class ImagesChangedEventArgs extends EventArgs {
}
ImagesChangedEventArgs.$t = markType(ImagesChangedEventArgs, 'ImagesChangedEventArgs', EventArgs.$);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class GeographicMapSeriesHost extends Series {
    constructor() {
        super();
        this.l1 = null;
        this.l3 = this.l2();
    }
    get_ct() {
        return true;
    }
    fs(a, b) {
        let c = this.gv(b);
        if (c == "LatitudeMemberPath") {
            c = "YMemberPath";
        }
        if (c == "LongitudeMemberPath") {
            c = "XMemberPath";
        }
        return this.l3.fs(a, b);
    }
    ch(a, b, c) {
        return this.l3.ch(a, b, c);
    }
    ag() {
        return this.l3.ag();
    }
    a5() {
        return this.l3;
    }
    get l3() {
        return this.l1;
    }
    set l3(a) {
        let b = this.l3 != a;
        if (b) {
            this.l1 = a;
            this.l8();
        }
    }
    l8() {
        if (this.l1 != null) {
            let hostedSeries_ = this.l1;
            hostedSeries_.externalObject = TypeRegistrar.createFromInternal(hostedSeries_, PlatformConstants.Prefix, PlatformConstants.Postfix);
            hostedSeries_.externalObject._implementation = hostedSeries_;
        }
        this.h1(this.l3);
        this.l4.bv();
    }
    fp(a) {
        return this.fu(this.l3, a);
    }
    bf() {
        return new HostSeriesView(this);
    }
    iv(a) {
        super.iv(a);
        this.l4 = typeCast(HostSeriesView.$, a);
    }
    get l5() {
        return this.c(GeographicMapSeriesHost.ma);
    }
    set l5(a) {
        this.h(GeographicMapSeriesHost.ma, a);
    }
    i0(a, b, c, d) {
        super.i0(a, b, c, d);
        switch (b) {
            case "SeriesViewer":
                this.l3.bs = this.bs;
                if (c != null) {
                    c.jy(this.l3);
                }
                if (d != null) {
                    this.bs.hc(this.l3);
                }
                this.l3.i3(this.lz);
                this.l3.fh = this.fh;
                this.h6(this.l3);
                this.fk = this.l3.fk;
                let e = typeCast(SeriesViewer.$, c);
                if (e != null) {
                    e.actualWindowRectChanged = delegateRemove(e.actualWindowRectChanged, runOn(this, this.l9));
                }
                if (this.bs != null) {
                    let f = this.bs;
                    f.actualWindowRectChanged = delegateCombine(f.actualWindowRectChanged, runOn(this, this.l9));
                }
                this.l7();
                break;
            case "SyncLink":
                this.l3.bn = this.bn;
                break;
            case "VisibleFromScale":
                this.l7();
                break;
            case "Index":
                this.l3.fh = this.fh;
                break;
            case "ItemsSource":
                this.l4.bw();
                break;
            case "Resolution":
                this.l4.by();
                break;
            case "TransitionDuration":
                this.l4.bz();
                break;
            case "Opacity":
                this.l4.bx();
                break;
            case "Visibility":
                let hs_ = this.l3;
                let v_ = this._visibility;
                hs_.visibility = v_;
                break;
            case "MouseOverEnabled":
                this.l3.c7 = this.c7;
                break;
            case "ExpectFunctions":
                this.l3.expectFunctions = this.expectFunctions;
                break;
        }
    }
    l7() {
        if (this.bs == null || this.l3 == null) {
            return;
        }
        if (!isNaN_(this.l5)) {
            if (this.bs.mr.width > this.l5) {
                let hs_ = this.l3;
                let v_ = 1;
                hs_.visibility = v_;
            }
            else {
                let hs2_ = this.l3;
                let v2_ = 0;
                hs2_.visibility = v2_;
            }
        }
    }
    l9(a, b) {
        this.l7();
    }
    je(a) {
        super.je(a);
        if (this.l3 != null) {
            this.l3.je(a);
        }
    }
    jd(a, b, c, d, e) {
        if (this.l3 != null) {
            this.l3.jd(a, b, c, d, e);
        }
    }
    ar(a, b) {
        return this.l3.ar(a, b);
    }
    jn() {
        super.jn();
        this.l3.jn();
    }
    get_coercionMethods() {
        return this._coercionMethods;
    }
    set_coercionMethods(a) {
        this._coercionMethods = a;
        this.l3.coercionMethods = a;
    }
    h5(a) {
        super.h5(a);
        if (this.l3 != null) {
            let b = this.l3.fo();
            this.hy(a, b);
        }
    }
}
GeographicMapSeriesHost.$t = markType(GeographicMapSeriesHost, 'GeographicMapSeriesHost', Series.$);
GeographicMapSeriesHost.ma = DependencyProperty.i("VisibleFromScale", Number_$type, GeographicMapSeriesHost.$, new PropertyMetadata(2, 1, (a, b) => {
    let c = a;
    c.raisePropertyChanged("VisibleFromScale", b.oldValue, b.newValue);
}));
/**
 * @hidden
 */
class HostSeriesView extends SeriesView {
    constructor(a) {
        super(a);
        this.bu = null;
        this.bu = a;
    }
    ao(a, b) {
        super.ao(a, b);
    }
    bv() {
        this.bu.l3.itemsSource = this.bu.itemsSource;
        this.bu.l3.fh = this.bu.fh;
        this.bu.l3.k6 = this.bu.k6;
        this.bu.l3.k9 = this.bu.k9;
        this.bu.l3.eu = this.bu.eu;
        this.bu.l3.fi = this.bu.fi;
        this.bu.l3._opacity = this.bu._opacity;
    }
    bw() {
        this.bu.l3.itemsSource = this.bu.itemsSource;
    }
    by() {
        this.bu.l3.eu = this.bu.eu;
    }
    bz() {
        this.bu.l3.fi = this.bu.fi;
    }
    bx() {
        this.bu.l3._opacity = this.bu._opacity;
    }
}
HostSeriesView.$t = markType(HostSeriesView, 'HostSeriesView', SeriesView.$);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class XamGeographicMap extends SeriesViewer {
    constructor() {
        super();
        this.nv = null;
        this.nr = 0;
        this.oy = null;
        this.nf = null;
        this.nb = null;
        this.nd = null;
        this.nh = null;
        this.ou = { $type: Point_$type, x: NaN, y: NaN };
        this.o1 = null;
        this.nq = 1;
        this.imageTilesReady = null;
        this.nl = null;
        this.o0 = Rect.empty;
        this.nr = SphericalMercatorVerticalScaler.am(XamGeographicMap.oz.bottom) - SphericalMercatorVerticalScaler.am(XamGeographicMap.oz.top);
        this.ab = XamGeographicMap.$;
        this.backgroundContent = new OpenStreetMapImagery();
        let a = ((() => {
            let $ret = new NumericXAxis();
            $ret.bh = this;
            return $ret;
        })());
        a.b8 = true;
        this.nc = a;
        this.nc.ln = new SphericalMercatorHorizontalScaler();
        let b = ((() => {
            let $ret = new NumericYAxis();
            $ret.bh = this;
            return $ret;
        })());
        b.b8 = true;
        this.ne = b;
        this.ne.ln = new SphericalMercatorVerticalScaler();
        this.ob();
        this.oi();
        this.hs();
    }
    provideContainer(a) {
        super.provideContainer(a);
        this.nc.provideRenderer(a);
        this.ne.provideRenderer(a);
    }
    hs() {
        super.hs();
        this.nk.fl(this.ea);
    }
    c3() {
        return this.no;
    }
    c4() {
        return this.no;
    }
    get o3() {
        return this.oy;
    }
    set o3(a) {
        let b = Rect.l_op_Inequality(this.oy, a);
        if (b) {
            let c = this.oy;
            this.oy = a;
            this.ji("ActualWorldRect", c, a);
        }
    }
    o7() {
        return this.o3;
    }
    ob() {
        if (this.pf.isEmpty) {
            return;
        }
        this.o3 = this.pd(this.pf, true);
    }
    pd(a, b) {
        let c = a.top;
        let d = a.left;
        let e = a.width;
        let f = a.height;
        let g = SphericalMercatorVerticalScaler.am(a.bottom);
        let h = SphericalMercatorVerticalScaler.am(a.top);
        let i = g - h;
        let j = a.width / XamGeographicMap.oz.width;
        let k = SphericalMercatorVerticalScaler.am(XamGeographicMap.oz.top);
        let l = i / j;
        if (i / j > this.nr) {
            let m = i / this.nr;
            let n = m - j;
            d = d - (n / 2) * XamGeographicMap.oz.width;
            e = m * XamGeographicMap.oz.width;
            if (b) {
                if (d < XamGeographicMap.oz.left) {
                    d += (XamGeographicMap.oz.left - d);
                }
                else if ((d + e) > XamGeographicMap.oz.right) {
                    d -= ((d + e) - XamGeographicMap.oz.right);
                }
            }
        }
        else if (i / j < this.nr) {
            let o = this.nr * j;
            let p = o - i;
            let q = h - (p / 2);
            let r = g + (p / 2);
            if (b) {
                if (q < k) {
                    q += (k - q);
                    r += (k - q);
                }
                else if (r > (k + this.nr)) {
                    q -= ((r) - (k + this.nr));
                    r -= ((r) - (k + this.nr));
                }
            }
            c = SphericalMercatorVerticalScaler.aq(q);
            f = SphericalMercatorVerticalScaler.aq(r) - c;
        }
        let s = new Rect(0, d, c, e, f);
        return s;
    }
    get backgroundContent() {
        return this.nf;
    }
    set backgroundContent(a) {
        let b = a != this.backgroundContent;
        if (b) {
            let c = this.backgroundContent;
            this.nf = a;
            this.ji("BackgroundContent", c, a);
        }
    }
    get nc() {
        return this.nb;
    }
    set nc(a) {
        let b = a != this.nc;
        if (b) {
            let c = this.nc;
            this.nb = a;
            this.ji("XAxis", c, a);
        }
    }
    get ne() {
        return this.nd;
    }
    set ne(a) {
        let b = a != this.ne;
        if (b) {
            let c = this.ne;
            this.nd = a;
            this.ji("YAxis", c, a);
        }
    }
    getZoomRectFromGeoRect(a) {
        return this.getZoomFromGeographicRect(a);
    }
    ol(a) {
        this.m6 = a;
    }
    ok(a) {
        this.pf = a;
    }
    getZoomFromGeographicRect(a) {
        return this.o5(a, true, 0);
    }
    o4(a, b) {
        return this.o5(a, false, b);
    }
    o5(a, b, c) {
        let d = a;
        if (b) {
            d = this.pd(a, false);
        }
        let e = this.nc;
        let f = this.ne;
        let g = new ScalerParams(1, XamGeographicMap.o2, this.m5, e.ca);
        g.c = this.mv;
        let h = new ScalerParams(1, XamGeographicMap.o2, this.m5, f.ca);
        h.c = this.mv;
        let i = this.nc.dy(d.left, g);
        let j = this.nc.dy(d.right, g);
        let k = this.ne.dy(d.top, h);
        let l = this.ne.dy(d.bottom, h);
        let m = (i - c) / this.m5.width;
        let n = (l - c) / this.m5.height;
        let o = (j - i + (c * 2)) / this.m5.width;
        let p = (k - l + (c * 2)) / this.m5.height;
        let q = new Rect(0, m, n, o, p);
        q.intersect(XamGeographicMap.o2);
        if (q.isEmpty) {
            q = XamGeographicMap.o2;
        }
        return q;
    }
    getZoomFromGeographicPoints(a, b) {
        let c = a.x;
        let d = b.y;
        let e = b.x - a.x;
        let f = a.y - b.y;
        if (e < 0 || f < 0) {
            return XamGeographicMap.o2;
        }
        else {
            let g = new Rect(0, c, d, e, f);
            return this.getZoomFromGeographicRect(g);
        }
    }
    o9(a) {
        let b = this.nc;
        let c = this.ne;
        let d = new ScalerParams(1, a, this.m5, b.ca);
        d.c = this.mv;
        let e = new ScalerParams(1, a, this.m5, c.ca);
        e.c = this.mv;
        let f = this.mu;
        let g = b.d1(f.left, d);
        let h = c.d1(f.top, e);
        let i = b.d1(f.right, d);
        let j = c.d1(f.bottom, e);
        let k = i - g;
        let l = h - j;
        let m = new Rect(0, g, j, k, l);
        m.intersect(XamGeographicMap.oz);
        if (m.isEmpty) {
            m = XamGeographicMap.oz;
        }
        return m;
    }
    ov(a) {
        let b = this.nc.km(a.x);
        let c = this.ne.km(a.y);
        return { $type: Point_$type, x: b, y: c };
    }
    ow(a) {
        let b = this.nc.ed(a.x);
        let c = this.ne.ed(a.y);
        return { $type: Point_$type, x: b, y: c };
    }
    ox(a) {
        return this.ow(a);
    }
    n8() {
        let a = typeCast(GeographicMapImagery.$, this.backgroundContent);
        if (a != null) {
            a.clearTileCache();
        }
    }
    oe(a) {
    }
    mb(a) {
        return this.nk.fp(a);
    }
    mc(a) {
        return this.nk.fq(a);
    }
    dh() {
        return true;
    }
    og() {
        this.nk.d7();
        for (let a of fromEnum(this.series)) {
            a.jn();
        }
    }
    oj() {
        if (this.nj == 2) {
            if (!this.m5.isEmpty && this.m5.width > 0 && this.m5.height > 0) {
                let a = this.nc.km(this.m5.left + (this.m5.width / 2));
                let b = this.ne.km(this.m5.top + (this.m5.height / 2));
                this.ou = { $type: Point_$type, x: a, y: b };
            }
        }
        else {
            if (!this.m5.isEmpty && this.m5.width > 0 && this.m5.height > 0) {
                let c = this.nc.km(this.m5.left);
                let d = this.ne.km(this.m5.top);
                this.ou = { $type: Point_$type, x: c, y: d };
            }
        }
    }
    of() {
        if (isNaN_(this.ou.x) || isNaN_(this.ou.y)) {
            this.oj();
        }
        let a = this.ou.x;
        let b = this.ou.y;
        if (!isNaN_(a) && !isNaN_(b)) {
            let c = this.mr.left;
            let d = this.mr.top;
            let e = this.mr.width;
            let f = this.mr.height;
            if (e > this.o1.width) {
            }
            else {
                let g = new ScalerParams(1, XamGeographicMap.o2, this.m5, this.nc.ca);
                g.c = this.mv;
                let h = this.nc.dy(a, g);
                if (this.nj == 2) {
                    let i = h / this.m5.width;
                    c = i - (e / 2);
                }
                else {
                    c = h / this.m5.width;
                }
                if (c + e > this.o1.right) {
                    c = this.o1.right - e;
                }
                else if (c < this.o1.left) {
                    c = this.o1.left;
                }
            }
            if (f > this.o1.height) {
            }
            else {
                let j = new ScalerParams(1, XamGeographicMap.o2, this.m5, this.ne.ca);
                j.c = this.mv;
                let k = this.ne.dy(b, j);
                if (this.nj == 2) {
                    let l = k / this.m5.height;
                    d = l - (f / 2);
                }
                else {
                    d = k / this.m5.height;
                }
                if (d + f > this.o1.bottom) {
                    d = this.o1.bottom - f;
                }
                else if (d < this.o1.top) {
                    d = this.o1.top;
                }
            }
            this.km(new Rect(0, c, d, e, f), false);
        }
    }
    get_cx() {
        return true;
    }
    ms() {
        let a = super.ms();
        if (this.nc == null || this.ne == null) {
            return a;
        }
        let b = new ScalerParams(1, XamGeographicMap.o2, this.m5, this.nc.ca);
        b.c = this.mv;
        let c = new ScalerParams(1, XamGeographicMap.o2, this.m5, this.ne.ca);
        c.c = this.mv;
        let d = this.nc.dy(XamGeographicMap.oz.left, b);
        let e = this.nc.dy(XamGeographicMap.oz.right, b);
        let f = this.ne.dy(XamGeographicMap.oz.top, c);
        let g = this.ne.dy(XamGeographicMap.oz.bottom, c);
        this.o1 = new Rect(0, d / this.m5.width, g / this.m5.height, (e - d) / this.m5.width, (f - g) / this.m5.height);
        let h = a.left;
        let i = a.top;
        if (this.m6.width > this.o1.width) {
            h = 0.5 - (this.m6.width / 2);
        }
        else if (h + a.width > this.o1.right) {
            h = this.o1.right - this.m6.width;
        }
        else if (h < this.o1.left) {
            h = this.o1.left;
        }
        if (this.m6.height > this.o1.height) {
            i = 0.5 - (this.m6.height / 2);
        }
        else if (i + this.m6.height > this.o1.bottom) {
            i = this.o1.bottom - this.m6.height;
        }
        else if (i < this.o1.top) {
            i = this.o1.top;
        }
        let j = new Rect(0, h, i, a.width, a.height);
        if (this.nn) {
            let k = this.o4(this.pf, 1);
            k = this.o6(k);
            let l = j.left + j.width / 2;
            let m = j.top + j.height / 2;
            if (j.width > k.width) {
                let n = j.height / j.width;
                let o = k.width;
                let p = n * o;
                j = new Rect(0, l - o / 2, m - p / 2, o, p);
            }
            if (j.height > k.height) {
                let q = j.width / j.height;
                let r = k.height;
                let s = q * r;
                j = new Rect(0, l - s / 2, m - r / 2, s, r);
            }
            if (j.left < k.left) {
                j = new Rect(0, k.left, j.top, j.width, j.height);
            }
            if (j.top < k.top) {
                j = new Rect(0, j.left, k.top, j.width, j.height);
            }
            if (j.right > k.right) {
                j = new Rect(0, k.right - j.width, j.top, j.width, j.height);
            }
            if (j.bottom > k.bottom) {
                j = new Rect(0, j.left, k.bottom - j.height, j.width, j.height);
            }
        }
        return j;
    }
    o6(a) {
        let b = this.ex;
        let c = 0.5 * (a.left + a.right);
        let d = 0.5 * (a.top + a.bottom);
        let e = a.width;
        let f = a.height;
        let g = MathUtil.b(a.width, b, 1);
        let h = MathUtil.b(a.height, b, 1);
        let i = this.m5;
        let j = i.width / i.height;
        let k = g * i.width;
        let l = h * i.height;
        let m = k / l;
        if (m != j) {
            if (l * j > k) {
                k = l * j;
                g = k / i.width;
            }
            else {
                l = k / j;
                h = l / i.height;
            }
        }
        let n = g != e;
        let o = h != f;
        let p = n ? c - 0.5 * g : a.left;
        let q = o ? d - 0.5 * h : a.top;
        let r = n ? c + 0.5 * g : a.right;
        let s = o ? d + 0.5 * h : a.bottom;
        if (p < 0) {
            p = 0;
            r = p + g;
        }
        if (r > 1) {
            r = 1;
            p = r - g;
        }
        if (q < 0) {
            q = 0;
            s = q + h;
        }
        if (s > 1) {
            s = 1;
            q = s - h;
        }
        return new Rect(0, p, q, r - p, s - q);
    }
    mt(a) {
        super.mt(this.m5);
        if (a.isEmpty) {
            return Rect.empty;
        }
        let b;
        if (a.width > a.height) {
            let c = intDivide(truncate((a.width - a.height)), 2);
            b = new Rect(0, a.left + c, a.top, a.height, a.height);
        }
        else {
            let d = intDivide(truncate((a.height - a.width)), 2);
            b = new Rect(0, a.left, a.top + d, a.width, a.width);
        }
        return b;
    }
    o8(a) {
        return this.mt(a);
    }
    bm() {
        return new XamGeographicMapView(this);
    }
    l7(a) {
        return this.nk.fo(a);
    }
    md(a) {
        return this.nk.fr(a);
    }
    oa(a) {
        if (a != null) {
            a.bh = this;
        }
    }
    i2(a) {
        super.i2(a);
        this.nk = a;
    }
    jd(a, b) {
        super.jd(a, b);
        this.kb(this.nc);
        this.kb(this.ne);
        if (Rect.l_op_Inequality(a, b)) {
            this.of();
        }
        if (this.nn) {
            this.mr = this.ms();
        }
        this.om();
    }
    get ns() {
        return this.nq;
    }
    set ns(a) {
        let b = this.nq;
        this.nq = a;
        this.ji("ActualWindowScale", b, this.nq);
    }
    eg() {
        return this.ns;
    }
    eh() {
        return this.ns;
    }
    ka() {
        super.ka();
        let a = Math.min(this.mr.width, this.mr.height);
        this.ns = a;
    }
    je(a, b, c, d) {
        super.je(a, b, c, d);
        switch (b) {
            case "WindowRect":
                this.oj();
                break;
            case XamGeographicMap.$$p[2]:
                this.mr = this.ms();
                break;
            case "BackgroundContent":
                if (this.nh != null) {
                    let e = this.nh;
                    e.imageTilesReady = delegateRemove(e.imageTilesReady, runOn(this, this.oc));
                    this.nh.deferralHandler = null;
                }
                this.nh = typeCast(GeographicMapImagery.$, this.backgroundContent);
                if (this.nh != null) {
                    let f = this.nh;
                    f.imageTilesReady = delegateCombine(f.imageTilesReady, runOn(this, this.oc));
                    this.nh.deferralHandler = this;
                }
                this.nk.fk(typeCast(GeographicMapImagery.$, c), typeCast(GeographicMapImagery.$, d));
                if (this.nh != null) {
                    this.nh.geographicMap = this;
                    this.nk.fh(this.mr);
                    this.nk.fl(this.ea);
                }
                break;
            case "YAxis":
            case "XAxis":
                this.oh(c);
                this.oa(d);
                break;
            case XamGeographicMap.$$p[4]:
                if (!this.nm) {
                    this.m6 = XamGeographicMap.o2;
                }
                this.ob();
                this.oi();
                this.oj();
                this.mr = this.ms();
                this.nk.fi();
                break;
            case "ActualWindowRect":
                this.nk.fh(this.mr);
                break;
            case "ActualWorldRect":
                for (let g of fromEnum(this.series)) {
                    g.je(false);
                }
                break;
            case XamGeographicMap.$$p[3]:
                this.ns = this.nt;
                break;
            case "ActualWindowScale":
                if (!this.dg) {
                    this.kl(this.eg(), this.eh());
                }
                break;
            case "ActualPixelScalingRatio":
                this.nk.fl(this.ea);
                break;
            case XamGeographicMap.$$p[5]:
                this.kh();
                break;
        }
    }
    oc(a, b) {
        if (this.imageTilesReady != null) {
            this.imageTilesReady(this, new ImageTilesReadyEventArgs());
        }
    }
    oh(a) {
        if (a != null) {
            a.bh = null;
        }
    }
    oi() {
        if (this.nc != null) {
            this.nc.kj = this.o3.left;
            this.nc.ki = this.o3.right;
        }
        if (this.ne != null) {
            this.ne.kj = this.o3.top;
            this.ne.ki = this.o3.bottom;
        }
        this.nc.co(true);
        this.ne.co(true);
    }
    getFontInfo() {
        this.nl = this.nk.fe;
        return this.nl;
    }
    l6() {
        return this.nk.fm;
    }
    getFontBrush() {
        return this.nk.fn;
    }
    j5(a, b) {
        if (typeCast(ItfConverter.$, b) !== null) {
            let c = b;
            let d = a;
            d.itemsSource = c.triangulationSource.points;
            d.mc = c.triangulationSource.triangles;
        }
        else {
            super.j5(a, b);
        }
    }
    register(a, b) {
        this.jv(a, b);
    }
    unRegister(a) {
        this.j9(a);
    }
    deferredRefresh() {
        this.hh();
    }
    deferAction(a) {
        if (this.nv != null) {
            this.nv.setTimeout(a, 0);
        }
        else {
            window.setTimeout(a, 0);
        }
    }
    n9(a) {
        this.kg(a);
    }
    nw() {
        let a = new ChartVisualData();
        let b = this.nc.e5();
        let c = this.ne.e5();
        a.axes.add1(b);
        a.axes.add1(c);
        for (let d = 0; d < this.series.count; d++) {
            let e = this.series._inner[d].fo();
            a.series.add1(e);
        }
        a.name = this.name;
        a.contentArea = RectData.b(this.m5);
        a.centralArea = RectData.b(this.m5);
        a.plotArea = RectData.b(this.m5);
        return a;
    }
    my(a, b, c) {
        return a;
    }
    od() {
    }
    get pe() {
        return this.o0;
    }
    set pe(a) {
        this.o0 = a;
    }
    on(a) {
        this.pe = a;
        this.om();
    }
    om() {
        if (this.np && !this.pe.isEmpty) {
            let a = this.getZoomFromGeographicRect(this.pe);
            this.pe = Rect.empty;
            this.km(a, false);
        }
    }
    get np() {
        return !this.m5.isEmpty && !this.mv.isEmpty;
    }
}
XamGeographicMap.$t = markType(XamGeographicMap, 'XamGeographicMap', SeriesViewer.$, [IMapRenderDeferralHandler_$type]);
XamGeographicMap.ni = 0;
XamGeographicMap.oz = new Rect(2, { $type: Point_$type, x: -180, y: -85.05112878 }, { $type: Point_$type, x: 180, y: 85.05112878 });
XamGeographicMap.o2 = new Rect(0, 0, 0, 1, 1);
XamGeographicMap.$$p = markDep(DependencyProperty, PropertyMetadata, XamGeographicMap, 'ji', ['ResizeBehavior:nj:oo', [MapResizeBehavior_$type, enumGetBox(MapResizeBehavior_$type, XamGeographicMap.ni)], 'SuppressZoomResetOnWorldRectChange:nm:op', [0, false], 'UseWorldRectForZoomBounds:nn:oq', [0, false], 'WindowScale:nt:or', [1, NaN], 'WorldRect:pf:os', [Rect.$, XamGeographicMap.oz], 'Zoomable:no:ot', [0, true]]);
/**
 * @hidden
 */
class GeographicMapImagery extends Control {
    constructor(a) {
        super();
        this.ak = null;
        this.imageTilesReady = null;
        this.an = null;
        this.ap = null;
        this.propertyChanged = null;
        this.imagesChanged = null;
        this.cancellingImage = null;
        this.downloadingImage = null;
        this.ab = GeographicMapImagery.$;
        this.ap = a;
        this.aj = this.ai();
        this.a9(this.aj);
    }
    a9(a) {
    }
    ai() {
        return new GeographicMapImageryView(this);
    }
    get deferralHandler() {
        return this.ak;
    }
    set deferralHandler(a) {
        this.ak = a;
        if (this.ao != null) {
            this.ao.al = a;
        }
    }
    a3(a, b) {
        if (this.imageTilesReady != null) {
            this.imageTilesReady(this, new ImageTilesReadyEventArgs());
        }
    }
    a7() {
        let a = this.ao;
        a.imageTilesReady = delegateCombine(a.imageTilesReady, runOn(this, this.a3));
        this.ao.al = this.deferralHandler;
        let b = this.ao;
        b.imagesChanged = delegateCombine(b.imagesChanged, runOn(this, this.a2));
        let c = this.ao;
        c.downloadingImage = delegateCombine(c.downloadingImage, runOn(this, this.a1));
        let d = this.ao;
        d.cancellingImage = delegateCombine(d.cancellingImage, runOn(this, this.a0));
        this.ao.bc = this.referer;
        this.ao.bg = this.userAgent;
    }
    a1(a, b) {
        if (this.downloadingImage != null) {
            this.downloadingImage(this, b);
        }
    }
    a0(a, b) {
        if (this.cancellingImage != null) {
            this.cancellingImage(this, b);
        }
    }
    be() {
        if (this.ao != null) {
            this.aj.e();
        }
    }
    a8(a, b, c) {
        switch (a) {
            case GeographicMapImagery.$$p[2]:
                this.be();
                break;
            case "GeographicMap":
                this.aj.e();
                break;
            case GeographicMapImagery.$$p[0]:
                if (this.ao != null) {
                    this.ao.bc = this.referer;
                }
                break;
            case GeographicMapImagery.$$p[1]:
                if (this.ao != null) {
                    this.ao.bg = this.userAgent;
                }
                break;
        }
        if (this.propertyChanged != null) {
            this.propertyChanged(this, new PropertyChangedEventArgs(a));
        }
    }
    get geographicMap() {
        return this.c(GeographicMapImagery.geographicMapProperty);
    }
    set geographicMap(a) {
        this.h(GeographicMapImagery.geographicMapProperty, a);
    }
    static a6(a, b) {
        a.a5(b.oldValue, b.newValue);
    }
    a5(a, b) {
        this.a8("GeographicMap", a, b);
    }
    clearTileCache() {
        if (this.ao != null) {
            this.ao.bp(0, 0, 0, 0);
        }
    }
    get ao() {
        return this.an;
    }
    set ao(a) {
        this.an = a;
        if (this.propertyChanged != null) {
            this.propertyChanged(this, new PropertyChangedEventArgs("MultiScaleImage"));
        }
    }
    bk(a) {
        if (this.geographicMap == null || a.width < 1 || a.height < 1) {
            return a;
        }
        let b = new Rect(0, 0, 0, a.width, a.height);
        let c = this.geographicMap.o8(b);
        let d = XamGeographicMap.oz;
        let e = this.geographicMap.o3;
        let f = Math.min(this.windowRect.height, this.windowRect.width);
        let g = e.width / d.width;
        this.ao.a3 = (b.width / c.width) * f * g;
        let h = this.geographicMap.nc;
        let i = this.geographicMap.ne;
        let j = new ScalerParams(1, this.windowRect, b, h.ca);
        j.c = c;
        let k = new ScalerParams(1, this.windowRect, b, i.ca);
        k.c = c;
        let l = h.dy(d.left, j);
        let m = i.dy(d.bottom, k);
        let n = (-l / b.width) * this.ao.a3;
        let o = (-m / b.height) * this.ao.a3 * (b.height / b.width);
        this.ao.ci = { $type: Point_$type, x: n, y: o };
        return a;
    }
    bb(a) {
        this.aj.f(a);
    }
    bd(a) {
        this.aj.h(a);
    }
    bc(a) {
        this.aj.g(a);
    }
    a2(a, b) {
        if (this.imagesChanged != null) {
            this.imagesChanged(this, new ImagesChangedEventArgs());
        }
    }
    a4() {
        this.aj.e();
    }
    ba(a) {
        this.aj.i(a);
    }
    v() {
        super.v();
        this.ap.m = this._opacity;
    }
}
GeographicMapImagery.$t = markType(GeographicMapImagery, 'GeographicMapImagery', Control.$, [INotifyPropertyChanged_$type]);
GeographicMapImagery.geographicMapProperty = DependencyProperty.i("GeographicMap", XamGeographicMap.$, GeographicMapImagery.$, new PropertyMetadata(2, null, GeographicMapImagery.a6));
GeographicMapImagery.$$p = markDep(DependencyProperty, PropertyMetadata, GeographicMapImagery, 'a8', ['Referer', [2, null], 'UserAgent', [2, null], 'WindowRect', [Rect.$, Rect.empty]]);
/**
 * @hidden
 */
class GeographicMapImageryView extends Base {
    constructor(a) {
        super();
        this.a = null;
        this.j = null;
        this.d = null;
        this.b = 1;
        this.j = Rect.empty;
        this.a = a;
        this.a.ao = new XamMultiScaleImage();
        this.a.ao.ao = this.a.ap;
        this.a.a7();
    }
    e() {
        if (this.j.isEmpty) {
            return;
        }
        this.a.bk(new Size(1, this.j.width, this.j.height));
    }
    f(a) {
        this.a.ao.by(a);
    }
    g(a) {
        this.d = a;
        this.a.ao.bz(a);
    }
    h(a) {
        this.j = a;
        this.a.ao.b0(a);
        this.a.a4();
    }
    get c() {
        return this.b;
    }
    i(a) {
        this.b = a;
        this.a.ao.bw(a);
    }
}
GeographicMapImageryView.$t = markType(GeographicMapImageryView, 'GeographicMapImageryView');
/**
 * @hidden
 */
class GeographicXYTriangulatingSeriesView extends HostSeriesView {
    constructor(a) {
        super(a);
        this.b0 = null;
        this.b0 = a;
    }
    bv() {
        super.bv();
        let a = this.b0.l3;
        a.mz = this.b0.mf;
        a.m3 = this.b0.md;
        a.trianglesSource = this.b0.mc;
        a.mr = this.b0.mi;
        a.mt = this.b0.mk;
        a.mv = this.b0.mm;
    }
    b3() {
        let a = this.b0.l3;
        if (this.b0.bs == null) {
            a.l1 = null;
            a.l2 = null;
            return;
        }
        a.l1 = this.b0.bs.nc;
        a.l2 = this.b0.bs.ne;
    }
    b2() {
        this.b0.l3.mz = this.b0.mf;
    }
    b1() {
        this.b0.l3.m3 = this.b0.md;
    }
    b4() {
        this.b0.l3.trianglesSource = this.b0.mc;
    }
    b5() {
        this.b0.l3.mr = this.b0.mi;
    }
    b6() {
        this.b0.l3.mt = this.b0.mk;
    }
    b7() {
        this.b0.l3.mv = this.b0.mm;
    }
}
GeographicXYTriangulatingSeriesView.$t = markType(GeographicXYTriangulatingSeriesView, 'GeographicXYTriangulatingSeriesView', HostSeriesView.$);
/**
 * @hidden
 */
class GeographicScatterAreaSeriesView extends GeographicXYTriangulatingSeriesView {
    constructor(a) {
        super(a);
        this.b8 = null;
        this.b8 = a;
    }
    bv() {
        super.bv();
        if (this.b8.mw != null) {
            this.b8.mw.nu = this.b8.mz;
            this.b8.mw.nm = this.b8.mv;
        }
    }
    b9() {
        if (this.b8.mw != null) {
            this.b8.mw.nu = this.b8.mz;
        }
    }
    ca() {
        if (this.b8.mw != null) {
            this.b8.mw.nm = this.b8.mv;
        }
    }
}
GeographicScatterAreaSeriesView.$t = markType(GeographicScatterAreaSeriesView, 'GeographicScatterAreaSeriesView', GeographicXYTriangulatingSeriesView.$);
/**
 * @hidden
 */
class XamGeographicMapView extends SeriesViewerView {
    constructor(a) {
        super(a);
        this.fd = null;
        this.ft = null;
        this.fn = null;
        this.fm = null;
        this.fe = null;
        this.ff = NaN;
        this.ft = Rect.empty;
        this.fd = a;
        this.fd.l1 = 2;
        this.fd.ex = 5E-06;
    }
    k(a) {
        return 2;
    }
    bi(a) {
        this.i.bv(a);
        this.fd.n9(a);
        this.ee();
    }
    get_an() {
        return true;
    }
    dx() {
        let a;
        let b;
        let c;
        let d;
        let e;
        let f = this.i.a7(a, b, c, d, e);
        a = f.p0;
        b = f.p1;
        c = f.p2;
        d = f.p3;
        e = f.p4;
        this.fn = c;
        this.fe = d;
        this.fm = e;
    }
    fp(a) {
        return ((() => {
            let $ret = new Brush();
            $ret.fill = "rgba(0,0,0,1)";
            return $ret;
        })());
    }
    fq(a) {
        return ((() => {
            let $ret = new Brush();
            $ret.fill = "white";
            return $ret;
        })());
    }
    fo(a) {
        return ((() => {
            let $ret = new Brush();
            $ret.fill = "rgba(50,50,50,.5)";
            return $ret;
        })());
    }
    fr(a) {
        return ((() => {
            let $ret = new Brush();
            $ret.fill = "white";
            return $ret;
        })());
    }
    dm(a) {
        super.dm(a);
        if (this.fd.backgroundContent != null) {
            let b = this.fd.backgroundContent;
            b.bc(this.i.ae);
            b.bb(a);
        }
    }
    dn(a) {
        super.dn(a);
        this.ft = a;
        if (this.fd.backgroundContent != null) {
            let b = this.fd.backgroundContent;
            b.bd(this.ft);
        }
    }
    fs() {
        return new Rect(0, 0, 0, this.ft.width, this.ft.height);
    }
    fi() {
        if (this.fd.backgroundContent != null) {
            let a = this.fd.backgroundContent;
            a.a4();
        }
    }
    fh(a) {
        if (this.fd.nh != null) {
            this.fd.nh.windowRect = a;
        }
    }
    fk(a, b) {
        if (this.fd.nh != null) {
            this.fd.nh.windowRect = this.fd.mr;
        }
        if (a != null) {
            let c = a.ao;
            if (c != null) {
                this.fd.ah.e.remove(c.ag);
            }
            a.bb(null);
            a.bc(null);
        }
        if (b != null) {
            let d = b.ao;
            if (d != null) {
                this.fd.ah.e.add(d.ag);
            }
            if (!this.ft.isEmpty) {
                this.dn(this.ft);
            }
            if (this.u != null) {
                this.dm(this.u);
            }
        }
        if (b == null) {
            this.fj(this.u);
        }
    }
    fj(a) {
        let b = this.fd.ea;
        if (b != 1) {
            a.z();
            a.aa(b, b);
        }
        a.k(this.ft.left, this.ft.top, this.ft.width, this.ft.height);
        if (b != 1) {
            a.y();
        }
    }
    du() {
        this.e5.ac = 1;
        this.e6.ac = 1;
        this.e5._stroke = this.fn;
        this.e6._stroke = this.fn;
        super.du();
    }
    fl(a) {
        this.ff = a;
        if (this.fd.backgroundContent != null) {
            this.fd.backgroundContent.ba(a);
        }
    }
    get fg() {
        return this.ff;
    }
    set fg(a) {
        this.ff = a;
    }
}
XamGeographicMapView.$t = markType(XamGeographicMapView, 'XamGeographicMapView', SeriesViewerView.$);
/**
 * @hidden
 */
class OpenStreetMapImagery extends GeographicMapImagery {
    constructor() {
        super(new OpenStreetMapTileSource());
    }
    get tilePath() {
        return this.c(OpenStreetMapImagery.tilePathProperty);
    }
    set tilePath(a) {
        this.h(OpenStreetMapImagery.tilePathProperty, a);
    }
    static bo(a, b) {
        a.bn("TilePath", b.oldValue, b.newValue);
    }
    bn(a, b, c) {
        switch (a) {
            case "TilePath":
                this.ap.setTilePathUrl(c == null ? null : c);
                this.aj.e();
                break;
        }
        super.a8(a, b, c);
    }
}
OpenStreetMapImagery.$t = markType(OpenStreetMapImagery, 'OpenStreetMapImagery', GeographicMapImagery.$);
OpenStreetMapImagery.tilePathProperty = DependencyProperty.i("TilePath", String_$type, OpenStreetMapImagery.$, new PropertyMetadata(2, null, OpenStreetMapImagery.bo));
/**
 * @hidden
 */
class GeographicXYTriangulatingSeries extends GeographicMapSeriesHost {
    bf() {
        return new GeographicXYTriangulatingSeriesView(this);
    }
    iv(a) {
        super.iv(a);
        this.mb = a;
    }
    i0(a, b, c, d) {
        super.i0(a, b, c, d);
        switch (b) {
            case "SeriesViewer":
                this.mb.b3();
                break;
            case GeographicXYTriangulatingSeries.$$p[1]:
                this.mb.b2();
                break;
            case GeographicXYTriangulatingSeries.$$p[0]:
                this.mb.b1();
                break;
            case GeographicXYTriangulatingSeries.$$p[2]:
                this.mb.b4();
                break;
            case GeographicXYTriangulatingSeries.$$p[3]:
                this.mb.b5();
                break;
            case GeographicXYTriangulatingSeries.$$p[4]:
                this.mb.b6();
                break;
            case GeographicXYTriangulatingSeries.$$p[5]:
                this.mb.b7();
                break;
        }
    }
}
GeographicXYTriangulatingSeries.$t = markType(GeographicXYTriangulatingSeries, 'GeographicXYTriangulatingSeries', GeographicMapSeriesHost.$);
GeographicXYTriangulatingSeries.$$p = markDep(DependencyProperty, PropertyMetadata, GeographicXYTriangulatingSeries, 'raisePropertyChanged', ['LatitudeMemberPath:md:mo', [2, "pointY"], 'LongitudeMemberPath:mf:mp', [2, "pointX"], 'TrianglesSource:mc:mq', [IEnumerable_$type, null], 'TriangleVertexMemberPath1:mi:mr', [2, "v1"], 'TriangleVertexMemberPath2:mk:ms', [2, "v2"], 'TriangleVertexMemberPath3:mm:mt', [2, "v3"]]);
/**
 * @hidden
 */
class GeographicScatterAreaSeries extends GeographicXYTriangulatingSeries {
    constructor() {
        super();
        this.mu = null;
        this.triangulationStatusChanged = null;
        this.ab = GeographicScatterAreaSeries.$;
    }
    get mv() {
        return this.mu;
    }
    set mv(a) {
        let b = this.mu != a;
        if (b) {
            let c = this.mu;
            this.mu = a;
            this.raisePropertyChanged("ColorScale", c, this.mu);
            if (this.mw != null) {
                this.mw.nm = a;
            }
        }
    }
    l2() {
        this.mw = new ScatterAreaSeries();
        let a = this.mw;
        a.triangulationStatusChanged = delegateCombine(a.triangulationStatusChanged, runOn(this, this.m2));
        return this.mw;
    }
    m2(a, b) {
        if (this.triangulationStatusChanged != null) {
            this.triangulationStatusChanged(this, b);
        }
    }
    bf() {
        return new GeographicScatterAreaSeriesView(this);
    }
    iv(a) {
        super.iv(a);
        this.my = a;
    }
    i0(a, b, c, d) {
        super.i0(a, b, c, d);
        switch (b) {
            case GeographicScatterAreaSeries.$$p[0]:
                this.my.b9();
                break;
            case "ColorScale":
                this.my.ca();
                break;
        }
    }
    get_dq() {
        return true;
    }
    set_dq(a) {
        super.set_dq(a);
    }
}
GeographicScatterAreaSeries.$t = markType(GeographicScatterAreaSeries, 'GeographicScatterAreaSeries', GeographicXYTriangulatingSeries.$);
GeographicScatterAreaSeries.$$p = markDep(DependencyProperty, PropertyMetadata, GeographicScatterAreaSeries, 'raisePropertyChanged', ['ColorMemberPath:mz:m3', [2, "value"]]);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

class IgxImageTilesReadyEventArgs {
    createImplementation() {
        return new ImageTilesReadyEventArgs();
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var IgxGeographicMapComponent_1;
const IgxGeographicMapComponent_PROVIDERS = [{ provide: IgxSeriesViewerComponent, useExisting: forwardRef(() => IgxGeographicMapComponent) }];
/**
 * Represents the Infragistics IgxGeographicMapComponent control.
*/
let IgxGeographicMapComponent = IgxGeographicMapComponent_1 = class IgxGeographicMapComponent extends IgxSeriesViewerComponent {
    constructor(_renderer, _elRef, _ngZone, _componentFactoryResolver, _injector) {
        super();
        this._renderer = _renderer;
        this._elRef = _elRef;
        this._ngZone = _ngZone;
        this._componentFactoryResolver = _componentFactoryResolver;
        this._injector = _injector;
        /**
         * The series actually present in the chart. Do not directly modify this array.
         * This array's contents can be modified by causing Angular to reproject the child content.
         * Or adding and removing series from the manual series collection on the series property.
         */
        this.actualSeries = [];
        this._series = null;
        this._dataSource = null;
        this._seriesAdapter = null;
        this._defaultTooltips = null;
        this._imageTilesReady = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._zoneRunner = (act) => this._ngZone.run(act);
        this._container = _renderer.createElement("div");
        _renderer.appendChild(_elRef.element.nativeElement, this._container);
        _renderer.setStyle(this._container, "display", "block");
        _renderer.setStyle(this._container, "width", "100%");
        _renderer.setStyle(this._container, "height", "100%");
        var root;
        root = this._container;
        if (this._container.nativeElement != null) {
            root = this._container.nativeElement;
        }
        var ren = new AngularRenderer(root, this._renderer, window.document, this._ngZone, true, DataChartStylingDefaults);
        this._wrapper = ren;
        var chart = this.i;
        this._chart = chart;
        chart.provideContainer(ren);
        ren.addSizeWatcher(() => {
            this._chart.notifyContainerResized();
        });
    }
    set height(value) {
        this._height = value;
        this._renderer.setStyle(this._elRef.element.nativeElement, "height", value);
        this._chart.notifyContainerResized();
    }
    get height() {
        return this._height;
    }
    set width(value) {
        this._width = value;
        this._renderer.setStyle(this._elRef.element.nativeElement, "width", value);
        this._chart.notifyContainerResized();
    }
    get width() {
        return this._width;
    }
    /**
     * Gets or sets the legend used for the current chart.
    */
    get legend() {
        if (this.i.legend != null)
            return this.i.legend.externalObject;
    }
    set legend(v) {
        if (v != undefined && v != null)
            this.i.legend = v.i;
    }
    /**
     * A collection or manually added series for the chart.
    */
    get series() {
        if (this._series === null) {
            let coll = new IgxSeriesCollection();
            let inner = coll._innerColl;
            inner.addListener((sender, e) => {
                switch (e.action) {
                    case NotifyCollectionChangedAction.Add:
                        this._seriesAdapter.addManualItem(e.newItems.item(0));
                        break;
                    case NotifyCollectionChangedAction.Remove:
                        this._seriesAdapter.removeManualItemAt(e.oldStartingIndex);
                        break;
                    case NotifyCollectionChangedAction.Replace:
                        this._seriesAdapter.removeManualItemAt(e.oldStartingIndex);
                        this._seriesAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                        break;
                    case NotifyCollectionChangedAction.Reset:
                        this._seriesAdapter.clearManualItems();
                        break;
                }
            });
            this._series = coll;
        }
        return this._series;
    }
    ngOnDestroy() {
        this._chart.destroy();
        this._wrapper.destroy();
    }
    createImplementation() {
        return new XamGeographicMap();
    }
    set dataSource(value) {
        this._dataSource = value;
        this.bindData();
    }
    get dataSource() {
        return this._dataSource;
    }
    bindData() {
        if (this.actualSeries && this.actualSeries.length > 0) {
            var currSeries = this.actualSeries;
            for (var i = 0; i < currSeries.length; i++) {
                currSeries[i].provideData(this._dataSource);
            }
        }
    }
    ngAfterContentInit() {
        if (TypeRegistrar.isRegistered("IgxDataChartDefaultTooltipsComponent")) {
            let c = TypeRegistrar.get("IgxDataChartDefaultTooltipsComponent");
            let cf = this._componentFactoryResolver.resolveComponentFactory(c);
            let cr = this._dynamicContent.createComponent(cf);
            //let cr = cf.create(this._injector);
            this._defaultTooltips = cr;
            cr.instance.onContentReady.subscribe(() => {
                this._onDefaultTooltipsReady(cr);
            });
            //this._container.appendChild(cr.location.nativeElement);
        }
        this._seriesAdapter = new CollectionAdapter(this.contentSeries, this.i.series, this.actualSeries, (c) => c.i, (i) => {
            i.owner = this;
            i._provideRenderer(this._dataSource);
            i.provideData(this._dataSource);
            //i.bindAxes(this.axes);
            this._ensureDefaultTooltip(i);
            this._ensureTooltipCreated(i);
        }, (i) => { i._provideRenderer(null); i.provideData(null); });
        this.i.notifyContainerResized();
    }
    _ensureTooltipCreated(series) {
        series._ensureTooltipCreated(() => this.createTooltip(), (ele) => {
            let wrapper = new AngularWrapper(ele, this._renderer, this._ngZone);
            wrapper.updateToolTip = ele.updateToolTip;
            wrapper.hideToolTip = ele.hideToolTip;
            return wrapper;
        });
    }
    _ensureDefaultTooltip(series) {
        if (this._defaultTooltips == null) {
            return;
        }
        this._defaultTooltips.instance["ensureDefaultTooltip"](series);
    }
    _onDefaultTooltipsReady(cr) {
        if (this.actualSeries && this.actualSeries.length > 0) {
            var currSeries = this.actualSeries;
            for (var i = 0; i < currSeries.length; i++) {
                if (currSeries[i].showDefaultTooltip) {
                    this._ensureDefaultTooltip(currSeries[i]);
                }
            }
        }
    }
    createTooltip() {
        if (!TypeRegistrar.isRegistered("IgxTooltipContainerComponent")) {
            return null;
        }
        let t = TypeRegistrar.get("IgxTooltipContainerComponent");
        let cf = this._componentFactoryResolver.resolveComponentFactory(t);
        //let cr = cf.create(this._injector);
        let cr = this._dynamicContent.createComponent(cf);
        let ele = cr.location.nativeElement;
        let self = this;
        ele.updateToolTip = function (c, isSubContent) {
            if (c.externalObject) {
                c = c.externalObject;
            }
            else {
                let ext = new IgxDataContext();
                ext._implementation = c;
                c = ext;
            }
            if (!isSubContent) {
                if (ele.parentElement != self._container) {
                    if (ele.parentElement != null) {
                        ele.parentElement.removeChild(ele);
                    }
                    self._container.appendChild(ele);
                }
            }
            else {
                c.isSubContent = true;
            }
            cr.instance.context = c;
            ele.style.display = "block";
            return true;
        };
        ele.hideToolTip = function () {
            ele.style.display = "none";
        };
        ele.style.display = "none";
        return cr;
    }
    /**
     * An imagery to display behind all series, inside the viewport of the IgxGeographicMapComponent control.
    */
    get backgroundContent() {
        if (this.i.backgroundContent != null) {
            return this.i.backgroundContent.externalObject;
        }
        else {
            return null;
        }
    }
    set backgroundContent(v) {
        if (v != undefined && v != null) {
            this.i.backgroundContent = v.i;
        }
        else {
            this.i.backgroundContent = null;
        }
    }
    /**
                             * @hidden
                             */
    get i() {
        return this._implementation;
    }
    /**
 * Gets or sets zoomability of the current control
*/
    get zoomable() {
        return this.i.no;
    }
    set zoomable(v) {
        this.i.no = ensureBool(v);
    }
    /**
     * Gets or sets the behavior to use during resize.
    */
    get resizeBehavior() {
        return this.i.nj;
    }
    set resizeBehavior(v) {
        this.i.nj = ensureEnum(MapResizeBehavior_$type, v);
    }
    /**
     * Gets or sets whether to use the uncoerced world rect to constrain the zoom bounds.
    */
    get useWorldRectForZoomBounds() {
        return this.i.nn;
    }
    set useWorldRectForZoomBounds(v) {
        this.i.nn = ensureBool(v);
    }
    /**
     * Gets or sets whether skip resetting the zoom when the world rect changes.
    */
    get suppressZoomResetOnWorldRectChange() {
        return this.i.nm;
    }
    set suppressZoomResetOnWorldRectChange(v) {
        this.i.nm = ensureBool(v);
    }
    /**
     * Gets or sets the world bounding rectangle.
    */
    get worldRect() {
        return fromRect(this.i.pf);
    }
    set worldRect(v) {
        this.i.pf = toRect(v);
    }
    /**
     * Gets the actual value of the WorldRect.
    */
    get actualWorldRect() {
        return fromRect(this.i.o3);
    }
    set actualWorldRect(v) {
        this.i.o3 = toRect(v);
    }
    /**
     * The X-axis for this IgxGeographicMap.Component
     * Under normal circumstances, this property should not be set in application code.  By default, it will be set to a numeric axis with a spherical mercator scaler.
    */
    get xAxis() {
        if (this.i.nc == null) {
            return null;
        }
        if (!this.i.nc.externalObject) {
            let e = IgxNumericXAxisComponent._createFromInternal(this.i.nc);
            if (e) {
                e._implementation = this.i.nc;
            }
            this.i.nc.externalObject = e;
        }
        return this.i.nc.externalObject;
    }
    set xAxis(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.nc = null : this.i.nc = v.i;
    }
    /**
     * The Y-axis for this IgxGeographicMap.Component
     * Under normal circumstances, this property should not be set in application code.  By default, it will be set to a numeric axis with a spherical mercator scaler.
    */
    get yAxis() {
        if (this.i.ne == null) {
            return null;
        }
        if (!this.i.ne.externalObject) {
            let e = IgxNumericYAxisComponent._createFromInternal(this.i.ne);
            if (e) {
                e._implementation = this.i.ne;
            }
            this.i.ne.externalObject = e;
        }
        return this.i.ne.externalObject;
    }
    set yAxis(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.ne = null : this.i.ne = v.i;
    }
    /**
     * Indicates if this SeriesViewer is a map.
    */
    get isMap() {
        return this.i.cx;
    }
    /**
     * A number between 0 and 1 determining the scale of the horizontal/vertical zoom.
     * This property is effectively a shortcut to the Width/Height of the WindowRect property.
    */
    get windowScale() {
        return this.i.nt;
    }
    set windowScale(v) {
        this.i.nt = +v;
    }
    /**
     * A number between 0 and 1 determining the scale of the horizontal/vertical zoom.
     * This property is effectively a shortcut to the Width/Height of the ActualWindowRect property.
    */
    get actualWindowScale() {
        return this.i.ns;
    }
    set actualWindowScale(v) {
        this.i.ns = +v;
    }
    /**
     * Gets whether or not the control is ready for zooming
    */
    get zoomIsReady() {
        return this.i.np;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.backgroundContent && this.backgroundContent.name && this.backgroundContent.name == name) {
            return this.backgroundContent;
        }
        return null;
    }
    _styling(container, component, parent) {
        super._styling(container, component, parent);
        this._inStyling = true;
        if (this.xAxis && this.xAxis._styling) {
            this.xAxis._styling(container, component, this);
        }
        if (this.yAxis && this.yAxis._styling) {
            this.yAxis._styling(container, component, this);
        }
        this._inStyling = false;
    }
    getCurrentActualWorldRect() {
        let iv = this.i.o7();
        return fromRect(iv);
    }
    /**
     * Given the current plot area of the control and a geographic region, get the WindowRect that would encompass that geographic region.
    
    * @param geographic  * The geographic area.
    */
    getZoomRectFromGeoRect(geographic) {
        let iv = this.i.getZoomRectFromGeoRect(toRect(geographic));
        return fromRect(iv);
    }
    updateZoomWindow(zoomWindow) {
        this.i.ol(toRect(zoomWindow));
    }
    updateWorldRect(worldRect) {
        this.i.ok(toRect(worldRect));
    }
    /**
     * Given the current plot area of the control and a geographic region, get the WindowRect that would encompass that geographic region.
    
    * @param geographic  * The geographic area.
    */
    getZoomFromGeographicRect(geographic) {
        let iv = this.i.getZoomFromGeographicRect(toRect(geographic));
        return fromRect(iv);
    }
    convertGeographicToZoom(geographic, extraPixelPadding) {
        let iv = this.i.o4(toRect(geographic), extraPixelPadding);
        return fromRect(iv);
    }
    getZoomFromGeographicPoints(northWest, southEast) {
        let iv = this.i.getZoomFromGeographicPoints(toPoint(northWest), toPoint(southEast));
        return fromRect(iv);
    }
    /**
     * Given a WindowRect and the current plot area, get the geographic region represented by that WindowRect.
    
    * @param windowRect  * The zoom area.
    */
    getGeographicFromZoom(windowRect) {
        let iv = this.i.o9(toRect(windowRect));
        return fromRect(iv);
    }
    /**
     * Convert a pixel-based coordinate to a geographic coordinate.
    
    * @param pixelCoordinate  * A pixel-based coordinate
    */
    getGeographicPoint(pixelCoordinate) {
        let iv = this.i.ov(toPoint(pixelCoordinate));
        return fromPoint(iv);
    }
    /**
     * Convert a geographic coordinate to a pixel-based coordinate.
    
    * @param geographicCoordinate  * A geographic coordinate
    */
    getPixelPoint(geographicCoordinate) {
        let iv = this.i.ow(toPoint(geographicCoordinate));
        return fromPoint(iv);
    }
    /**
     * Convert a geographic coordinate to a pixel-based coordinate.
    
    * @param geographicCoordinate  * A geographic coordinate
    */
    getWindowPoint(geographicCoordinate) {
        let iv = this.i.ox(toPoint(geographicCoordinate));
        return fromPoint(iv);
    }
    /**
     * Removes all cached tile images from the map imagery assigned to the map's background content.
    
    */
    clearTileCache() {
        this.i.n8();
    }
    /**
     * Notifies the chart that the CSS styles in effect have been updated.
    
    */
    styleUpdated() {
        this.i.og();
    }
    /**
     * Gets actual window scale for horizontal dimension of the control
    
    */
    getActualWindowScaleHorizontal() {
        let iv = this.i.eg();
        return (iv);
    }
    /**
     * Gets actual window scale for vertical dimension of the control
    
    */
    getActualWindowScaleVertical() {
        let iv = this.i.eh();
        return (iv);
    }
    /**
     * Calls for a deferred refresh to the GeographicMap's background.
    
    */
    deferredRefresh() {
        this.i.deferredRefresh();
    }
    /**
     * Returns the chart visuals expressed as a ChartVisualData object.
    
    */
    exportVisualData() {
        let iv = this.i.nw();
        return (iv);
    }
    /**
     * Zoom in to the geographic region specified, when possible (may need to wait for map to be initialized).
    
    * @param geographic  * The geographic region to zoom to.
    */
    zoomToGeographic(geographic) {
        this.i.on(toRect(geographic));
    }
    /**
     * This event is fired whenever the image tiles transition from a loading state (e.g. some are fading in) to a loaded state.
    */
    get imageTilesReady() {
        if (this._imageTilesReady == null) {
            this._imageTilesReady = new EventEmitter();
            this.i.imageTilesReady = delegateCombine(this.i.imageTilesReady, (o, e) => {
                let outerArgs = new IgxImageTilesReadyEventArgs();
                outerArgs._provideImplementation(e);
                if (this.beforeImageTilesReady) {
                    this.beforeImageTilesReady(this, outerArgs);
                }
                this._imageTilesReady.emit({
                    sender: this,
                    args: outerArgs
                });
            });
        }
        return this._imageTilesReady;
    }
};
__decorate([
    ContentChildren(IgxSeriesComponent),
    __metadata("design:type", QueryList)
], IgxGeographicMapComponent.prototype, "contentSeries", void 0);
__decorate([
    ViewChild("dynamicContent", { read: ViewContainerRef, static: true }),
    __metadata("design:type", ViewContainerRef)
], IgxGeographicMapComponent.prototype, "_dynamicContent", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicMapComponent.prototype, "height", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicMapComponent.prototype, "width", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], IgxGeographicMapComponent.prototype, "legend", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], IgxGeographicMapComponent.prototype, "dataSource", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], IgxGeographicMapComponent.prototype, "zoomable", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicMapComponent.prototype, "resizeBehavior", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], IgxGeographicMapComponent.prototype, "useWorldRectForZoomBounds", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], IgxGeographicMapComponent.prototype, "suppressZoomResetOnWorldRectChange", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], IgxGeographicMapComponent.prototype, "worldRect", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], IgxGeographicMapComponent.prototype, "actualWorldRect", null);
__decorate([
    Input(),
    __metadata("design:type", IgxNumericXAxisComponent),
    __metadata("design:paramtypes", [IgxNumericXAxisComponent])
], IgxGeographicMapComponent.prototype, "xAxis", null);
__decorate([
    Input(),
    __metadata("design:type", IgxNumericYAxisComponent),
    __metadata("design:paramtypes", [IgxNumericYAxisComponent])
], IgxGeographicMapComponent.prototype, "yAxis", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicMapComponent.prototype, "windowScale", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicMapComponent.prototype, "actualWindowScale", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter),
    __metadata("design:paramtypes", [])
], IgxGeographicMapComponent.prototype, "imageTilesReady", null);
IgxGeographicMapComponent = IgxGeographicMapComponent_1 = __decorate([
    Component({
        selector: 'igx-geographic-map',
        template: `<ng-container #dynamicContent></ng-container>`,
        changeDetection: ChangeDetectionStrategy.OnPush,
        providers: [{ provide: IgxSeriesViewerComponent, useExisting: forwardRef(() => IgxGeographicMapComponent_1) }],
        host: { 'class': 'igx-geographic-map ig-geographic-map' },
        styles: [`
		:host {
			display: block;
		}
	`]
    }),
    __metadata("design:paramtypes", [Renderer2,
        ViewContainerRef,
        NgZone,
        ComponentFactoryResolver,
        Injector])
], IgxGeographicMapComponent);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxBingMapsMapImageryModule = class IgxBingMapsMapImageryModule {
};
IgxBingMapsMapImageryModule = __decorate([
    NgModule({
        declarations: [],
        imports: [CommonModule],
        exports: [],
        entryComponents: []
    })
], IgxBingMapsMapImageryModule);

class IgxSubDomainsCollection extends IgCollection {
    constructor(list) {
        super();
        if (list) {
            for (let i = 0; i < list.length; i++) {
                this.add(list[i]);
            }
        }
    }
    _createInnerColl() {
        let coll = new SyncableObservableCollection$2(String_$type, String_$type, 0);
        coll.compare = (ext, int) => {
            let comp = ext;
            if (comp.equals) {
                return comp.equals(int);
            }
            return comp === int;
        };
        coll.createTo = (ext) => {
            return ext;
        };
        coll.createFrom = (int) => {
            return int;
        };
        return coll;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Describes available map styles for the Bing Maps imagery.
 */
var BingMapsImageryStyle;
(function (BingMapsImageryStyle) {
    /**
     * Specifies the Aerial map style without road or labels overlay.
     */
    BingMapsImageryStyle[BingMapsImageryStyle["Aerial"] = 0] = "Aerial";
    /**
     * Specifies the Aerial map style with road and labels overlay.
     */
    BingMapsImageryStyle[BingMapsImageryStyle["AerialWithLabels"] = 1] = "AerialWithLabels";
    /**
     * Specifies the Roads map style without aerial overlay.
     */
    BingMapsImageryStyle[BingMapsImageryStyle["Road"] = 2] = "Road";
    /**
     * Specifies a dark version of the Roads maps.
     */
    BingMapsImageryStyle[BingMapsImageryStyle["CanvasDark"] = 3] = "CanvasDark";
    /**
     * Specifies a lighter version of the Roads maps.
     */
    BingMapsImageryStyle[BingMapsImageryStyle["CanvasLight"] = 4] = "CanvasLight";
    /**
     * Specifies a grayscale version of the Roads maps.
     */
    BingMapsImageryStyle[BingMapsImageryStyle["CanvasGray"] = 5] = "CanvasGray";
})(BingMapsImageryStyle || (BingMapsImageryStyle = {}));
/**
 * @hidden
 */
let BingMapsImageryStyle_$type = markEnum('BingMapsImageryStyle', 'Aerial,0|AerialWithLabels,1|Road,2|CanvasDark,3|CanvasLight,4|CanvasGray,5');

class IgxImagesChangedEventArgs {
    createImplementation() {
        return new ImagesChangedEventArgs();
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
}

/**
 * Control class used for displaying multi-scale TileSource imagery.  Designed to be used for background imagery in the IgxGeographicMap.Component
*/
class IgxGeographicMapImagery {
    constructor() {
        this._imageTilesReady = null;
        this._imagesChanged = null;
        this._cancellingImage = null;
        this._downloadingImage = null;
        this._zoneRunner = null;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    createImplementation() {
        return null;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    /**
     * The deferral handler to use for deferred refreshes.
    */
    get deferralHandler() {
        return this.i.deferralHandler;
    }
    set deferralHandler(v) {
        this.i.deferralHandler = v;
    }
    /**
     * A rectangle representing the portion of the map imagery currently in view.
     * A rectangle at X=0, Y=0 with a Height and Width of 1 implies the entire plotting area is in view.  A Height and Width of .5 would imply that the view is halfway zoomed in.
    */
    get windowRect() {
        return fromRect(this.i.windowRect);
    }
    set windowRect(v) {
        this.i.windowRect = toRect(v);
    }
    /**
     * The IgxGeographicMapComponent which is hosting this GeographicMapImagery control.
    */
    get geographicMap() {
        if (this.i.geographicMap == null) {
            return null;
        }
        return this.i.geographicMap.externalObject;
    }
    set geographicMap(v) {
        v == null ? this.i.geographicMap = null : this.i.geographicMap = v.i;
    }
    /**
     * Gets or sets the referer sent in the headers of the tile request.
    */
    get referer() {
        return this.i.referer;
    }
    set referer(v) {
        this.i.referer = v;
    }
    /**
     * Gets or sets the UserAgent sent in the headers of the tile request.
    */
    get userAgent() {
        return this.i.userAgent;
    }
    set userAgent(v) {
        this.i.userAgent = v;
    }
    get opacity() {
        return this.i.opacity;
    }
    set opacity(v) {
        this.i.opacity = +v;
    }
    findByName(name) {
        if (this.geographicMap && this.geographicMap.name && this.geographicMap.name == name) {
            return this.geographicMap;
        }
        return null;
    }
    /**
     * Removes all cached tile Imagery from the
    
    */
    clearTileCache() {
        this.i.clearTileCache();
    }
    /**
     * Event raised when the image tiles have been downloaded.
    */
    get imageTilesReady() {
        if (this._imageTilesReady == null) {
            this._imageTilesReady = new EventEmitter();
            this.i.imageTilesReady = delegateCombine(this.i.imageTilesReady, (o, e) => {
                this._runInZone(() => {
                    let outerArgs = new IgxImageTilesReadyEventArgs();
                    outerArgs._provideImplementation(e);
                    if (this.beforeImageTilesReady) {
                        this.beforeImageTilesReady(this, outerArgs);
                    }
                    this._imageTilesReady.emit({
                        sender: this,
                        args: outerArgs
                    });
                });
            });
        }
        return this._imageTilesReady;
    }
    /**
     * Event raised when tile images have changed.
    */
    get imagesChanged() {
        if (this._imagesChanged == null) {
            this._imagesChanged = new EventEmitter();
            this.i.imagesChanged = delegateCombine(this.i.imagesChanged, (o, e) => {
                let outerArgs = new IgxImagesChangedEventArgs();
                outerArgs._provideImplementation(e);
                if (this.beforeImagesChanged) {
                    this.beforeImagesChanged(this, outerArgs);
                }
                this._imagesChanged.emit({
                    sender: this,
                    args: outerArgs
                });
            });
        }
        return this._imagesChanged;
    }
    /**
     * Event raised when an image is being downloaded.
    */
    get cancellingImage() {
        if (this._cancellingImage == null) {
            this._cancellingImage = new EventEmitter();
            this.i.cancellingImage = delegateCombine(this.i.cancellingImage, (o, e) => {
                let outerArgs = new IgxCancellingMultiScaleImageEventArgs();
                outerArgs._provideImplementation(e);
                if (this.beforeCancellingImage) {
                    this.beforeCancellingImage(this, outerArgs);
                }
                this._cancellingImage.emit({
                    sender: this,
                    args: outerArgs
                });
            });
        }
        return this._cancellingImage;
    }
    /**
     * Event raised when an image is being downloaded.
    */
    get downloadingImage() {
        if (this._downloadingImage == null) {
            this._downloadingImage = new EventEmitter();
            this.i.downloadingImage = delegateCombine(this.i.downloadingImage, (o, e) => {
                let outerArgs = new IgxDownloadingMultiScaleImageEventArgs();
                outerArgs._provideImplementation(e);
                if (this.beforeDownloadingImage) {
                    this.beforeDownloadingImage(this, outerArgs);
                }
                this._downloadingImage.emit({
                    sender: this,
                    args: outerArgs
                });
            });
        }
        return this._downloadingImage;
    }
    _runInZone(act) {
        if (this._zoneRunner != null) {
            this._zoneRunner(act);
        }
        else {
            act();
        }
    }
}
__decorate([
    Output(),
    __metadata("design:type", EventEmitter),
    __metadata("design:paramtypes", [])
], IgxGeographicMapImagery.prototype, "imageTilesReady", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter),
    __metadata("design:paramtypes", [])
], IgxGeographicMapImagery.prototype, "imagesChanged", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter),
    __metadata("design:paramtypes", [])
], IgxGeographicMapImagery.prototype, "cancellingImage", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter),
    __metadata("design:paramtypes", [])
], IgxGeographicMapImagery.prototype, "downloadingImage", null);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class SubDomainsCollection extends ObservableCollection$1 {
    constructor(a, ..._rest) {
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0:
                {
                    super(String_$type, 0);
                }
                break;
            case 1:
                {
                    let c = _rest[0];
                    super(String_$type, 1, c);
                }
                break;
        }
    }
}
SubDomainsCollection.$t = markType(SubDomainsCollection, 'SubDomainsCollection', ObservableCollection$1.$.specialize(String_$type));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class BingMapsMapImageryView extends GeographicMapImageryView {
    constructor(a) {
        super(a);
        this.k = a;
    }
    m() {
        if (this.k.subDomains == null) {
            this.k.subDomains = new SubDomainsCollection(0);
        }
        this.k.ap.tilePath = this.k.actualTilePath;
        this.k.ap.subDomains = this.k.actualSubDomains;
        this.k.ap.cultureName = this.k.cultureName;
    }
    o() {
        this.k.ap.tilePath = this.k.actualTilePath;
    }
    l() {
        this.k.ap.cultureName = this.k.cultureName;
    }
    n() {
        this.k.ap.subDomains = this.k.actualSubDomains;
    }
}
BingMapsMapImageryView.$t = markType(BingMapsMapImageryView, 'BingMapsMapImageryView', GeographicMapImageryView.$);
/**
 * @hidden
 */
class BingMapsMapImagery extends GeographicMapImagery {
    constructor() {
        super(new BingMapsTileSource(0));
        this._pendingBingRequest_ = null;
        this._isInitialized = false;
        this.bw = null;
        this.bn = null;
        this.bx = null;
        this.bv = null;
        this.getResponseCompleted = this.getResponseCompleted.bind(this);
        this.bm.m();
        this.actualBingImageryRestUri = BingMapsMapImagery.b9;
    }
    ai() {
        return new BingMapsMapImageryView(this);
    }
    a9(a) {
        super.a9(a);
        this.bm = a;
    }
    get isInitialized() {
        return this._isInitialized;
    }
    set isInitialized(a) {
        this._isInitialized = a;
    }
    get actualTilePath() {
        return this.bw;
    }
    set actualTilePath(a) {
        let b = this.bw;
        this.bw = a;
        this.cj("ActualTilePath", b, this.bw);
    }
    get actualSubDomains() {
        return this.bn;
    }
    set actualSubDomains(a) {
        let b = this.bn;
        this.bn = a;
        this.cj("ActualSubDomains", b, this.bn);
    }
    get bingImageryRestUri() {
        return this.bx;
    }
    set bingImageryRestUri(a) {
        let b = this.bx;
        this.bx = a;
        this.cj("BingImageryRestUri", b, this.bx);
    }
    get actualBingImageryRestUri() {
        return this.bv;
    }
    set actualBingImageryRestUri(a) {
        let b = this.bv;
        this.bv = a;
        this.a8("ActualBingImageryRestUri", b, this.bv);
    }
    requestMapSettings() {
        this.cl(true);
    }
    cl(a) {
        this.ci(a);
    }
    bt() {
        if ((this.tilePath == null) && (this.subDomains == null)) {
            return true;
        }
        return false;
    }
    cn() {
        this.isInitialized = false;
        if (!this.bs()) {
            this.cm("", null);
            return;
        }
        if (!this.isDeferredLoad) {
            this.cl(false);
        }
    }
    bs() {
        if (stringIsNullOrEmpty(this.apiKey) || this.apiKey.length < 20) {
            return false;
        }
        return true;
    }
    cg() {
    }
    cm(a, b) {
        if (a != this.actualTilePath) {
            this.actualTilePath = a;
        }
        let c = b == null ? null : new SubDomainsCollection(1, b);
        if (this.actualSubDomains != c) {
            this.actualSubDomains = c;
        }
        this.bm.m();
    }
    ci(a) {
        if ((!a) && (this.isDeferredLoad)) {
            return;
        }
        if (!this.bs()) {
            this.isInitialized = false;
            this.cm("", null);
            return;
        }
        this.isInitialized = true;
        let b = null;
        if (this.bingImageryRestUri != null) {
            if (Uri.isWellFormedUriString(this.bingImageryRestUri, 1)) {
                b = this.bingImageryRestUri;
            }
        }
        else {
            if (Uri.isWellFormedUriString(this.actualBingImageryRestUri, 1)) {
                b = this.actualBingImageryRestUri;
            }
        }
        if (b == null) {
            this.cm("", null);
            return;
        }
        let c = this.imageryStyle;
        b += enumGetBox(BingMapsImageryStyle_$type, c);
        let d = "key=" + this.apiKey + "&include=ImageryProviders";
        let url_ = b + "?" + d;
        this._pendingBingRequest_ = HttpRequestUtil.submit(url_, this.getResponseCompleted, null);
    }
    getResponseCompleted(a, b) {
        if (b != this._pendingBingRequest_) {
            return;
        }
        this._pendingBingRequest_ = null;
        let data_ = a;
        let resourceSets_ = JSON.parse(data_).resourceSets;
        if (resourceSets_ == null) {
            return;
        }
        let resources_ = resourceSets_.length > 0 ? resourceSets_[0].resources : null;
        if (resources_ == null) {
            return;
        }
        if (resources_.length == 0) {
            return;
        }
        ;
        let imageUrl_ = (resources_[0].imageUrl);
        let subDomains_ = new List$1(String_$type, 0);
        for (var i = 0; i < resources_[0].imageUrlSubdomains.length; i++) {
            subDomains_.add(resources_[0].imageUrlSubdomains[i]);
        }
        ;
        this.cm(imageUrl_, subDomains_);
    }
    cf(a, b) {
        this.aj.e();
        this.cn();
        this.cj(BingMapsMapImagery.$$p[4], this.actualSubDomains, this.actualSubDomains);
    }
    cj(a, b, c) {
        switch (a) {
            case BingMapsMapImagery.$$p[0]:
                this.cn();
                break;
            case BingMapsMapImagery.$$p[3]:
                this.cn();
                break;
            case BingMapsMapImagery.$$p[5]:
                this.cg();
                this.actualTilePath = c;
                this.bm.o();
                this.aj.e();
                break;
            case BingMapsMapImagery.$$p[1]:
                this.bm.l();
                this.aj.e();
                break;
            case BingMapsMapImagery.$$p[2]:
                this.cn();
                break;
            case BingMapsMapImagery.$$p[4]:
                this.cg();
                let d = b;
                let e = c;
                if (this.actualSubDomains != null) {
                    let f = this.actualSubDomains;
                    f.collectionChanged = delegateRemove(f.collectionChanged, runOn(this, this.cf));
                }
                this.actualSubDomains = e;
                if (this.actualSubDomains != null) {
                    e.collectionChanged = delegateCombine(e.collectionChanged, runOn(this, this.cf));
                }
                this.bm.n();
                this.aj.e();
                break;
            case "ActualTilePath":
                let g = c;
                if (stringIsNullOrEmpty(g)) {
                    this.cn();
                }
                break;
            case "BingImageryRestUri":
                this.actualBingImageryRestUri = c;
                this.cg();
                this.cn();
                break;
            case "ActualBingImageryRestUri":
                this.cg();
                this.cn();
                break;
        }
        super.a8(a, b, c);
    }
}
BingMapsMapImagery.$t = markType(BingMapsMapImagery, 'BingMapsMapImagery', GeographicMapImagery.$);
BingMapsMapImagery.b9 = "http://dev.virtualearth.net/REST/v1/Imagery/Metadata/";
BingMapsMapImagery.$$p = markDep(DependencyProperty, PropertyMetadata, BingMapsMapImagery, 'cj', ['ApiKey', [2, stringEmpty()], 'CultureName', [2, "en-US"], 'ImageryStyle', [BingMapsImageryStyle_$type, enumGetBox(BingMapsImageryStyle_$type, 1)], 'IsDeferredLoad', [0, false], 'SubDomains', [SubDomainsCollection.$, null], 'TilePath', [2, null]]);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/**
 * UI element class used to display BingMapsMap imagery in the IgxGeographicMap.Component
*/
class IgxBingMapsMapImagery extends IgxGeographicMapImagery {
    constructor() {
        super();
        this._subDomains = null;
        this._actualSubDomains = null;
    }
    createImplementation() {
        return new BingMapsMapImagery();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * Gets a status whether the Bing Maps service is initialized.
    */
    get isInitialized() {
        return this.i.isInitialized;
    }
    set isInitialized(v) {
        this.i.isInitialized = ensureBool(v);
    }
    /**
     * Gets or sets whether the Bing Maps service should be auto-initialized upon valid property values.
    */
    get isDeferredLoad() {
        return this.i.isDeferredLoad;
    }
    set isDeferredLoad(v) {
        this.i.isDeferredLoad = ensureBool(v);
    }
    /**
     * Gets or sets the map tile image uri.
    */
    get tilePath() {
        return this.i.tilePath;
    }
    set tilePath(v) {
        this.i.tilePath = v;
    }
    /**
     * Gets or sets the actual map tile image uri.
    */
    get actualTilePath() {
        return this.i.actualTilePath;
    }
    set actualTilePath(v) {
        this.i.actualTilePath = v;
    }
    /**
     * Gets or sets the collection of image uri subdomains.
    */
    get subDomains() {
        if (this._subDomains === null) {
            let coll = new IgxSubDomainsCollection();
            let innerColl = this.i.subDomains;
            if (!innerColl) {
                innerColl = new SubDomainsCollection(0);
            }
            this._subDomains = coll._fromInner(innerColl);
            this.i.subDomains = innerColl;
        }
        return this._subDomains;
    }
    set subDomains(v) {
        if (this._subDomains !== null) {
            this._subDomains._setSyncTarget(null);
            this._subDomains = null;
        }
        let coll = new IgxSubDomainsCollection();
        this._subDomains = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(String_$type);
        let innerColl = this.i.subDomains;
        if (!innerColl) {
            innerColl = new SubDomainsCollection(0);
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._subDomains._setSyncTarget(syncColl);
        this.i.subDomains = innerColl;
    }
    /**
     * Gets or sets the actual collection of image uri subdomains.
    */
    get actualSubDomains() {
        if (this._actualSubDomains === null) {
            let coll = new IgxSubDomainsCollection();
            let innerColl = this.i.actualSubDomains;
            if (!innerColl) {
                innerColl = new SubDomainsCollection(0);
            }
            this._actualSubDomains = coll._fromInner(innerColl);
            this.i.actualSubDomains = innerColl;
        }
        return this._actualSubDomains;
    }
    set actualSubDomains(v) {
        if (this._actualSubDomains !== null) {
            this._actualSubDomains._setSyncTarget(null);
            this._actualSubDomains = null;
        }
        let coll = new IgxSubDomainsCollection();
        this._actualSubDomains = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(String_$type);
        let innerColl = this.i.actualSubDomains;
        if (!innerColl) {
            innerColl = new SubDomainsCollection(0);
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._actualSubDomains._setSyncTarget(syncColl);
        this.i.actualSubDomains = innerColl;
    }
    /**
     * Gets or sets the Bing Imagery Rest Uri.
    */
    get bingImageryRestUri() {
        return this.i.bingImageryRestUri;
    }
    set bingImageryRestUri(v) {
        this.i.bingImageryRestUri = v;
    }
    /**
     * Gets or sets the Actual Bing Imagery Rest Uri.
    */
    get actualBingImageryRestUri() {
        return this.i.actualBingImageryRestUri;
    }
    set actualBingImageryRestUri(v) {
        this.i.actualBingImageryRestUri = v;
    }
    /**
     * Gets or sets the culture name for this tile source.
    */
    get cultureName() {
        return this.i.cultureName;
    }
    set cultureName(v) {
        this.i.cultureName = v;
    }
    /**
     * Gets or sets an API key required by the Bing Maps imagery service.
     * This key must be obtained from the http://www.bingmapsportal.com website.
    */
    get apiKey() {
        return this.i.apiKey;
    }
    set apiKey(v) {
        this.i.apiKey = v;
    }
    /**
     * Gets or sets a map style of the Bing Maps imagery tiles.  For example: Aerial, AerialWithLabels, or Road map style.
    */
    get imageryStyle() {
        return this.i.imageryStyle;
    }
    set imageryStyle(v) {
        this.i.imageryStyle = ensureEnum(BingMapsImageryStyle_$type, v);
    }
    /**
     * Will Connect to the Bing Rest API and retrieve the required TilePath and Subdomains from the service.  This requires a valid API key to already be set.
    
    */
    requestMapSettings() {
        this.i.requestMapSettings();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxBingMapsMapImageryDynamicModule = class IgxBingMapsMapImageryDynamicModule {
    constructor() {
        TypeRegistrar.registerCons("IgxBingMapsMapImagery", IgxBingMapsMapImagery);
        TypeRegistrar.register("BingMapsMapImagery", BingMapsMapImagery.$type);
    }
};
IgxBingMapsMapImageryDynamicModule = __decorate([
    NgModule({
        declarations: [],
        imports: [CommonModule, IgxBingMapsMapImageryModule],
        exports: [IgxBingMapsMapImageryModule],
        entryComponents: [IgxBingMapsMapImagery]
    }),
    __metadata("design:paramtypes", [])
], IgxBingMapsMapImageryDynamicModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxOpenStreetMapImageryModule = class IgxOpenStreetMapImageryModule {
};
IgxOpenStreetMapImageryModule = __decorate([
    NgModule({
        declarations: [],
        imports: [CommonModule],
        exports: [],
        entryComponents: []
    })
], IgxOpenStreetMapImageryModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/**
 * UI element class used to display OpenStreetMap imagery in the IgxGeographicMap.Component
*/
class IgxOpenStreetMapImagery extends IgxGeographicMapImagery {
    createImplementation() {
        return new OpenStreetMapImagery();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor() {
        super();
    }
    /**
     * Gets or sets the tile path URL.
    */
    get tilePath() {
        return this.i.tilePath;
    }
    set tilePath(v) {
        this.i.tilePath = v;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxOpenStreetMapImageryDynamicModule = class IgxOpenStreetMapImageryDynamicModule {
    constructor() {
        TypeRegistrar.registerCons("IgxOpenStreetMapImagery", IgxOpenStreetMapImagery);
        TypeRegistrar.register("OpenStreetMapImagery", OpenStreetMapImagery.$type);
    }
};
IgxOpenStreetMapImageryDynamicModule = __decorate([
    NgModule({
        declarations: [],
        imports: [CommonModule, IgxOpenStreetMapImageryModule],
        exports: [IgxOpenStreetMapImageryModule],
        entryComponents: [IgxOpenStreetMapImagery]
    }),
    __metadata("design:paramtypes", [])
], IgxOpenStreetMapImageryDynamicModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxCustomMapImageryModule = class IgxCustomMapImageryModule {
};
IgxCustomMapImageryModule = __decorate([
    NgModule({
        declarations: [],
        imports: [CommonModule],
        exports: [],
        entryComponents: []
    })
], IgxCustomMapImageryModule);

/**
 * Represents a CustomMapImagery MapImagery
*/
class IgxCustomMapImagery extends IgxGeographicMapImagery {
    constructor() {
        super();
        this._getTileImageUri = null;
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * Raised when URI for tiles should be provided
    */
    get getTileImageUri() {
        if (this._getTileImageUri == null) {
            this._getTileImageUri = new EventEmitter();
            this.i.getTileImageUri = delegateCombine(this.i.getTileImageUri, (o, e) => {
                let outerArgs = new IgxGetTileImageUriArgs();
                outerArgs._provideImplementation(e);
                if (this.beforeGetTileImageUri) {
                    this.beforeGetTileImageUri(this, outerArgs);
                }
                this._getTileImageUri.emit({
                    sender: this,
                    args: outerArgs
                });
            });
        }
        return this._getTileImageUri;
    }
}
__decorate([
    Output(),
    __metadata("design:type", EventEmitter),
    __metadata("design:paramtypes", [])
], IgxCustomMapImagery.prototype, "getTileImageUri", null);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class CustomMapImagery extends GeographicMapImagery {
    constructor(a) {
        super(a);
        this.getTileImageUri = null;
        a.getTileImageUri = delegateCombine(a.getTileImageUri, runOn(this, this.bn));
    }
    bn(a, b) {
        this.bm(b);
    }
    bm(a) {
        if (this.getTileImageUri != null) {
            this.getTileImageUri(this, a);
        }
    }
}
CustomMapImagery.$t = markType(CustomMapImagery, 'CustomMapImagery', GeographicMapImagery.$);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxCustomMapImageryDynamicModule = class IgxCustomMapImageryDynamicModule {
    constructor() {
        TypeRegistrar.registerCons("IgxCustomMapImagery", IgxCustomMapImagery);
        TypeRegistrar.register("CustomMapImagery", CustomMapImagery.$type);
    }
};
IgxCustomMapImageryDynamicModule = __decorate([
    NgModule({
        declarations: [],
        imports: [CommonModule, IgxCustomMapImageryModule],
        exports: [IgxCustomMapImageryModule],
        entryComponents: [IgxCustomMapImagery]
    }),
    __metadata("design:paramtypes", [])
], IgxCustomMapImageryDynamicModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxArcGISOnlineMapImageryModule = class IgxArcGISOnlineMapImageryModule {
};
IgxArcGISOnlineMapImageryModule = __decorate([
    NgModule({
        declarations: [],
        imports: [CommonModule],
        exports: [],
        entryComponents: []
    })
], IgxArcGISOnlineMapImageryModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class ArcGISOnlineMapImagery extends GeographicMapImagery {
    constructor() {
        super(new ArcGISOnlineTileSource());
        this.bm = 0;
        this.br = null;
        this.bq = null;
        this._pendingTokenRequest_ = null;
        this._pendingMapServerRequest_ = null;
        this.bq = "localhost";
        this.br = "https://www.arcgis.com/sharing/";
        this.bm = 60;
        this.userToken = null;
        this.getResponseCompleted_MapServerResponse = this.getResponseCompleted_MapServerResponse.bind(this);
        this.getResponseCompleted_TokenResponse = this.getResponseCompleted_TokenResponse.bind(this);
    }
    get mapServerUri() {
        return this.c(ArcGISOnlineMapImagery.mapServerUriProperty);
    }
    set mapServerUri(a) {
        this.h(ArcGISOnlineMapImagery.mapServerUriProperty, a);
    }
    static ca(a, b) {
        a.cc("MapServerUri", b.oldValue, b.newValue);
    }
    get userName() {
        return this.c(ArcGISOnlineMapImagery.userNameProperty);
    }
    set userName(a) {
        this.h(ArcGISOnlineMapImagery.userNameProperty, a);
    }
    static cd(a, b) {
        a.cc("UserName", b.oldValue, b.newValue);
    }
    get password() {
        return this.c(ArcGISOnlineMapImagery.passwordProperty);
    }
    set password(a) {
        this.h(ArcGISOnlineMapImagery.passwordProperty, a);
    }
    static cb(a, b) {
        a.cc("Password", b.oldValue, b.newValue);
    }
    get userToken() {
        return this.c(ArcGISOnlineMapImagery.userTokenProperty);
    }
    set userToken(a) {
        this.h(ArcGISOnlineMapImagery.userTokenProperty, a);
    }
    static ce(a, b) {
        a.cc("UserToken", b.oldValue, b.newValue);
    }
    get isMapPublic() {
        return this.c(ArcGISOnlineMapImagery.isMapPublicProperty);
    }
    set isMapPublic(a) {
        this.h(ArcGISOnlineMapImagery.isMapPublicProperty, a);
    }
    static b9(a, b) {
        a.cc("IsMapPublic", b.oldValue, b.newValue);
    }
    get defaultTokenTimeout() {
        return this.bm;
    }
    set defaultTokenTimeout(a) {
        this.bm = a;
        this.b5(true);
    }
    get tokenGenerationEndPoint() {
        return this.br;
    }
    set tokenGenerationEndPoint(a) {
        this.br = a;
        this.b5(true);
    }
    get refererUri() {
        return this.bq;
    }
    set refererUri(a) {
        this.bq = a;
        this.b5(true);
    }
    acquireNewToken() {
        this.b5(true);
    }
    b6(a) {
        a();
    }
    b5(a) {
        if (stringIsNullOrEmpty(this.userToken) && a == false) {
            this.cf();
            return;
        }
        let b = this.tokenGenerationEndPoint;
        if (stringIsNullOrEmpty(b)) {
            this.userToken = "";
            return;
        }
        if (b.substr(b.length - 1, 1) != "/") {
            b += "/";
        }
        if (stringIsNullOrEmpty(this.refererUri)) {
            this.userToken = "";
            return;
        }
        let c = this.defaultTokenTimeout;
        if (c < 1) {
            c = 1;
        }
        b += stringFormat1(ArcGISOnlineMapImagery.bs, this.userName, this.password, this.refererUri, c);
        if (!Uri.isWellFormedUriString(b, 1)) {
            this.userToken = "";
            return;
        }
        let url_ = b;
        this._pendingTokenRequest_ = HttpRequestUtil.submit(url_, this.getResponseCompleted_TokenResponse, null);
    }
    cf() {
        if (stringIsNullOrEmpty(this.mapServerUri)) {
            return;
        }
        let a = this.mapServerUri;
        if (a.substr(a.length - 1, 1) == "/") {
            stringRemove(a, a.length - 1, 1);
        }
        if (!this.isMapPublic) {
            if (stringIsNullOrEmpty(this.userToken)) {
                return;
            }
            a = stringFormat("{0}?f=json&token={1}", a, this.userToken);
        }
        else {
            a = stringFormat("{0}?f=json", a);
        }
        if (!Uri.isWellFormedUriString(a, 1)) {
            return;
        }
        let url_ = a;
        this._pendingMapServerRequest_ = HttpRequestUtil.submit(url_, this.getResponseCompleted_MapServerResponse, null);
    }
    getResponseCompleted_TokenResponse(a, b) {
        if (b != this._pendingTokenRequest_) {
            return;
        }
        this._pendingTokenRequest_ = null;
        let data_ = a;
        let c = (JSON.parse(data_));
        if (c != null) {
            let d = "";
            if (c.token != null) {
                d = c.token;
            }
            this.userToken = d;
        }
    }
    getResponseCompleted_MapServerResponse(a, b) {
        if (b != this._pendingMapServerRequest_) {
            return;
        }
        this._pendingMapServerRequest_ = null;
        let data_ = a;
        let c = (JSON.parse(data_));
        if ((c != null) && (c.tileInfo != null)) {
            this.ap.levelOfDetail = c.tileInfo.lods.length;
        }
    }
    cc(a, b, c) {
        let d = typeCast(ArcGISOnlineTileSource.$, this.ap);
        switch (a) {
            case "MapServerUri":
                if (d != null) {
                    d.mapServerUri = typeCast(String_$type, c);
                }
                this.cf();
                break;
            case "UserName":
            case "Password":
                if (stringIsNullOrEmpty(this.userName) || stringIsNullOrEmpty(this.password)) {
                    return;
                }
                this.b5(true);
                break;
            case "UserToken":
                this.b6(() => d.userToken = this.userToken);
                this.cf();
                break;
            case "IsMapPublic":
                d.isMapPublic = this.isMapPublic;
                break;
        }
        super.a8(a, b, c);
    }
}
ArcGISOnlineMapImagery.$t = markType(ArcGISOnlineMapImagery, 'ArcGISOnlineMapImagery', GeographicMapImagery.$);
ArcGISOnlineMapImagery.bs = "generateToken?username={0}&password={1}&client=referer&referer={2}&expiration={3}&f=pjson";
ArcGISOnlineMapImagery.mapServerUriProperty = DependencyProperty.i("MapServerUri", String_$type, ArcGISOnlineMapImagery.$, new PropertyMetadata(2, null, ArcGISOnlineMapImagery.ca));
ArcGISOnlineMapImagery.userNameProperty = DependencyProperty.i("UserName", String_$type, ArcGISOnlineMapImagery.$, new PropertyMetadata(2, null, ArcGISOnlineMapImagery.cd));
ArcGISOnlineMapImagery.passwordProperty = DependencyProperty.i("Password", String_$type, ArcGISOnlineMapImagery.$, new PropertyMetadata(2, null, ArcGISOnlineMapImagery.cb));
ArcGISOnlineMapImagery.userTokenProperty = DependencyProperty.i("UserToken", String_$type, ArcGISOnlineMapImagery.$, new PropertyMetadata(2, null, ArcGISOnlineMapImagery.ce));
ArcGISOnlineMapImagery.isMapPublicProperty = DependencyProperty.i("IsMapPublic", Boolean_$type, ArcGISOnlineMapImagery.$, new PropertyMetadata(2, true, ArcGISOnlineMapImagery.b9));

/**
 * UI element class used to display ArcGIS Online Map imagery in the IgxGeographicMap.Component
*/
class IgxArcGISOnlineMapImagery extends IgxGeographicMapImagery {
    createImplementation() {
        return new ArcGISOnlineMapImagery();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor() {
        super();
    }
    /**
     * Gets or sets the map tile server uri.
    */
    get mapServerUri() {
        return this.i.mapServerUri;
    }
    set mapServerUri(v) {
        this.i.mapServerUri = v;
    }
    /**
     * Gets or sets the UserName.
    */
    get userName() {
        return this.i.userName;
    }
    set userName(v) {
        this.i.userName = v;
    }
    /**
     * Gets or sets the Password.
    */
    get password() {
        return this.i.password;
    }
    set password(v) {
        this.i.password = v;
    }
    /**
     * Gets or sets the UserToken.
    */
    get userToken() {
        return this.i.userToken;
    }
    set userToken(v) {
        this.i.userToken = v;
    }
    /**
     * Gets or sets the IsMapPublic variable.  A value of false requires authentication parameters.
    */
    get isMapPublic() {
        return this.i.isMapPublic;
    }
    set isMapPublic(v) {
        this.i.isMapPublic = ensureBool(v);
    }
    /**
     * Gets or Sets the Default Token Timeout before the Token Expires, this value is in Minutes
    */
    get defaultTokenTimeout() {
        return this.i.defaultTokenTimeout;
    }
    set defaultTokenTimeout(v) {
        this.i.defaultTokenTimeout = +v;
    }
    /**
     * Gets or Sets the current endpoint to retrieve the token.
    */
    get tokenGenerationEndPoint() {
        return this.i.tokenGenerationEndPoint;
    }
    set tokenGenerationEndPoint(v) {
        this.i.tokenGenerationEndPoint = v;
    }
    /**
     * Contains the User Supplied Referer Uri to be used in Token Generation.
    */
    get refererUri() {
        return this.i.refererUri;
    }
    set refererUri(v) {
        this.i.refererUri = v;
    }
    /**
     * Retreives a new token based on the preconfigured parameters and updates the UserToken field, Normal this is called automatically.
     * The is provided to the end-user to allow them to reteive tokens on their onw.
    
    */
    acquireNewToken() {
        this.i.acquireNewToken();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxArcGISOnlineMapImageryDynamicModule = class IgxArcGISOnlineMapImageryDynamicModule {
    constructor() {
        TypeRegistrar.registerCons("IgxArcGISOnlineMapImagery", IgxArcGISOnlineMapImagery);
        TypeRegistrar.register("ArcGISOnlineMapImagery", ArcGISOnlineMapImagery.$type);
    }
};
IgxArcGISOnlineMapImageryDynamicModule = __decorate([
    NgModule({
        declarations: [],
        imports: [CommonModule, IgxArcGISOnlineMapImageryModule],
        exports: [IgxArcGISOnlineMapImageryModule],
        entryComponents: [IgxArcGISOnlineMapImagery]
    }),
    __metadata("design:paramtypes", [])
], IgxArcGISOnlineMapImageryDynamicModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxGeographicMapCoreModule = class IgxGeographicMapCoreModule {
    constructor() {
    }
};
IgxGeographicMapCoreModule = __decorate([
    NgModule({
        declarations: [IgxGeographicMapComponent],
        exports: [IgxBingMapsMapImageryModule,
            IgxOpenStreetMapImageryModule,
            IgxCustomMapImageryModule,
            IgxArcGISOnlineMapImageryModule,
            IgxGeographicMapComponent
        ],
        imports: [CommonModule, IgxBingMapsMapImageryModule,
            IgxOpenStreetMapImageryModule,
            IgxCustomMapImageryModule,
            IgxArcGISOnlineMapImageryModule
        ],
        entryComponents: []
    }),
    __metadata("design:paramtypes", [])
], IgxGeographicMapCoreModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxGeographicMapCoreDynamicModule = class IgxGeographicMapCoreDynamicModule {
    constructor() {
        TypeRegistrar.registerCons('IgxGeographicMapComponent', IgxGeographicMapComponent);
    }
};
IgxGeographicMapCoreDynamicModule = __decorate([
    NgModule({
        declarations: [],
        exports: [IgxBingMapsMapImageryDynamicModule,
            IgxOpenStreetMapImageryDynamicModule,
            IgxCustomMapImageryDynamicModule,
            IgxArcGISOnlineMapImageryDynamicModule,
            IgxGeographicMapCoreModule
        ],
        imports: [CommonModule, IgxBingMapsMapImageryDynamicModule,
            IgxOpenStreetMapImageryDynamicModule,
            IgxCustomMapImageryDynamicModule,
            IgxArcGISOnlineMapImageryDynamicModule,
            IgxGeographicMapCoreModule
        ],
        entryComponents: [IgxGeographicMapComponent]
    }),
    __metadata("design:paramtypes", [])
], IgxGeographicMapCoreDynamicModule);

/**
 * Base class for hosting chart series in a IgxGeographicMap.Component
*/
const IgxGeographicMapSeriesHostComponent_PROVIDERS = [{ provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxGeographicMapSeriesHostComponent) }];
class IgxGeographicMapSeriesHostComponent extends IgxSeriesComponent {
    constructor() {
        super();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * Checks if this control is geographic coordinate system
    */
    get isGeographic() {
        return this.i.ct;
    }
    /**
     * The minimum scale at which this series becomes visible.
     * The default value for this property is 1.0, which means the series will always be visible.  At a VisibleFromScale setting of 0.0, the series will never be visible.  At a VisibleFromScale setting of 0.5, the series will be visible as long as the map is zoomed in to at least 200%.
    */
    get visibleFromScale() {
        return this.i.l5;
    }
    set visibleFromScale(v) {
        this.i.l5 = +v;
    }
    /**
     * Gets or sets the coercion methods to use when loading data from data sources.
     * Should be specified before setting any member paths, if being used. Setting it later
     * will not cause data to be reimported into the chart.
    */
    get coercionMethods() {
        return this.i.coercionMethods;
    }
    set coercionMethods(v) {
        this.i.coercionMethods = v;
    }
    getItemValue(item, memberPathName) {
        let iv = this.i.fs(item, memberPathName);
        return (iv);
    }
    /**
     * Gets the item that is the best match for the specified world coordinates.
    
    * @param world  * The world coordinates to use.
    */
    getItem(world) {
        let iv = this.i.fp(toPoint(world));
        return (iv);
    }
    /**
     * Renders the series.
    
    * @param animate  * True if the change should be animated.
    */
    renderSeries(animate) {
        this.i.je(animate);
    }
    /**
     * Called when this series' Style is updated.
    
    */
    styleUpdated() {
        this.i.jn();
    }
}
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicMapSeriesHostComponent.prototype, "visibleFromScale", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], IgxGeographicMapSeriesHostComponent.prototype, "coercionMethods", null);

/**
 * Base class for series which render polygons on a map.
*/
const IgxGeographicShapeSeriesBaseComponent_PROVIDERS = [{ provide: IgxGeographicMapSeriesHostComponent, useExisting: forwardRef(() => IgxGeographicShapeSeriesBaseComponent) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxGeographicShapeSeriesBaseComponent) }];
class IgxGeographicShapeSeriesBaseComponent extends IgxGeographicMapSeriesHostComponent {
    constructor() {
        super();
        this._currData = null;
        this._sub = null;
    }
    get i() {
        return this._implementation;
    }
    /**
     * Gets or sets the string path of the .shp portion of the Shapefile.
    */
    set shapeDataSource(value) {
        this._shapeDataSource = value;
        this.updateShapeDataSource();
    }
    get shapeDataSource() {
        return this._shapeDataSource;
    }
    /**
     * Gets or sets the string path of the .dbf portion of the Shapefile.
    */
    set databaseSource(value) {
        this._databaseSource = value;
        this.updateShapeDataSource();
    }
    get databaseSource() {
        return this._databaseSource;
    }
    onUpdateDataSource(dataSource) {
        if (dataSource && dataSource.getPointData) {
            this._currData = dataSource;
            if (this._sub != null) {
                this._sub();
            }
            if (dataSource.count > 0) {
                return dataSource.getPointData();
            }
            this._sub = dataSource.importCompleted.subscribe((o, e) => {
                if (this._currData == dataSource) {
                    if (this._sub != null) {
                        this._sub();
                        this._sub == null;
                    }
                    this.i.itemsSource = dataSource.getPointData();
                }
            });
            return null;
        }
        return dataSource;
    }
    updateShapeDataSource() {
        if (this._cachedShapeDataSource == null) {
            this._cachedShapeDataSource = new IgxShapeDataSource();
            this.onShapeDataSourceImportCompleted = this.onShapeDataSourceImportCompleted.bind(this);
            this._cachedShapeDataSource.importCompleted.subscribe(this.onShapeDataSourceImportCompleted);
        }
        this._cachedShapeDataSource.shapefileSource = this._shapeDataSource;
        this._cachedShapeDataSource.databaseSource = this._databaseSource;
        if (this._shapeDataSource && this._databaseSource) {
            this._cachedShapeDataSource.dataBind();
        }
    }
    onShapeDataSourceImportCompleted(args) {
        this.dataSource = this._cachedShapeDataSource.getPointData();
    }
    /**
 * The name of the property on ItemsSource items which, for each shape, contains a list of points to be converted to a polygon.
 * To be consistent with the Shapefile technical description, it is expected that each list of points is defined as an IEnumerable of IEnumerable of Point, or in other words, a list of lists of points.
*/
    get shapeMemberPath() {
        return this.i.mi;
    }
    set shapeMemberPath(v) {
        this.i.mi = v;
    }
    /**
     * Set a shapefile datasource to use with the series.
    */
    get shapefileDataSource() {
        if (this.i.md == null) {
            return null;
        }
        if (!this.i.md.externalObject) {
            let e = new IgxShapeDataSource();
            e._implementation = this.i.md;
            this.i.md.externalObject = e;
        }
        return this.i.md.externalObject;
    }
    set shapefileDataSource(v) {
        v == null ? this.i.md = null : this.i.md = v.i;
    }
    /**
     * The resolution at which to filter out shapes in the series.  For example, if the ShapeFilterResolution is set to 3, then elements with a bounding rectangle smaller than 3 X 3 pixels will be filtered out.
     * In the case of GeographicPolylineSeries, the resolution is compared to either dimension, rather than both.  In other words, a polyline will not be filtered if its height or its width exceeds the value of this property.  Whereas with a ShapeSeries, both the height and the width must exceed the value of this property.
    */
    get shapeFilterResolution() {
        return this.i.mf;
    }
    set shapeFilterResolution(v) {
        this.i.mf = +v;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.shapefileDataSource && this.shapefileDataSource.name && this.shapefileDataSource.name == name) {
            return this.shapefileDataSource;
        }
        return null;
    }
}
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicShapeSeriesBaseComponent.prototype, "shapeDataSource", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicShapeSeriesBaseComponent.prototype, "databaseSource", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicShapeSeriesBaseComponent.prototype, "shapeMemberPath", null);
__decorate([
    Input(),
    __metadata("design:type", IgxShapeDataSource),
    __metadata("design:paramtypes", [IgxShapeDataSource])
], IgxGeographicShapeSeriesBaseComponent.prototype, "shapefileDataSource", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicShapeSeriesBaseComponent.prototype, "shapeFilterResolution", null);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class GeographicShapeSeriesBase extends GeographicMapSeriesHost {
    constructor() {
        super(...arguments);
        this.mc = null;
        this.me = false;
    }
    bf() {
        return new GeographicShapeSeriesBaseView(this);
    }
    iv(a) {
        super.iv(a);
        this.mb = a;
    }
    i0(a, b, c, d) {
        super.i0(a, b, c, d);
        switch (b) {
            case "SeriesViewer":
                this.mb.b3();
                break;
            case "ActualBrush":
                this.mb.b1();
                break;
            case "ActualOutline":
                this.mb.b2();
                break;
            case "ShapeMemberPath":
                this.mb.b5();
                break;
            case "Thickness":
                this.mb.b6();
                break;
            case GeographicShapeSeriesBase.$$p[0]:
                this.mb.b4();
                break;
            case "ShapefileDataSource":
                if (c != null) {
                    let e = c;
                    if (this.me) {
                        e.importCompleted = delegateRemove(e.importCompleted, runOn(this, this.mk));
                    }
                }
                if (d != null) {
                    let f = d;
                    if (f.count > 0) {
                        this.ml();
                        break;
                    }
                    this.me = true;
                    f.importCompleted = delegateCombine(f.importCompleted, runOn(this, this.mk));
                }
                break;
        }
    }
    mk(a, b) {
        this.ml();
    }
    ml() {
        let sds_ = this.md;
        let ext_ = sds_.externalObject;
        this.itemsSource = (ext_.getPointData());
    }
    get md() {
        return this.mc;
    }
    set md(a) {
        let b = this.mc;
        this.mc = a;
        if (b != this.mc) {
            this.raisePropertyChanged("ShapefileDataSource", b, this.mc);
        }
    }
    get_dq() {
        return true;
    }
    set_dq(a) {
        super.set_dq(a);
    }
}
GeographicShapeSeriesBase.$t = markType(GeographicShapeSeriesBase, 'GeographicShapeSeriesBase', GeographicMapSeriesHost.$);
GeographicShapeSeriesBase.$$p = markDep(DependencyProperty, PropertyMetadata, GeographicShapeSeriesBase, 'raisePropertyChanged', ['ShapeFilterResolution:mf:mm', [1, 2], 'ShapeMemberPath:mi:mn', [2, "points"]]);
/**
 * @hidden
 */
class GeographicShapeSeriesBaseView extends HostSeriesView {
    constructor(a) {
        super(a);
        this.b0 = null;
        this.b0 = a;
    }
    bv() {
        super.bv();
        this.b0.l3.mv = this.b0.mi;
        this.b0.l3.k6 = this.b0.k4;
        this.b0.l3.k9 = this.b0.k5;
    }
    b3() {
        let a = this.b0.l3;
        if (this.b0.bs == null) {
            a.l7 = null;
            a.l9 = null;
            return;
        }
        a.l7 = this.b0.bs.nc;
        a.l9 = this.b0.bs.ne;
    }
    b1() {
        this.b0.l3.k6 = this.b0.k4;
    }
    b2() {
        this.b0.l3.k9 = this.b0.k5;
    }
    b5() {
        this.b0.l3.mv = this.b0.mi;
    }
    b6() {
        this.b0.l3.ey = this.b0.ey;
    }
    b4() {
        this.b0.l3.mp = this.b0.mf;
    }
}
GeographicShapeSeriesBaseView.$t = markType(GeographicShapeSeriesBaseView, 'GeographicShapeSeriesBaseView', HostSeriesView.$);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class GeographicShapeSeriesView extends GeographicShapeSeriesBaseView {
    constructor(a) {
        super(a);
        this.b7 = null;
        this.b7 = a;
        if (!this.n) {
            this.b7.mi = "points";
        }
    }
    bv() {
        super.bv();
        this.b7.l3.ok = this.b7.nh;
        this.b7.l3.nk = this.b7.mq;
        this.b7.l3.n1 = this.b7.m4;
        this.b7.l3.nm = this.b7.ms;
        this.b7.l3.ne = this.b7.mo;
    }
    cc() {
        this.b7.l3.n1 = this.b7.m4;
    }
    ce() {
        this.b7.l3.nm = this.b7.ms;
    }
    b9() {
        this.b7.l3.ne = this.b7.mo;
    }
    cd() {
        this.b7.l3.nf = this.b7.mp;
    }
    b8() {
        this.b7.l3.og = this.b7.ne;
    }
    ca() {
        this.b7.l3.oh = this.b7.nf;
    }
    cb() {
        this.b7.l3.oj = this.b7.ng;
    }
    cf() {
        this.b7.l3.nk = this.b7.mq;
    }
    cg() {
        this.b7.l3.ok = this.b7.nh;
    }
}
GeographicShapeSeriesView.$t = markType(GeographicShapeSeriesView, 'GeographicShapeSeriesView', GeographicShapeSeriesBaseView.$);
/**
 * @hidden
 */
class GeographicShapeSeries extends GeographicShapeSeriesBase {
    constructor() {
        super();
        this.styleShape = null;
        this.ms = 2;
        this.ab = GeographicShapeSeries.$;
    }
    bf() {
        return new GeographicShapeSeriesView(this);
    }
    iv(a) {
        super.iv(a);
        this.mr = a;
    }
    l2() {
        let a = new ScatterPolygonSeries();
        a.styleShape = delegateCombine(a.styleShape, runOn(this, this.m3));
        return a;
    }
    m3(a, b) {
        if (this.styleShape != null) {
            this.styleShape(this, b);
        }
    }
    i0(a, b, c, d) {
        super.i0(a, b, c, d);
        switch (b) {
            case GeographicShapeSeries.$$p[4]:
                this.mr.cc();
                break;
            case GeographicShapeSeries.$$p[5]:
                this.mr.ce();
                break;
            case GeographicShapeSeries.$$p[1]:
                this.mr.b9();
                break;
            case GeographicShapeSeries.$$p[6]:
                this.mr.cd();
                break;
            case GeographicShapeSeries.$$p[0]:
                this.mr.b8();
                break;
            case GeographicShapeSeries.$$p[2]:
                this.mr.ca();
                break;
            case GeographicShapeSeries.$$p[3]:
                this.mr.cb();
                break;
            case GeographicShapeSeries.$$p[8]:
                this.mr.cf();
                break;
            case GeographicShapeSeries.$$p[7]:
                this.mr.cg();
                break;
        }
    }
}
GeographicShapeSeries.$t = markType(GeographicShapeSeries, 'GeographicShapeSeries', GeographicShapeSeriesBase.$);
GeographicShapeSeries.$$p = markDep(DependencyProperty, PropertyMetadata, GeographicShapeSeries, 'raisePropertyChanged', ['MarkerBrush:ne:m5', [Brush.$], 'MarkerCollisionAvoidance:mo:m6', [CollisionAvoidanceType_$type, enumGetBox(CollisionAvoidanceType_$type, 0)], 'MarkerOutline:nf:m7', [Brush.$], 'MarkerStyle:ng:m8', [Style.$], 'MarkerTemplate:m4:m9', [DataTemplate.$, null], 'MarkerThickness:ms:na', [1], 'MarkerType:mp:nb', [MarkerType_$type, enumGetBox(MarkerType_$type, 1)], 'ShapeStyle:nh:nc', [Style.$, null], 'ShapeStyleSelector:mq:nd', [StyleSelector.$, null]]);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

var IgxGeographicShapeSeriesComponent_1;
/**
 * Series class which renders polygons as Paths, in a geographic context, based on lists of points in the ItemsSource.
*/
const IgxGeographicShapeSeriesComponent_PROVIDERS = [{ provide: IgxGeographicShapeSeriesBaseComponent, useExisting: forwardRef(() => IgxGeographicShapeSeriesComponent) }, { provide: IgxGeographicMapSeriesHostComponent, useExisting: forwardRef(() => IgxGeographicShapeSeriesComponent) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxGeographicShapeSeriesComponent) }];
let IgxGeographicShapeSeriesComponent = IgxGeographicShapeSeriesComponent_1 = class IgxGeographicShapeSeriesComponent extends IgxGeographicShapeSeriesBaseComponent {
    constructor() {
        super();
        this._styleShape = null;
    }
    createImplementation() {
        return new GeographicShapeSeries();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * Gets or sets the fill brush.
    */
    get shapeFill() {
        return this.i.nh ? this.i.nh.fill : null;
    }
    set shapeFill(v) {
        this.ensureShapeStyle();
        this.i.nh.fill = v;
    }
    /**
     * Gets or sets the stroke brush.
    */
    get shapeStroke() {
        return this.i.nh ? this.i.nh.stroke : null;
    }
    set shapeStroke(v) {
        this.ensureShapeStyle();
        this.i.nh.stroke = v;
    }
    /**
     * Gets or sets the stroke thickness.
    */
    get shapeStrokeThickness() {
        return this.i.nh ? this.i.nh.strokeThickness : NaN;
    }
    set shapeStrokeThickness(v) {
        this.ensureShapeStyle();
        this.i.nh.strokeThickness = +v;
    }
    /**
     * Gets or sets the opacity.
    */
    get shapeOpacity() {
        return this.i.nh ? this.i.nh.opacity : NaN;
    }
    set shapeOpacity(v) {
        this.ensureShapeStyle();
        this.i.nh.opacity = +v;
    }
    ensureShapeStyle() {
        if (this.i.nh) {
            return;
        }
        this.i.nh = new Style();
    }
    /**
     * Gets or sets the marker type for the current series object.
     * If the MarkerTemplate property is set, the setting of the MarkerType property will be ignored.
    */
    get markerType() {
        return this.i.mp;
    }
    set markerType(v) {
        this.i.mp = ensureEnum(MarkerType_$type, v);
    }
    /**
     * Gets or sets the MarkerTemplate for the current series object.
    */
    get markerTemplate() {
        return this.i.m4;
    }
    set markerTemplate(v) {
        this.i.m4 = v;
    }
    /**
     * Gets or sets the brush that specifies how the current series object's marker interiors are painted.
    */
    get markerBrush() {
        return brushToString(this.i.ne);
    }
    set markerBrush(v) {
        this.i.ne = stringToBrush(v);
    }
    /**
     * Gets or sets the brush that specifies how the current series object's marker outlines are painted.
    */
    get markerOutline() {
        return brushToString(this.i.nf);
    }
    set markerOutline(v) {
        this.i.nf = stringToBrush(v);
    }
    /**
     * Gets or sets thickness of the marker outline
    */
    get markerThickness() {
        return this.i.ms;
    }
    set markerThickness(v) {
        this.i.ms = +v;
    }
    /**
     * The desired behavior for markers in this series which are placed too close together for the current view, resulting in a collision.
    */
    get markerCollisionAvoidance() {
        return this.i.mo;
    }
    set markerCollisionAvoidance(v) {
        this.i.mo = ensureEnum(CollisionAvoidanceType_$type, v);
    }
    get styleShape() {
        if (this._styleShape == null) {
            this._styleShape = new EventEmitter();
            this.i.styleShape = delegateCombine(this.i.styleShape, (o, e) => {
                this._runInZone(() => {
                    let outerArgs = new IgxStyleShapeEventArgs();
                    outerArgs._provideImplementation(e);
                    if (this.beforeStyleShape) {
                        this.beforeStyleShape(this, outerArgs);
                    }
                    this._styleShape.emit({
                        sender: this,
                        args: outerArgs
                    });
                });
            });
        }
        return this._styleShape;
    }
};
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicShapeSeriesComponent.prototype, "shapeFill", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicShapeSeriesComponent.prototype, "shapeStroke", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicShapeSeriesComponent.prototype, "shapeStrokeThickness", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicShapeSeriesComponent.prototype, "shapeOpacity", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicShapeSeriesComponent.prototype, "markerType", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], IgxGeographicShapeSeriesComponent.prototype, "markerTemplate", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicShapeSeriesComponent.prototype, "markerBrush", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicShapeSeriesComponent.prototype, "markerOutline", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicShapeSeriesComponent.prototype, "markerThickness", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicShapeSeriesComponent.prototype, "markerCollisionAvoidance", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter),
    __metadata("design:paramtypes", [])
], IgxGeographicShapeSeriesComponent.prototype, "styleShape", null);
IgxGeographicShapeSeriesComponent = IgxGeographicShapeSeriesComponent_1 = __decorate([
    Component({
        selector: 'igx-geographic-shape-series',
        template: ``,
        providers: [{ provide: IgxGeographicShapeSeriesBaseComponent, useExisting: forwardRef(() => IgxGeographicShapeSeriesComponent_1) }, { provide: IgxGeographicMapSeriesHostComponent, useExisting: forwardRef(() => IgxGeographicShapeSeriesComponent_1) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxGeographicShapeSeriesComponent_1) }],
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [])
], IgxGeographicShapeSeriesComponent);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxGeographicShapeSeriesModule = class IgxGeographicShapeSeriesModule {
};
IgxGeographicShapeSeriesModule = __decorate([
    NgModule({
        declarations: [IgxGeographicShapeSeriesComponent],
        imports: [CommonModule, IgxScatterPolygonSeriesDynamicModule],
        exports: [IgxGeographicShapeSeriesComponent, IgxScatterPolygonSeriesDynamicModule],
        entryComponents: []
    })
], IgxGeographicShapeSeriesModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxGeographicShapeSeriesDynamicModule = class IgxGeographicShapeSeriesDynamicModule {
    constructor() {
        TypeRegistrar.registerCons("IgxGeographicShapeSeriesComponent", IgxGeographicShapeSeriesComponent);
        TypeRegistrar.register("GeographicShapeSeries", GeographicShapeSeries.$type);
    }
};
IgxGeographicShapeSeriesDynamicModule = __decorate([
    NgModule({
        declarations: [],
        imports: [CommonModule, IgxGeographicShapeSeriesModule],
        exports: [IgxGeographicShapeSeriesModule],
        entryComponents: [IgxGeographicShapeSeriesComponent]
    }),
    __metadata("design:paramtypes", [])
], IgxGeographicShapeSeriesDynamicModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class GeographicPolylineSeriesView extends GeographicShapeSeriesBaseView {
    constructor(a) {
        super(a);
        this.b7 = null;
        this.b7 = a;
    }
    bv() {
        super.bv();
        this.b7.l3.nd = this.b7.mo;
        this.b7.l3.ni = this.b7.mw;
    }
    b8() {
        this.b7.l3.nd = this.b7.mo;
    }
    b9() {
        this.b7.l3.ni = this.b7.mw;
    }
}
GeographicPolylineSeriesView.$t = markType(GeographicPolylineSeriesView, 'GeographicPolylineSeriesView', GeographicShapeSeriesBaseView.$);
/**
 * @hidden
 */
class GeographicPolylineSeries extends GeographicShapeSeriesBase {
    constructor() {
        super();
        this.styleShape = null;
        this.ab = GeographicPolylineSeries.$;
    }
    bf() {
        return new GeographicPolylineSeriesView(this);
    }
    iv(a) {
        super.iv(a);
        this.mp = a;
    }
    l2() {
        let a = new ScatterPolylineSeries();
        a.styleShape = delegateCombine(a.styleShape, runOn(this, this.mt));
        return a;
    }
    mt(a, b) {
        if (this.styleShape != null) {
            this.styleShape(this, b);
        }
    }
    i0(a, b, c, d) {
        super.i0(a, b, c, d);
        switch (b) {
            case GeographicPolylineSeries.$$p[1]:
                this.mp.b8();
                break;
            case GeographicPolylineSeries.$$p[0]:
                this.mp.b9();
                break;
        }
    }
}
GeographicPolylineSeries.$t = markType(GeographicPolylineSeries, 'GeographicPolylineSeries', GeographicShapeSeriesBase.$);
GeographicPolylineSeries.$$p = markDep(DependencyProperty, PropertyMetadata, GeographicPolylineSeries, 'raisePropertyChanged', ['ShapeStyle:mw:mu', [Style.$, null], 'ShapeStyleSelector:mo:mv', [StyleSelector.$, null]]);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

var IgxGeographicPolylineSeriesComponent_1;
/**
 * Series class used for displaying multiple polylines, in a geographic context, for datasources which contain multiple lists of points.
*/
const IgxGeographicPolylineSeriesComponent_PROVIDERS = [{ provide: IgxGeographicShapeSeriesBaseComponent, useExisting: forwardRef(() => IgxGeographicPolylineSeriesComponent) }, { provide: IgxGeographicMapSeriesHostComponent, useExisting: forwardRef(() => IgxGeographicPolylineSeriesComponent) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxGeographicPolylineSeriesComponent) }];
let IgxGeographicPolylineSeriesComponent = IgxGeographicPolylineSeriesComponent_1 = class IgxGeographicPolylineSeriesComponent extends IgxGeographicShapeSeriesBaseComponent {
    constructor() {
        super();
        this._styleShape = null;
    }
    createImplementation() {
        return new GeographicPolylineSeries();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * Gets or sets the fill brush.
    */
    get shapeFill() {
        return this.i.mw ? this.i.mw.fill : null;
    }
    set shapeFill(v) {
        this.ensureShapeStyle();
        this.i.mw.fill = v;
    }
    /**
     * Gets or sets the stroke brush.
    */
    get shapeStroke() {
        return this.i.mw ? this.i.mw.stroke : null;
    }
    set shapeStroke(v) {
        this.ensureShapeStyle();
        this.i.mw.stroke = v;
    }
    /**
     * Gets or sets the stroke thickness.
    */
    get shapeStrokeThickness() {
        return this.i.mw ? this.i.mw.strokeThickness : NaN;
    }
    set shapeStrokeThickness(v) {
        this.ensureShapeStyle();
        this.i.mw.strokeThickness = +v;
    }
    /**
     * Gets or sets the opacity.
    */
    get shapeOpacity() {
        return this.i.mw ? this.i.mw.opacity : NaN;
    }
    set shapeOpacity(v) {
        this.ensureShapeStyle();
        this.i.mw.opacity = +v;
    }
    ensureShapeStyle() {
        if (this.i.mw) {
            return;
        }
        this.i.mw = new Style();
    }
    get styleShape() {
        if (this._styleShape == null) {
            this._styleShape = new EventEmitter();
            this.i.styleShape = delegateCombine(this.i.styleShape, (o, e) => {
                this._runInZone(() => {
                    let outerArgs = new IgxStyleShapeEventArgs();
                    outerArgs._provideImplementation(e);
                    if (this.beforeStyleShape) {
                        this.beforeStyleShape(this, outerArgs);
                    }
                    this._styleShape.emit({
                        sender: this,
                        args: outerArgs
                    });
                });
            });
        }
        return this._styleShape;
    }
};
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicPolylineSeriesComponent.prototype, "shapeFill", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicPolylineSeriesComponent.prototype, "shapeStroke", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicPolylineSeriesComponent.prototype, "shapeStrokeThickness", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicPolylineSeriesComponent.prototype, "shapeOpacity", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter),
    __metadata("design:paramtypes", [])
], IgxGeographicPolylineSeriesComponent.prototype, "styleShape", null);
IgxGeographicPolylineSeriesComponent = IgxGeographicPolylineSeriesComponent_1 = __decorate([
    Component({
        selector: 'igx-geographic-polyline-series',
        template: ``,
        providers: [{ provide: IgxGeographicShapeSeriesBaseComponent, useExisting: forwardRef(() => IgxGeographicPolylineSeriesComponent_1) }, { provide: IgxGeographicMapSeriesHostComponent, useExisting: forwardRef(() => IgxGeographicPolylineSeriesComponent_1) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxGeographicPolylineSeriesComponent_1) }],
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [])
], IgxGeographicPolylineSeriesComponent);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxGeographicPolylineSeriesModule = class IgxGeographicPolylineSeriesModule {
};
IgxGeographicPolylineSeriesModule = __decorate([
    NgModule({
        declarations: [IgxGeographicPolylineSeriesComponent],
        imports: [CommonModule, IgxScatterPolylineSeriesDynamicModule],
        exports: [IgxGeographicPolylineSeriesComponent, IgxScatterPolylineSeriesDynamicModule],
        entryComponents: []
    })
], IgxGeographicPolylineSeriesModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxGeographicPolylineSeriesDynamicModule = class IgxGeographicPolylineSeriesDynamicModule {
    constructor() {
        TypeRegistrar.registerCons("IgxGeographicPolylineSeriesComponent", IgxGeographicPolylineSeriesComponent);
        TypeRegistrar.register("GeographicPolylineSeries", GeographicPolylineSeries.$type);
    }
};
IgxGeographicPolylineSeriesDynamicModule = __decorate([
    NgModule({
        declarations: [],
        imports: [CommonModule, IgxGeographicPolylineSeriesModule],
        exports: [IgxGeographicPolylineSeriesModule],
        entryComponents: [IgxGeographicPolylineSeriesComponent]
    }),
    __metadata("design:paramtypes", [])
], IgxGeographicPolylineSeriesDynamicModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxTileGeneratorMapImageryModule = class IgxTileGeneratorMapImageryModule {
};
IgxTileGeneratorMapImageryModule = __decorate([
    NgModule({
        declarations: [],
        imports: [CommonModule],
        exports: [],
        entryComponents: []
    })
], IgxTileGeneratorMapImageryModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class TileGeneratorMapImagery extends GeographicMapImagery {
    constructor() {
        super(new TileGeneratorTileSource());
        this.downloadingImage = delegateCombine(this.downloadingImage, runOn(this, this.bo));
        this.cancellingImage = delegateCombine(this.cancellingImage, runOn(this, this.bn));
    }
    bn(a, b) {
        let c = b.uri.toString().split('/');
        let d = parseInt(stringReplace(c[3], "/", ""));
        let e = parseInt(stringReplace(c[4], "/", ""));
        let f = parseInt(stringReplace(stringReplace(c[5], "/", ""), ".png", ""));
        if (this.tileGenerator != null) {
            this.tileGenerator.cancelTile(d, e, f);
        }
    }
    bo(a, b) {
        let c = b.uri.toString().split('/');
        let d = parseInt(stringReplace(c[3], "/", ""));
        let e = parseInt(stringReplace(c[4], "/", ""));
        let f = parseInt(stringReplace(stringReplace(c[5], "/", ""), ".png", ""));
        b.uri = null;
        let img_ = b.image;
        if (this.tileGenerator != null) {
            this.tileGenerator.getTile(d, e, f, (g, h) => this.deferralHandler.deferAction(() => img_.src = h.url), (g, h) => {
            }, (g, h) => {
            }, img_);
        }
    }
}
TileGeneratorMapImagery.$t = markType(TileGeneratorMapImagery, 'TileGeneratorMapImagery', GeographicMapImagery.$);
TileGeneratorMapImagery.$$p = markDep(DependencyProperty, PropertyMetadata, TileGeneratorMapImagery, 'a8', ['TileGenerator', [ITileGenerator_$type, null]]);

/**
 * Represents a CustomMapImagery MapImagery
*/
class IgxTileGeneratorMapImagery extends IgxGeographicMapImagery {
    createImplementation() {
        return new TileGeneratorMapImagery();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor() {
        super();
    }
    /**
     * Gets or sets the culture name for this tile source.
    */
    get tileGenerator() {
        return this.i.tileGenerator;
    }
    set tileGenerator(v) {
        this.i.tileGenerator = v;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxTileGeneratorMapImageryDynamicModule = class IgxTileGeneratorMapImageryDynamicModule {
    constructor() {
        TypeRegistrar.registerCons("IgxTileGeneratorMapImagery", IgxTileGeneratorMapImagery);
        TypeRegistrar.register("TileGeneratorMapImagery", TileGeneratorMapImagery.$type);
    }
};
IgxTileGeneratorMapImageryDynamicModule = __decorate([
    NgModule({
        declarations: [],
        imports: [CommonModule, IgxTileGeneratorMapImageryModule],
        exports: [IgxTileGeneratorMapImageryModule],
        entryComponents: [IgxTileGeneratorMapImagery]
    }),
    __metadata("design:paramtypes", [])
], IgxTileGeneratorMapImageryDynamicModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class TileSeries extends ShapeSeriesBase {
    constructor() {
        super(...arguments);
        this.ne = null;
        this.nd = null;
        this.imageTilesReady = null;
        this.nh = null;
        this.ni = false;
    }
    bf() {
        return new TileSeriesView(this);
    }
    iv(a) {
        super.iv(a);
        this.nc = a;
    }
    get_mi() {
        return false;
    }
    get ng() {
        return this.ne;
    }
    set ng(a) {
        let b = a != this.ng;
        if (b) {
            let c = this.ng;
            this.ne = a;
            this.raisePropertyChanged("TileImagery", c, a);
        }
    }
    get nf() {
        return this.nd;
    }
    set nf(a) {
        let b = this.nd;
        this.nd = a;
        this.raisePropertyChanged("ActualTileImagery", b, this.nd);
    }
    i0(a, b, c, d) {
        super.i0(a, b, c, d);
        let e;
        let f;
        switch (b) {
            case "TileImagery":
                e = c;
                f = d;
                if (e != null) {
                    e.propertyChanged = delegateRemove(e.propertyChanged, runOn(this, this.nl));
                }
                if (f != null) {
                    f.propertyChanged = delegateCombine(f.propertyChanged, runOn(this, this.nl));
                }
                this.nc.c5(e, f);
                this.je(false);
                this.il();
                break;
            case "ActualTileImagery":
                e = c;
                f = d;
                if (e != null) {
                    e.imageTilesReady = delegateRemove(e.imageTilesReady, runOn(this, this.nm));
                    e.deferralHandler = null;
                }
                if (f != null) {
                    f.imageTilesReady = delegateCombine(f.imageTilesReady, runOn(this, this.nm));
                    f.deferralHandler = this;
                }
                this.nc.c4(e, f);
                if (f != null && typeCast(XamGeographicMap.$, this.bs) !== null) {
                    f.geographicMap = this.bs;
                    this.no(this.bi);
                    this.nc.c1(this.bs.mr);
                }
                this.il();
                break;
            case "ActualWindowRect":
                this.nc.c1(d);
                break;
            case "WorldRect":
                this.nc.c8(d);
                break;
            case "SeriesViewer":
                let g = c;
                let h = d;
                if (g != null && this.nf != null) {
                    this.nf.bc(null);
                }
                if (h != null && this.nf != null) {
                    this.nf.bc(this.bi.t);
                }
                break;
        }
    }
    nl(a, b) {
        if (b.propertyName == "MultiScaleImage") {
            this.no(this.bi);
        }
    }
    nm(a, b) {
        if (this.imageTilesReady != null) {
            this.imageTilesReady(this, new EventArgs());
        }
        if (!this.ni) {
            this.nc.c6();
        }
    }
    register(a, b) {
        this.nh = b;
    }
    unRegister(a) {
        this.nh = null;
    }
    deferredRefresh() {
        this.je(false);
    }
    deferAction(a) {
        if (this.e4 != null) {
            this.e4.setTimeout(a, 0);
        }
        else {
            window.setTimeout(a, 0);
        }
    }
    jt(a, b) {
        this.nc.c7();
        super.jt(a, b);
    }
    jf(a) {
        super.jf(a);
        this.nn(a, this.bi);
    }
    nn(a, b) {
        let c;
        let d;
        let e = b;
        let f = b.getViewInfo(c, d);
        c = f.p0;
        d = f.p1;
        this.no(b);
        if (this.nh != null) {
            this.ni = true;
            this.nh(a);
            this.ni = false;
        }
        e.c6();
    }
    jd(a, b, c, d, e) {
        super.jd(a, b, c, d, e);
        let f = this.dz.item(d);
        f.ay(c);
        if (this.cc(f)) {
            return;
        }
        this.m1(f);
    }
    no(a) {
        let b;
        let c;
        let d = a.getViewInfo(b, c);
        b = d.p0;
        c = d.p1;
        if (this.ng != null && this.ng.ao != null) {
            if (this.ng != this.nf) {
                this.nf = this.ng;
            }
            if (this.nf != null && !b.isEmpty) {
                if (this.nf.width != b.width) {
                    this.nf.width = b.width;
                }
                if (this.nf.height != b.height) {
                    this.nf.height = b.height;
                }
            }
        }
    }
    hw(a, b) {
        super.hw(a, b);
        b.c2();
    }
}
TileSeries.$t = markType(TileSeries, 'TileSeries', ShapeSeriesBase.$, [IMapRenderDeferralHandler_$type]);
/**
 * @hidden
 */
class TileSeriesView extends ShapeSeriesViewBase {
    constructor(a) {
        super(a);
        this.cy = null;
        this.c9 = new GeometryGroup();
        this.c0 = null;
        this.cz = null;
        this.cy = a;
    }
    ca(a, b) {
        if (b.c.count > 0) {
            this.c9.d.add(b);
        }
    }
    cu(a, b) {
        return this.cv(a, b, true);
    }
    ct(a, b) {
        return null;
    }
    ce(a) {
    }
    cc(a, b) {
    }
    cj() {
        super.cj();
        this.c9.d.clear();
    }
    ci() {
        super.ci();
        this.an();
    }
    c1(a) {
        if (this.cy.ng != null) {
            this.cy.ng.windowRect = a;
        }
    }
    c4(a, b) {
        if (this.c0 == null) {
            this.c0 = this.e.e4.createElement("canvas");
            let c = this.e.e4.get2DCanvasContext(this.c0);
            this.cz = new RenderingContext(new CanvasViewRenderer(), c);
            this.c0.setAttribute("width", this.br.width.toString());
            this.c0.setAttribute("height", this.br.height.toString());
        }
        if (a != null) {
            a.bb(null);
            a.bc(null);
            a.imagesChanged = delegateRemove(a.imagesChanged, runOn(this, this.c3));
        }
        if (b != null) {
            if (this.t != null) {
                b.bc(this.t);
            }
            b.bb(this.cz);
            b.bd(this.br);
            b.imagesChanged = delegateCombine(b.imagesChanged, runOn(this, this.c3));
        }
    }
    c3(a, b) {
        this.an();
    }
    c5(a, b) {
    }
    c7() {
        if (this.c0 != null) {
            this.c0.setAttribute("width", this.br.width.toString());
            this.c0.setAttribute("height", this.br.height.toString());
        }
        if (this.cy.ng != null) {
            this.cy.ng.bd(this.br);
        }
    }
    a3(a, b) {
        super.a3(a, b);
        if (b) {
            return;
        }
        if (this.c0 == null) {
            return;
        }
        let c = false;
        if (this.c9.d.count > 0) {
            c = true;
            this.h.z();
            this.h.q(this.c9);
            let d = this.h.g();
            d.clip();
        }
        let e = truncate(Math.round(this.br.left));
        let f = truncate(Math.round(this.br.top));
        let g = truncate(Math.round(this.br.width));
        let h = truncate(Math.round(this.br.height));
        this.h.n(this.c0.getNativeElement(), 1, e, f, g, h, e, f, g, h);
        if (c) {
            this.h.y();
        }
    }
    c6() {
        this.an();
    }
    c2() {
    }
    c8(a) {
        if (this.cy.ng != null) {
            this.cy.ng.a4();
        }
    }
}
TileSeriesView.$t = markType(TileSeriesView, 'TileSeriesView', ShapeSeriesViewBase.$);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

var IgxTileSeriesComponent_1;
/**
 * Represents a tile series class that can render imagery tiles
*/
const IgxTileSeriesComponent_PROVIDERS = [{ provide: IgxShapeSeriesBaseComponent, useExisting: forwardRef(() => IgxTileSeriesComponent) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxTileSeriesComponent) }];
let IgxTileSeriesComponent = IgxTileSeriesComponent_1 = class IgxTileSeriesComponent extends IgxShapeSeriesBaseComponent {
    constructor() {
        super();
    }
    createImplementation() {
        return new TileSeries();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * The MapImagery which is used to provide the tiles for display.
    */
    get tileImagery() {
        if (this.i.ng == null) {
            return null;
        }
        return this.i.ng.externalObject;
    }
    set tileImagery(v) {
        v == null ? this.i.ng = null : this.i.ng = v.i;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.tileImagery && this.tileImagery.name && this.tileImagery.name == name) {
            return this.tileImagery;
        }
        return null;
    }
    /**
     * Defers rendering of the series
    
    */
    deferredRefresh() {
        this.i.deferredRefresh();
    }
};
__decorate([
    Input(),
    __metadata("design:type", IgxGeographicMapImagery),
    __metadata("design:paramtypes", [IgxGeographicMapImagery])
], IgxTileSeriesComponent.prototype, "tileImagery", null);
IgxTileSeriesComponent = IgxTileSeriesComponent_1 = __decorate([
    Component({
        selector: 'igx-tile-series',
        template: ``,
        providers: [{ provide: IgxShapeSeriesBaseComponent, useExisting: forwardRef(() => IgxTileSeriesComponent_1) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxTileSeriesComponent_1) }],
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [])
], IgxTileSeriesComponent);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxTileSeriesModule = class IgxTileSeriesModule {
};
IgxTileSeriesModule = __decorate([
    NgModule({
        declarations: [IgxTileSeriesComponent],
        imports: [CommonModule],
        exports: [IgxTileSeriesComponent],
        entryComponents: []
    })
], IgxTileSeriesModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxTileSeriesDynamicModule = class IgxTileSeriesDynamicModule {
    constructor() {
        TypeRegistrar.registerCons("IgxTileSeriesComponent", IgxTileSeriesComponent);
        TypeRegistrar.register("TileSeries", TileSeries.$type);
    }
};
IgxTileSeriesDynamicModule = __decorate([
    NgModule({
        declarations: [],
        imports: [CommonModule, IgxTileSeriesModule],
        exports: [IgxTileSeriesModule],
        entryComponents: [IgxTileSeriesComponent]
    }),
    __metadata("design:paramtypes", [])
], IgxTileSeriesDynamicModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class GeographicTileSeries extends GeographicShapeSeriesBase {
    constructor() {
        super();
        this.mp = null;
        this.mo = null;
        this.imageTilesReady = null;
        this.ab = GeographicTileSeries.$;
    }
    get mq() {
        return this.mp;
    }
    set mq(a) {
        let b = a != this.mq;
        if (b) {
            let c = this.mq;
            this.mp = a;
            this.raisePropertyChanged("TileImagery", c, a);
        }
    }
    mu() {
        if (this.mq != null) {
            this.mq.clearTileCache();
        }
    }
    i0(a, b, c, d) {
        super.i0(a, b, c, d);
        switch (b) {
            case "TileImagery":
                if (this.l3 != null) {
                    this.l3.ng = this.mq;
                }
                break;
        }
    }
    l8() {
        super.l8();
        this.l3.ng = this.mq;
        if (this.mo != null) {
            let a = this.mo;
            a.imageTilesReady = delegateRemove(a.imageTilesReady, runOn(this, this.mt));
        }
        this.mo = this.l3;
        if (this.mo != null) {
            let b = this.mo;
            b.imageTilesReady = delegateCombine(b.imageTilesReady, runOn(this, this.mt));
        }
    }
    l2() {
        return new TileSeries();
    }
    mt(a, b) {
        if (this.imageTilesReady != null) {
            this.imageTilesReady(this, new ImageTilesReadyEventArgs());
        }
    }
}
GeographicTileSeries.$t = markType(GeographicTileSeries, 'GeographicTileSeries', GeographicShapeSeriesBase.$);

var IgxGeographicTileSeriesComponent_1;
/**
 * Series class used for displaying a tile set, and using shapes to define the areas that should be rendered.
*/
const IgxGeographicTileSeriesComponent_PROVIDERS = [{ provide: IgxGeographicShapeSeriesBaseComponent, useExisting: forwardRef(() => IgxGeographicTileSeriesComponent) }, { provide: IgxGeographicMapSeriesHostComponent, useExisting: forwardRef(() => IgxGeographicTileSeriesComponent) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxGeographicTileSeriesComponent) }];
let IgxGeographicTileSeriesComponent = IgxGeographicTileSeriesComponent_1 = class IgxGeographicTileSeriesComponent extends IgxGeographicShapeSeriesBaseComponent {
    constructor() {
        super();
        this._imageTilesReady = null;
    }
    createImplementation() {
        return new GeographicTileSeries();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * The MapImagery which is used to provide the tiles for display.
    */
    get tileImagery() {
        if (this.i.mq == null) {
            return null;
        }
        return this.i.mq.externalObject;
    }
    set tileImagery(v) {
        v == null ? this.i.mq = null : this.i.mq = v.i;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.tileImagery && this.tileImagery.name && this.tileImagery.name == name) {
            return this.tileImagery;
        }
        return null;
    }
    /**
     * Removes all cached tile Imagery from the
    
    */
    clearTileCache() {
        this.i.mu();
    }
    /**
     * This event is fired whenever the image tiles transition from a loading state (e.g. some are fading in) to a loaded state.
    */
    get imageTilesReady() {
        if (this._imageTilesReady == null) {
            this._imageTilesReady = new EventEmitter();
            this.i.imageTilesReady = delegateCombine(this.i.imageTilesReady, (o, e) => {
                this._runInZone(() => {
                    let outerArgs = new IgxImageTilesReadyEventArgs();
                    outerArgs._provideImplementation(e);
                    if (this.beforeImageTilesReady) {
                        this.beforeImageTilesReady(this, outerArgs);
                    }
                    this._imageTilesReady.emit({
                        sender: this,
                        args: outerArgs
                    });
                });
            });
        }
        return this._imageTilesReady;
    }
};
__decorate([
    Input(),
    __metadata("design:type", IgxGeographicMapImagery),
    __metadata("design:paramtypes", [IgxGeographicMapImagery])
], IgxGeographicTileSeriesComponent.prototype, "tileImagery", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter),
    __metadata("design:paramtypes", [])
], IgxGeographicTileSeriesComponent.prototype, "imageTilesReady", null);
IgxGeographicTileSeriesComponent = IgxGeographicTileSeriesComponent_1 = __decorate([
    Component({
        selector: 'igx-geographic-tile-series',
        template: ``,
        providers: [{ provide: IgxGeographicShapeSeriesBaseComponent, useExisting: forwardRef(() => IgxGeographicTileSeriesComponent_1) }, { provide: IgxGeographicMapSeriesHostComponent, useExisting: forwardRef(() => IgxGeographicTileSeriesComponent_1) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxGeographicTileSeriesComponent_1) }],
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [])
], IgxGeographicTileSeriesComponent);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxGeographicTileSeriesModule = class IgxGeographicTileSeriesModule {
};
IgxGeographicTileSeriesModule = __decorate([
    NgModule({
        declarations: [IgxGeographicTileSeriesComponent],
        imports: [CommonModule, IgxTileSeriesDynamicModule],
        exports: [IgxGeographicTileSeriesComponent, IgxTileSeriesDynamicModule],
        entryComponents: []
    })
], IgxGeographicTileSeriesModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxGeographicTileSeriesDynamicModule = class IgxGeographicTileSeriesDynamicModule {
    constructor() {
        TypeRegistrar.registerCons("IgxGeographicTileSeriesComponent", IgxGeographicTileSeriesComponent);
        TypeRegistrar.register("GeographicTileSeries", GeographicTileSeries.$type);
    }
};
IgxGeographicTileSeriesDynamicModule = __decorate([
    NgModule({
        declarations: [],
        imports: [CommonModule, IgxGeographicTileSeriesModule],
        exports: [IgxGeographicTileSeriesModule],
        entryComponents: [IgxGeographicTileSeriesComponent]
    }),
    __metadata("design:paramtypes", [])
], IgxGeographicTileSeriesDynamicModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class GeographicProportionalSymbolSeriesView extends HostSeriesView {
    constructor(a) {
        super(a);
        this.b0 = null;
        this.b0 = a;
    }
    bv() {
        super.bv();
        let a = this.b0.l3;
        a.nv = this.b0.mv;
        a.nz = this.b0.mt;
        a.l2 = this.b0.md;
        a.mn = this.b0.na;
        a.l7 = this.b0.ml;
        a.px = this.b0.m6;
        a.o5 = this.b0.me;
        a.pr = this.b0.mr;
        a.pm = this.b0.mn;
        a.o1 = this.b0.mb;
        a.pd = this.b0.mg;
        a.pe = this.b0.mh;
        a.pk = this.b0.mk;
        a.pj = this.b0.mj;
    }
    b9() {
        this.b0.l3.nv = this.b0.mv;
    }
    b8() {
        this.b0.l3.nz = this.b0.mt;
    }
    ce() {
        this.b0.l3.l2 = this.b0.md;
    }
    cc() {
        this.b0.l3.mn = this.b0.na;
    }
    cd() {
        this.b0.l3.l7 = this.b0.ml;
    }
    cf() {
        this.b0.l3.no = this.b0.mm;
    }
    ch() {
        this.b0.l3.xAxis = this.b0.bs.nc;
    }
    ci() {
        this.b0.l3.yAxis = this.b0.bs.ne;
    }
    cg() {
        let a = this.b0.l3;
        if (this.b0.bs == null) {
            a.xAxis = null;
            a.yAxis = null;
            return;
        }
        a.xAxis = this.b0.bs.nc;
        a.yAxis = this.b0.bs.ne;
    }
    ca() {
        this.b0.l3.m1 = this.b0.nt;
    }
    cb() {
        this.b0.l3.m2 = this.b0.nu;
    }
    cj() {
        this.b0.l3.px = this.b0.m6;
    }
    ck() {
        this.b0.l3.o5 = this.b0.me;
        this.b0.l3.pf = this.b0.mi;
    }
    b4() {
        this.b0.l3.pr = this.b0.mr;
    }
    b2() {
        this.b0.l3.o1 = this.b0.mb;
        this.b0.l3.pd = this.b0.mg;
        this.b0.l3.pe = this.b0.mh;
        this.b0.l3.pk = this.b0.mk;
        this.b0.l3.pj = this.b0.mj;
    }
    b1() {
        this.b0.l3.pm = this.b0.mn;
    }
    cl() {
        this.b0.l3.pf = this.b0.mi;
    }
    b3() {
        this.b0.l3.pd = this.b0.mg;
    }
    b7() {
        this.b0.l3.pe = this.b0.mh;
    }
    b6() {
        this.b0.l3.pk = this.b0.mk;
    }
    b5() {
        this.b0.l3.pj = this.b0.mj;
    }
}
GeographicProportionalSymbolSeriesView.$t = markType(GeographicProportionalSymbolSeriesView, 'GeographicProportionalSymbolSeriesView', HostSeriesView.$);
/**
 * @hidden
 */
class GeographicProportionalSymbolSeries extends GeographicMapSeriesHost {
    constructor() {
        super();
        this.mc = null;
        this.ml = 2;
        this.mh = false;
        this.mk = NaN;
        this.mj = NaN;
        this.ab = GeographicProportionalSymbolSeries.$;
    }
    bf() {
        return new GeographicProportionalSymbolSeriesView(this);
    }
    iv(a) {
        super.iv(a);
        this.mf = a;
    }
    l2() {
        return new BubbleSeries();
    }
    i0(a, b, c, d) {
        super.i0(a, b, c, d);
        switch (b) {
            case "SeriesViewer":
                this.mf.cg();
                break;
            case GeographicProportionalSymbolSeries.$$p[5]:
                this.mf.b9();
                break;
            case GeographicProportionalSymbolSeries.$$p[4]:
                this.mf.b8();
                break;
            case GeographicProportionalSymbolSeries.$$p[13]:
                this.mf.ce();
                break;
            case GeographicProportionalSymbolSeries.$$p[11]:
                this.mf.cc();
                break;
            case GeographicProportionalSymbolSeries.$$p[12]:
                this.mf.cd();
                break;
            case GeographicProportionalSymbolSeries.$$p[14]:
                this.mf.cf();
                break;
            case "XAxis":
                this.mf.ch();
                break;
            case "YAxis":
                this.mf.ci();
                break;
            case GeographicProportionalSymbolSeries.$$p[7]:
                this.mf.ca();
                break;
            case GeographicProportionalSymbolSeries.$$p[9]:
                this.mf.cb();
                break;
            case GeographicProportionalSymbolSeries.$$p[15]:
                this.mf.cj();
                break;
            case GeographicProportionalSymbolSeries.$$p[16]:
                this.mf.ck();
                break;
            case GeographicProportionalSymbolSeries.$$p[17]:
                this.mf.cl();
                break;
            case GeographicProportionalSymbolSeries.$$p[3]:
                this.mf.b4();
                break;
            case GeographicProportionalSymbolSeries.$$p[0]:
                this.mf.b1();
                break;
            case GeographicProportionalSymbolSeries.$$p[1]:
                this.mf.b2();
                break;
            case GeographicProportionalSymbolSeries.$$p[2]:
                this.mf.b3();
                break;
            case GeographicProportionalSymbolSeries.$$p[10]:
                this.mf.b7();
                break;
            case GeographicProportionalSymbolSeries.$$p[8]:
                this.mf.b6();
                break;
            case GeographicProportionalSymbolSeries.$$p[6]:
                this.mf.b5();
                break;
        }
    }
}
GeographicProportionalSymbolSeries.$t = markType(GeographicProportionalSymbolSeries, 'GeographicProportionalSymbolSeries', GeographicMapSeriesHost.$);
GeographicProportionalSymbolSeries.$$p = markDep(DependencyProperty, PropertyMetadata, GeographicProportionalSymbolSeries, 'raisePropertyChanged', ['FillMemberPath:mn:nb', [2], 'FillScale:mb:nc', [BrushScale.$], 'FillScaleUseGlobalValues:mg:nd', [0], 'LabelMemberPath:mr:ne', [2], 'LatitudeMemberPath:mt:nf', [2, null], 'LongitudeMemberPath:mv:ng', [2, null], 'MarkerBrushBrightness:mj:nh', [1], 'MarkerBrush:nt:ni', [Brush.$], 'MarkerOutlineBrightness:mk:nj', [1], 'MarkerOutline:nu:nk', [Brush.$], 'MarkerOutlineUsesFillScale:mh:nl', [0], 'MarkerTemplate:na:nm', [DataTemplate.$, null], 'MarkerThickness:ml:nn', [1], 'MarkerType:md:no', [MarkerType_$type, enumGetBox(MarkerType_$type, 1)], 'MaximumMarkers:mm:np', [1, 400], 'RadiusMemberPath:m6:nq', [2, null], 'RadiusScale:me:nr', [SizeScale.$], 'RadiusScaleUseGlobalValues:mi:ns', [0]]);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

var IgxGeographicProportionalSymbolSeriesComponent_1;
/**
 * Series class for a geographic map with points marked at given locations.
 * This is the geographic equivalent of a ScatterSeries.
*/
const IgxGeographicProportionalSymbolSeriesComponent_PROVIDERS = [{ provide: IgxGeographicMapSeriesHostComponent, useExisting: forwardRef(() => IgxGeographicProportionalSymbolSeriesComponent) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxGeographicProportionalSymbolSeriesComponent) }];
let IgxGeographicProportionalSymbolSeriesComponent = IgxGeographicProportionalSymbolSeriesComponent_1 = class IgxGeographicProportionalSymbolSeriesComponent extends IgxGeographicMapSeriesHostComponent {
    constructor() {
        super();
    }
    createImplementation() {
        return new GeographicProportionalSymbolSeries();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * The name of the property of ItemsSource items which contains the latitude coordinate of the symbol.
    */
    get latitudeMemberPath() {
        return this.i.mt;
    }
    set latitudeMemberPath(v) {
        this.i.mt = v;
    }
    /**
     * The name of the property of ItemsSource items which contains the longitude coordinate of the symbol.
    */
    get longitudeMemberPath() {
        return this.i.mv;
    }
    set longitudeMemberPath(v) {
        this.i.mv = v;
    }
    /**
     * Gets or sets the marker type for the current series object.
     * If the MarkerTemplate property is set, the setting of the MarkerType property will be ignored.
    */
    get markerType() {
        return this.i.md;
    }
    set markerType(v) {
        this.i.md = ensureEnum(MarkerType_$type, v);
    }
    /**
     * Gets or sets the MarkerTemplate for the current series object.
    */
    get markerTemplate() {
        return this.i.na;
    }
    set markerTemplate(v) {
        this.i.na = v;
    }
    /**
     * Gets or sets the brush that specifies how the current series object's marker interiors are painted.
    */
    get markerBrush() {
        return brushToString(this.i.nt);
    }
    set markerBrush(v) {
        this.i.nt = stringToBrush(v);
    }
    /**
     * Gets or sets the brush that specifies how the current series object's marker outlines are painted.
    */
    get markerOutline() {
        return brushToString(this.i.nu);
    }
    set markerOutline(v) {
        this.i.nu = stringToBrush(v);
    }
    /**
     * Gets or sets the maximum number of markerItems displayed by the current series.
     * If more than the specified number of markerItems are visible, the series will automatically
     * choose a representative set.
    */
    get maximumMarkers() {
        return this.i.mm;
    }
    set maximumMarkers(v) {
        this.i.mm = +v;
    }
    /**
     * Gets or sets the radius mapping property for the current series object.
    */
    get radiusMemberPath() {
        return this.i.m6;
    }
    set radiusMemberPath(v) {
        this.i.m6 = v;
    }
    /**
     * Gets or sets the radius size scale for the bubbles.
    */
    get radiusScale() {
        if (this.i.me == null) {
            return null;
        }
        if (!this.i.me.externalObject) {
            let e = IgxSizeScaleComponent._createFromInternal(this.i.me);
            if (e) {
                e._implementation = this.i.me;
            }
            this.i.me.externalObject = e;
        }
        return this.i.me.externalObject;
    }
    set radiusScale(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.me = null : this.i.me = v.i;
    }
    /**
     * Gets or sets the Label mapping property for the current series object.
    */
    get labelMemberPath() {
        return this.i.mr;
    }
    set labelMemberPath(v) {
        this.i.mr = v;
    }
    /**
     * Gets or sets the fill mapping property for the current series object.
    */
    get fillMemberPath() {
        return this.i.mn;
    }
    set fillMemberPath(v) {
        this.i.mn = v;
    }
    /**
     * Gets or sets the brush scale for the marker brush.
    */
    get fillScale() {
        if (this.i.mb == null) {
            return null;
        }
        if (!this.i.mb.externalObject) {
            let e = IgxBrushScaleComponent._createFromInternal(this.i.mb);
            if (e) {
                e._implementation = this.i.mb;
            }
            this.i.mb.externalObject = e;
        }
        return this.i.mb.externalObject;
    }
    set fillScale(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.mb = null : this.i.mb = v.i;
    }
    /**
     * Gets or sets the whether or not the FillScale uses global values of FillMemberPath of multiple series.
     * This setting applies only if multiple series are using the same FillScale.
    */
    get fillScaleUseGlobalValues() {
        return this.i.mg;
    }
    set fillScaleUseGlobalValues(v) {
        this.i.mg = ensureBool(v);
    }
    /**
     * Gets or sets whether or not the marker outline should use FillScale like the marker fill does.
     * This setting applies only if the current series has a FillScale set and it overrides MarkerOutline setting.
    */
    get markerOutlineUsesFillScale() {
        return this.i.mh;
    }
    set markerOutlineUsesFillScale(v) {
        this.i.mh = ensureBool(v);
    }
    /**
     * Gets or sets brightness of the marker outline. Using negative value will change marker outline to darker color and positive value will change marker outline to brighter color
     * Note you can use any values between minimum value of -1 (darkest outline) and maximum value of 1 (brightest outline)
    */
    get markerOutlineBrightness() {
        return this.i.mk;
    }
    set markerOutlineBrightness(v) {
        this.i.mk = +v;
    }
    /**
     * Gets or sets brightness of the marker fill. Using negative value will change marker fill to darker color and positive value will change marker fill to brighter color
     * Note you can use any values between minimum value of -1 (darkest fill) and maximum value of 1 (brightest fill)
    */
    get markerBrushBrightness() {
        return this.i.mj;
    }
    set markerBrushBrightness(v) {
        this.i.mj = +v;
    }
    /**
     * Gets or sets thickness of the marker outline
    */
    get markerThickness() {
        return this.i.ml;
    }
    set markerThickness(v) {
        this.i.ml = +v;
    }
    /**
     * Gets or sets the whether or not the RadiusScale uses global values of RadiusMemberPath of multiple series.
     * This setting applies only if multiple series are using the same RadiusScale.
    */
    get radiusScaleUseGlobalValues() {
        return this.i.mi;
    }
    set radiusScaleUseGlobalValues(v) {
        this.i.mi = ensureBool(v);
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.radiusScale && this.radiusScale.name && this.radiusScale.name == name) {
            return this.radiusScale;
        }
        if (this.fillScale && this.fillScale.name && this.fillScale.name == name) {
            return this.fillScale;
        }
        return null;
    }
    _styling(container, component, parent) {
        super._styling(container, component, parent);
        this._inStyling = true;
        if (this.radiusScale && this.radiusScale._styling) {
            this.radiusScale._styling(container, component, this);
        }
        if (this.fillScale && this.fillScale._styling) {
            this.fillScale._styling(container, component, this);
        }
        this._inStyling = false;
    }
};
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicProportionalSymbolSeriesComponent.prototype, "latitudeMemberPath", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicProportionalSymbolSeriesComponent.prototype, "longitudeMemberPath", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicProportionalSymbolSeriesComponent.prototype, "markerType", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], IgxGeographicProportionalSymbolSeriesComponent.prototype, "markerTemplate", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicProportionalSymbolSeriesComponent.prototype, "markerBrush", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicProportionalSymbolSeriesComponent.prototype, "markerOutline", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicProportionalSymbolSeriesComponent.prototype, "maximumMarkers", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicProportionalSymbolSeriesComponent.prototype, "radiusMemberPath", null);
__decorate([
    Input(),
    __metadata("design:type", IgxSizeScaleComponent),
    __metadata("design:paramtypes", [IgxSizeScaleComponent])
], IgxGeographicProportionalSymbolSeriesComponent.prototype, "radiusScale", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicProportionalSymbolSeriesComponent.prototype, "labelMemberPath", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicProportionalSymbolSeriesComponent.prototype, "fillMemberPath", null);
__decorate([
    Input(),
    __metadata("design:type", IgxBrushScaleComponent),
    __metadata("design:paramtypes", [IgxBrushScaleComponent])
], IgxGeographicProportionalSymbolSeriesComponent.prototype, "fillScale", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], IgxGeographicProportionalSymbolSeriesComponent.prototype, "fillScaleUseGlobalValues", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], IgxGeographicProportionalSymbolSeriesComponent.prototype, "markerOutlineUsesFillScale", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicProportionalSymbolSeriesComponent.prototype, "markerOutlineBrightness", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicProportionalSymbolSeriesComponent.prototype, "markerBrushBrightness", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicProportionalSymbolSeriesComponent.prototype, "markerThickness", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], IgxGeographicProportionalSymbolSeriesComponent.prototype, "radiusScaleUseGlobalValues", null);
IgxGeographicProportionalSymbolSeriesComponent = IgxGeographicProportionalSymbolSeriesComponent_1 = __decorate([
    Component({
        selector: 'igx-geographic-proportional-symbol-series',
        template: ``,
        providers: [{ provide: IgxGeographicMapSeriesHostComponent, useExisting: forwardRef(() => IgxGeographicProportionalSymbolSeriesComponent_1) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxGeographicProportionalSymbolSeriesComponent_1) }],
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [])
], IgxGeographicProportionalSymbolSeriesComponent);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxGeographicProportionalSymbolSeriesModule = class IgxGeographicProportionalSymbolSeriesModule {
};
IgxGeographicProportionalSymbolSeriesModule = __decorate([
    NgModule({
        declarations: [IgxGeographicProportionalSymbolSeriesComponent],
        imports: [CommonModule, IgxBubbleSeriesDynamicModule],
        exports: [IgxGeographicProportionalSymbolSeriesComponent, IgxBubbleSeriesDynamicModule],
        entryComponents: []
    })
], IgxGeographicProportionalSymbolSeriesModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxGeographicProportionalSymbolSeriesDynamicModule = class IgxGeographicProportionalSymbolSeriesDynamicModule {
    constructor() {
        TypeRegistrar.registerCons("IgxGeographicProportionalSymbolSeriesComponent", IgxGeographicProportionalSymbolSeriesComponent);
        TypeRegistrar.register("GeographicProportionalSymbolSeries", GeographicProportionalSymbolSeries.$type);
    }
};
IgxGeographicProportionalSymbolSeriesDynamicModule = __decorate([
    NgModule({
        declarations: [],
        imports: [CommonModule, IgxGeographicProportionalSymbolSeriesModule],
        exports: [IgxGeographicProportionalSymbolSeriesModule],
        entryComponents: [IgxGeographicProportionalSymbolSeriesComponent]
    }),
    __metadata("design:paramtypes", [])
], IgxGeographicProportionalSymbolSeriesDynamicModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class GeographicSymbolSeriesView extends HostSeriesView {
    constructor(a) {
        super(a);
        this.b0 = null;
        this.b0 = a;
    }
    bv() {
        let a = this.b0.l3;
        super.bv();
        a.nv = this.b0.mk;
        a.nz = this.b0.mi;
        a.l2 = this.b0.mc;
        a.mn = this.b0.mu;
        a.l7 = this.b0.mg;
    }
    b2() {
        this.b0.l3.nv = this.b0.mk;
    }
    b1() {
        this.b0.l3.nz = this.b0.mi;
    }
    b8() {
        this.b0.l3.l2 = this.b0.mc;
    }
    b6() {
        this.b0.l3.mn = this.b0.mu;
    }
    b7() {
        this.b0.l3.l7 = this.b0.mg;
    }
    b9() {
        this.b0.l3.no = this.b0.mh;
    }
    cb() {
        this.b0.l3.xAxis = this.b0.bs.nc;
    }
    cc() {
        this.b0.l3.yAxis = this.b0.bs.ne;
    }
    ca() {
        let a = this.b0.l3;
        if (this.b0.bs == null) {
            a.xAxis = null;
            a.yAxis = null;
            return;
        }
        a.xAxis = this.b0.bs.nc;
        a.yAxis = this.b0.bs.ne;
    }
    b4() {
        this.b0.l3.m5 = this.b0.mb;
    }
    b3() {
        this.b0.l3.m1 = this.b0.m5;
    }
    b5() {
        this.b0.l3.m2 = this.b0.m6;
    }
}
GeographicSymbolSeriesView.$t = markType(GeographicSymbolSeriesView, 'GeographicSymbolSeriesView', HostSeriesView.$);
/**
 * @hidden
 */
class GeographicSymbolSeries extends GeographicMapSeriesHost {
    constructor() {
        super();
        this.md = null;
        this.mg = 2;
        this.ab = GeographicSymbolSeries.$;
    }
    bf() {
        return new GeographicSymbolSeriesView(this);
    }
    iv(a) {
        super.iv(a);
        this.me = a;
    }
    l2() {
        return new ScatterSeries();
    }
    i0(a, b, c, d) {
        super.i0(a, b, c, d);
        switch (b) {
            case "SeriesViewer":
                this.me.ca();
                break;
            case GeographicSymbolSeries.$$p[1]:
                this.me.b2();
                break;
            case GeographicSymbolSeries.$$p[0]:
                this.me.b1();
                break;
            case GeographicSymbolSeries.$$p[3]:
                this.me.b4();
                break;
            case GeographicSymbolSeries.$$p[7]:
                this.me.b8();
                break;
            case GeographicSymbolSeries.$$p[5]:
                this.me.b6();
                break;
            case GeographicSymbolSeries.$$p[6]:
                this.me.b7();
                break;
            case GeographicSymbolSeries.$$p[8]:
                this.me.b9();
                break;
            case "XAxis":
                this.me.cb();
                break;
            case "YAxis":
                this.me.cc();
                break;
            case GeographicSymbolSeries.$$p[2]:
                this.me.b3();
                break;
            case GeographicSymbolSeries.$$p[4]:
                this.me.b5();
                break;
        }
    }
}
GeographicSymbolSeries.$t = markType(GeographicSymbolSeries, 'GeographicSymbolSeries', GeographicMapSeriesHost.$);
GeographicSymbolSeries.$$p = markDep(DependencyProperty, PropertyMetadata, GeographicSymbolSeries, 'raisePropertyChanged', ['LatitudeMemberPath:mi:mv', [2, null], 'LongitudeMemberPath:mk:mw', [2, null], 'MarkerBrush:m5:mx', [Brush.$], 'MarkerCollisionAvoidance:mb:my', [CollisionAvoidanceType_$type, enumGetBox(CollisionAvoidanceType_$type, 0)], 'MarkerOutline:m6:mz', [Brush.$], 'MarkerTemplate:mu:m0', [DataTemplate.$, null], 'MarkerThickness:mg:m1', [1], 'MarkerType:mc:m2', [MarkerType_$type, enumGetBox(MarkerType_$type, 2)], 'MaximumMarkers:mh:m3', [1, 400], 'UseLightweightMarkers:mf:m4', [0, false]]);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

var IgxGeographicSymbolSeriesComponent_1;
/**
 * Series class for a geographic map with points marked at given locations.
 * This is the geographic equivalent of a ScatterSeries.
*/
const IgxGeographicSymbolSeriesComponent_PROVIDERS = [{ provide: IgxGeographicMapSeriesHostComponent, useExisting: forwardRef(() => IgxGeographicSymbolSeriesComponent) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxGeographicSymbolSeriesComponent) }];
let IgxGeographicSymbolSeriesComponent = IgxGeographicSymbolSeriesComponent_1 = class IgxGeographicSymbolSeriesComponent extends IgxGeographicMapSeriesHostComponent {
    constructor() {
        super();
    }
    createImplementation() {
        return new GeographicSymbolSeries();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * The name of the property of ItemsSource items which contains the latitude coordinate of the symbol.
    */
    get latitudeMemberPath() {
        return this.i.mi;
    }
    set latitudeMemberPath(v) {
        this.i.mi = v;
    }
    /**
     * The name of the property of ItemsSource items which contains the longitude coordinate of the symbol.
    */
    get longitudeMemberPath() {
        return this.i.mk;
    }
    set longitudeMemberPath(v) {
        this.i.mk = v;
    }
    /**
     * Gets or sets the marker type for the current series object.
     * If the MarkerTemplate property is set, the setting of the MarkerType property will be ignored.
    */
    get markerType() {
        return this.i.mc;
    }
    set markerType(v) {
        this.i.mc = ensureEnum(MarkerType_$type, v);
    }
    /**
     * The desired behavior for markers in this series which are placed too close together for the current view, resulting in a collision.
    */
    get markerCollisionAvoidance() {
        return this.i.mb;
    }
    set markerCollisionAvoidance(v) {
        this.i.mb = ensureEnum(CollisionAvoidanceType_$type, v);
    }
    /**
     * Gets or sets the MarkerTemplate for the current series object.
    */
    get markerTemplate() {
        return this.i.mu;
    }
    set markerTemplate(v) {
        this.i.mu = v;
    }
    /**
     * Gets or sets the brush that specifies how the current series object's marker interiors are painted.
    */
    get markerBrush() {
        return brushToString(this.i.m5);
    }
    set markerBrush(v) {
        this.i.m5 = stringToBrush(v);
    }
    /**
     * Gets or sets the brush that specifies how the current series object's marker outlines are painted.
    */
    get markerOutline() {
        return brushToString(this.i.m6);
    }
    set markerOutline(v) {
        this.i.m6 = stringToBrush(v);
    }
    /**
     * Gets or sets the maximum number of markerItems displayed by the current series.
     * If more than the specified number of markerItems are visible, the series will automatically
     * choose a representative set.
    */
    get maximumMarkers() {
        return this.i.mh;
    }
    set maximumMarkers(v) {
        this.i.mh = +v;
    }
    /**
     * Gets or sets thickness of the marker outline
    */
    get markerThickness() {
        return this.i.mg;
    }
    set markerThickness(v) {
        this.i.mg = +v;
    }
};
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicSymbolSeriesComponent.prototype, "latitudeMemberPath", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicSymbolSeriesComponent.prototype, "longitudeMemberPath", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicSymbolSeriesComponent.prototype, "markerType", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicSymbolSeriesComponent.prototype, "markerCollisionAvoidance", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], IgxGeographicSymbolSeriesComponent.prototype, "markerTemplate", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicSymbolSeriesComponent.prototype, "markerBrush", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicSymbolSeriesComponent.prototype, "markerOutline", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicSymbolSeriesComponent.prototype, "maximumMarkers", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicSymbolSeriesComponent.prototype, "markerThickness", null);
IgxGeographicSymbolSeriesComponent = IgxGeographicSymbolSeriesComponent_1 = __decorate([
    Component({
        selector: 'igx-geographic-symbol-series',
        template: ``,
        providers: [{ provide: IgxGeographicMapSeriesHostComponent, useExisting: forwardRef(() => IgxGeographicSymbolSeriesComponent_1) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxGeographicSymbolSeriesComponent_1) }],
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [])
], IgxGeographicSymbolSeriesComponent);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxGeographicSymbolSeriesModule = class IgxGeographicSymbolSeriesModule {
};
IgxGeographicSymbolSeriesModule = __decorate([
    NgModule({
        declarations: [IgxGeographicSymbolSeriesComponent],
        imports: [CommonModule, IgxScatterSeriesDynamicModule],
        exports: [IgxGeographicSymbolSeriesComponent, IgxScatterSeriesDynamicModule],
        entryComponents: []
    })
], IgxGeographicSymbolSeriesModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxGeographicSymbolSeriesDynamicModule = class IgxGeographicSymbolSeriesDynamicModule {
    constructor() {
        TypeRegistrar.registerCons("IgxGeographicSymbolSeriesComponent", IgxGeographicSymbolSeriesComponent);
        TypeRegistrar.register("GeographicSymbolSeries", GeographicSymbolSeries.$type);
    }
};
IgxGeographicSymbolSeriesDynamicModule = __decorate([
    NgModule({
        declarations: [],
        imports: [CommonModule, IgxGeographicSymbolSeriesModule],
        exports: [IgxGeographicSymbolSeriesModule],
        entryComponents: [IgxGeographicSymbolSeriesComponent]
    }),
    __metadata("design:paramtypes", [])
], IgxGeographicSymbolSeriesDynamicModule);

/**
 * Base class for geographic series which triangulate XY data prior to rendering.
*/
const IgxGeographicXYTriangulatingSeriesComponent_PROVIDERS = [{ provide: IgxGeographicMapSeriesHostComponent, useExisting: forwardRef(() => IgxGeographicXYTriangulatingSeriesComponent) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxGeographicXYTriangulatingSeriesComponent) }];
class IgxGeographicXYTriangulatingSeriesComponent extends IgxGeographicMapSeriesHostComponent {
    constructor() {
        super();
    }
    get i() {
        return this._implementation;
    }
    /**
     * Gets or sets the string path specifying the location of the Itf file.
    */
    set triangulationDataSource(value) {
        this._triangulationDataSource = value;
        this.updateTriangulationDataSource();
    }
    get triangulationDataSource() {
        return this._triangulationDataSource;
    }
    updateTriangulationDataSource() {
        if (this._cachedTriangulationDataSource == null) {
            this._cachedTriangulationDataSource = new IgxTriangulationDataSource();
            this.onTriangulationDataSourceImportCompleted = this.onTriangulationDataSourceImportCompleted.bind(this);
            this._cachedTriangulationDataSource.importCompleted.subscribe(this.onTriangulationDataSourceImportCompleted);
        }
        this._cachedTriangulationDataSource.source = this._triangulationDataSource;
    }
    onTriangulationDataSourceImportCompleted(s, e) {
        this.dataSource = this._cachedTriangulationDataSource.getPointData();
        this.trianglesSource = this._cachedTriangulationDataSource.getTriangleData();
    }
    /**
 * The name of the property from which to extract the Longitude for each item in the ItemsSource.
*/
    get longitudeMemberPath() {
        return this.i.mf;
    }
    set longitudeMemberPath(v) {
        this.i.mf = v;
    }
    /**
     * The name of the property from which to extract the Latitude for each item in the ItemsSource.
    */
    get latitudeMemberPath() {
        return this.i.md;
    }
    set latitudeMemberPath(v) {
        this.i.md = v;
    }
    /**
     * The source of triangulation data.
     * This property is optional.  If it is left as null, the triangulation will be created based on the items in the ItemsSource.  Triangulation is a demanding operation, so the runtime performance will be better when specifying a TriangulationSource, especially when a large number of data items are present.
    */
    get trianglesSource() {
        return this.i.mc;
    }
    set trianglesSource(v) {
        this.i.mc = v;
    }
    /**
     * The name of the property of the TrianglesSource items which, for each triangle, contains the index of the first vertex point in the ItemsSource.
    */
    get triangleVertexMemberPath1() {
        return this.i.mi;
    }
    set triangleVertexMemberPath1(v) {
        this.i.mi = v;
    }
    /**
     * The name of the property of the TrianglesSource items which, for each triangle, contains the index of the second vertex point in the ItemsSource.
    */
    get triangleVertexMemberPath2() {
        return this.i.mk;
    }
    set triangleVertexMemberPath2(v) {
        this.i.mk = v;
    }
    /**
     * The name of the property of the TrianglesSource items which, for each triangle, contains the index of the third vertex point in the ItemsSource.
    */
    get triangleVertexMemberPath3() {
        return this.i.mm;
    }
    set triangleVertexMemberPath3(v) {
        this.i.mm = v;
    }
}
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicXYTriangulatingSeriesComponent.prototype, "triangulationDataSource", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicXYTriangulatingSeriesComponent.prototype, "longitudeMemberPath", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicXYTriangulatingSeriesComponent.prototype, "latitudeMemberPath", null);
__decorate([
    Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], IgxGeographicXYTriangulatingSeriesComponent.prototype, "trianglesSource", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicXYTriangulatingSeriesComponent.prototype, "triangleVertexMemberPath1", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicXYTriangulatingSeriesComponent.prototype, "triangleVertexMemberPath2", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicXYTriangulatingSeriesComponent.prototype, "triangleVertexMemberPath3", null);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

var IgxGeographicScatterAreaSeriesComponent_1;
/**
 * Series class which draws a colored 2D surface, in a geographic context, based on a triangulation of XY data with numeric values assigned to each point.
*/
const IgxGeographicScatterAreaSeriesComponent_PROVIDERS = [{ provide: IgxGeographicXYTriangulatingSeriesComponent, useExisting: forwardRef(() => IgxGeographicScatterAreaSeriesComponent) }, { provide: IgxGeographicMapSeriesHostComponent, useExisting: forwardRef(() => IgxGeographicScatterAreaSeriesComponent) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxGeographicScatterAreaSeriesComponent) }];
let IgxGeographicScatterAreaSeriesComponent = IgxGeographicScatterAreaSeriesComponent_1 = class IgxGeographicScatterAreaSeriesComponent extends IgxGeographicXYTriangulatingSeriesComponent {
    constructor() {
        super();
        this._triangulationStatusChanged = null;
    }
    createImplementation() {
        return new GeographicScatterAreaSeries();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * The name of the property on each data item containing a numeric value which can be converted to a color by the ColorScale.
    */
    get colorMemberPath() {
        return this.i.mz;
    }
    set colorMemberPath(v) {
        this.i.mz = v;
    }
    /**
     * The ColorScale used to resolve the color values of points in the series.
    */
    get colorScale() {
        if (this.i.mv == null) {
            return null;
        }
        if (!this.i.mv.externalObject) {
            let e = IgxColorScaleComponent._createFromInternal(this.i.mv);
            if (e) {
                e._implementation = this.i.mv;
            }
            this.i.mv.externalObject = e;
        }
        return this.i.mv.externalObject;
    }
    set colorScale(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.mv = null : this.i.mv = v.i;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.colorScale && this.colorScale.name && this.colorScale.name == name) {
            return this.colorScale;
        }
        return null;
    }
    _styling(container, component, parent) {
        super._styling(container, component, parent);
        this._inStyling = true;
        if (this.colorScale && this.colorScale._styling) {
            this.colorScale._styling(container, component, this);
        }
        this._inStyling = false;
    }
    /**
     * Raised when the status of an ongoing Triangulation has changed.
    */
    get triangulationStatusChanged() {
        if (this._triangulationStatusChanged == null) {
            this._triangulationStatusChanged = new EventEmitter();
            this.i.triangulationStatusChanged = delegateCombine(this.i.triangulationStatusChanged, (o, e) => {
                this._runInZone(() => {
                    let outerArgs = new IgxTriangulationStatusEventArgs();
                    outerArgs._provideImplementation(e);
                    if (this.beforeTriangulationStatusChanged) {
                        this.beforeTriangulationStatusChanged(this, outerArgs);
                    }
                    this._triangulationStatusChanged.emit({
                        sender: this,
                        args: outerArgs
                    });
                });
            });
        }
        return this._triangulationStatusChanged;
    }
};
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicScatterAreaSeriesComponent.prototype, "colorMemberPath", null);
__decorate([
    Input(),
    __metadata("design:type", IgxColorScaleComponent),
    __metadata("design:paramtypes", [IgxColorScaleComponent])
], IgxGeographicScatterAreaSeriesComponent.prototype, "colorScale", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter),
    __metadata("design:paramtypes", [])
], IgxGeographicScatterAreaSeriesComponent.prototype, "triangulationStatusChanged", null);
IgxGeographicScatterAreaSeriesComponent = IgxGeographicScatterAreaSeriesComponent_1 = __decorate([
    Component({
        selector: 'igx-geographic-scatter-area-series',
        template: ``,
        providers: [{ provide: IgxGeographicXYTriangulatingSeriesComponent, useExisting: forwardRef(() => IgxGeographicScatterAreaSeriesComponent_1) }, { provide: IgxGeographicMapSeriesHostComponent, useExisting: forwardRef(() => IgxGeographicScatterAreaSeriesComponent_1) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxGeographicScatterAreaSeriesComponent_1) }],
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [])
], IgxGeographicScatterAreaSeriesComponent);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxGeographicScatterAreaSeriesModule = class IgxGeographicScatterAreaSeriesModule {
};
IgxGeographicScatterAreaSeriesModule = __decorate([
    NgModule({
        declarations: [IgxGeographicScatterAreaSeriesComponent],
        imports: [CommonModule, IgxScatterAreaSeriesDynamicModule],
        exports: [IgxGeographicScatterAreaSeriesComponent, IgxScatterAreaSeriesDynamicModule],
        entryComponents: []
    })
], IgxGeographicScatterAreaSeriesModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxGeographicScatterAreaSeriesDynamicModule = class IgxGeographicScatterAreaSeriesDynamicModule {
    constructor() {
        TypeRegistrar.registerCons("IgxGeographicScatterAreaSeriesComponent", IgxGeographicScatterAreaSeriesComponent);
        TypeRegistrar.register("GeographicScatterAreaSeries", GeographicScatterAreaSeries.$type);
    }
};
IgxGeographicScatterAreaSeriesDynamicModule = __decorate([
    NgModule({
        declarations: [],
        imports: [CommonModule, IgxGeographicScatterAreaSeriesModule],
        exports: [IgxGeographicScatterAreaSeriesModule],
        entryComponents: [IgxGeographicScatterAreaSeriesComponent]
    }),
    __metadata("design:paramtypes", [])
], IgxGeographicScatterAreaSeriesDynamicModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class GeographicHighDensityScatterSeriesView extends HostSeriesView {
    constructor(a) {
        super(a);
        this.b0 = null;
        this.b0 = a;
    }
    bv() {
        super.bv();
        let a = typeCast(HighDensityScatterSeries.$, this.b0.l3);
        a.n4 = this.b0.ms;
        a.n8 = this.b0.mq;
        a.mo = this.b0.mf;
        a.mn = this.b0.me;
        a.c7 = this.b0.md;
        a.ng = this.b0.mh;
        a.nf = this.b0.mg;
    }
    b6() {
        this.b0.l3.n4 = this.b0.ms;
    }
    b5() {
        this.b0.l3.n8 = this.b0.mq;
    }
    cb() {
        this.b0.l3.mo = this.b0.mf;
    }
    b9() {
        this.b0.l3.mn = this.b0.me;
    }
    b7() {
        this.b0.l3.c7 = this.b0.md;
    }
    b4() {
        this.b0.l3.ng = this.b0.mh;
    }
    b2() {
        this.b0.l3.nf = this.b0.mg;
    }
    ca() {
        let a = typeCast(HighDensityScatterSeries.$, this.b0.l3);
        if (this.b0.bs == null) {
            a.l8 = null;
            a.ma = null;
            return;
        }
        a.l8 = this.b0.bs.nc;
        a.ma = this.b0.bs.ne;
    }
    cc() {
        this.b0.l3.l8 = this.b0.bs.nc;
    }
    cd() {
        this.b0.l3.ma = this.b0.bs.ne;
    }
    b3() {
        this.b0.l3.o1 = this.b0.na;
    }
    b1() {
        this.b0.l3.o0 = this.b0.m9;
    }
    b8() {
        this.b0.l3.ns = this.b0.mk;
    }
}
GeographicHighDensityScatterSeriesView.$t = markType(GeographicHighDensityScatterSeriesView, 'GeographicHighDensityScatterSeriesView', HostSeriesView.$);
/**
 * @hidden
 */
class GeographicHighDensityScatterSeries extends GeographicMapSeriesHost {
    constructor() {
        super();
        this.mb = null;
        this.progressiveLoadStatusChanged = null;
        this.mj = 0;
        this.ab = GeographicHighDensityScatterSeries.$;
    }
    bf() {
        return new GeographicHighDensityScatterSeriesView(this);
    }
    iv(a) {
        super.iv(a);
        this.mc = a;
    }
    l2() {
        return new HighDensityScatterSeries();
    }
    get ml() {
        return this.mj;
    }
    set ml(a) {
        let b = this.mj;
        this.mj = a;
        this.raisePropertyChanged("ProgressiveStatus", b, this.mj);
    }
    l8() {
        super.l8();
        let a = this.l3;
        a.progressiveLoadStatusChanged = delegateCombine(a.progressiveLoadStatusChanged, runOn(this, this.my));
    }
    my(a, b) {
        this.ml = b.currentStatus;
        if (this.progressiveLoadStatusChanged != null) {
            this.progressiveLoadStatusChanged(this, b);
        }
    }
    i0(a, b, c, d) {
        super.i0(a, b, c, d);
        switch (b) {
            case "SeriesViewer":
                this.mc.ca();
                break;
            case GeographicHighDensityScatterSeries.$$p[5]:
                this.mc.b6();
                break;
            case GeographicHighDensityScatterSeries.$$p[4]:
                this.mc.b5();
                break;
            case GeographicHighDensityScatterSeries.$$p[9]:
                this.mc.cb();
                break;
            case GeographicHighDensityScatterSeries.$$p[8]:
                this.mc.b9();
                break;
            case GeographicHighDensityScatterSeries.$$p[6]:
                this.mc.b7();
                break;
            case "XAxis":
                this.mc.cc();
                break;
            case "YAxis":
                this.mc.cd();
                break;
            case GeographicHighDensityScatterSeries.$$p[3]:
                this.mc.b4();
                break;
            case GeographicHighDensityScatterSeries.$$p[1]:
                this.mc.b2();
                break;
            case GeographicHighDensityScatterSeries.$$p[2]:
                this.mc.b3();
                break;
            case GeographicHighDensityScatterSeries.$$p[0]:
                this.mc.b1();
                break;
            case GeographicHighDensityScatterSeries.$$p[7]:
                this.mc.b8();
                break;
        }
    }
    get_dq() {
        return true;
    }
    set_dq(a) {
        super.set_dq(a);
    }
}
GeographicHighDensityScatterSeries.$t = markType(GeographicHighDensityScatterSeries, 'GeographicHighDensityScatterSeries', GeographicMapSeriesHost.$);
GeographicHighDensityScatterSeries.$$p = markDep(DependencyProperty, PropertyMetadata, GeographicHighDensityScatterSeries, 'raisePropertyChanged', ['HeatMaximumColor:m9:mz', [Color.$, null], 'HeatMaximum:mg:m0', [1, 50], 'HeatMinimumColor:na:m1', [Color.$, null], 'HeatMinimum:mh:m2', [1, 0], 'LatitudeMemberPath:mq:m3', [2, null], 'LongitudeMemberPath:ms:m4', [2, null], 'MouseOverEnabled:md:m5', [0, false], 'PointExtent:mk:m6', [1, 1], 'ProgressiveLoad:me:m7', [0, true], 'UseBruteForce:mf:m8', [0, false]]);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

var IgxGeographicHighDensityScatterSeriesComponent_1;
/**
 * Series class for a geographic map with points marked at given locations.
 * This is the geographic equivalent of a HighDensityScatterSeries.
*/
const IgxGeographicHighDensityScatterSeriesComponent_PROVIDERS = [{ provide: IgxGeographicMapSeriesHostComponent, useExisting: forwardRef(() => IgxGeographicHighDensityScatterSeriesComponent) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxGeographicHighDensityScatterSeriesComponent) }];
let IgxGeographicHighDensityScatterSeriesComponent = IgxGeographicHighDensityScatterSeriesComponent_1 = class IgxGeographicHighDensityScatterSeriesComponent extends IgxGeographicMapSeriesHostComponent {
    constructor() {
        super();
        this._progressiveLoadStatusChanged = null;
    }
    createImplementation() {
        return new GeographicHighDensityScatterSeries();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * The name of the property of ItemsSource items which contains the latitude coordinate of the symbol.
    */
    get latitudeMemberPath() {
        return this.i.mq;
    }
    set latitudeMemberPath(v) {
        this.i.mq = v;
    }
    /**
     * The name of the property of ItemsSource items which contains the longitude coordinate of the symbol.
    */
    get longitudeMemberPath() {
        return this.i.ms;
    }
    set longitudeMemberPath(v) {
        this.i.ms = v;
    }
    /**
     * Gets or sets the whether to use use brute force mode.
    */
    get useBruteForce() {
        return this.i.mf;
    }
    set useBruteForce(v) {
        this.i.mf = ensureBool(v);
    }
    /**
     * Gets or sets the whether to progressively load the data into the chart.
    */
    get progressiveLoad() {
        return this.i.me;
    }
    set progressiveLoad(v) {
        this.i.me = ensureBool(v);
    }
    /**
     * Gets or sets the whether the chart reacts to mouse move events.
    */
    get mouseOverEnabled() {
        return this.i.md;
    }
    set mouseOverEnabled(v) {
        this.i.md = ensureBool(v);
    }
    /**
     * Gets or sets the density value that maps to the minimum heat color.
    */
    get heatMinimum() {
        return this.i.mh;
    }
    set heatMinimum(v) {
        this.i.mh = +v;
    }
    /**
     * Gets or sets the value that maps to the maximum heat color.
    */
    get heatMaximum() {
        return this.i.mg;
    }
    set heatMaximum(v) {
        this.i.mg = +v;
    }
    /**
     * Gets or sets the color to use for the minimum end of the scale.
    */
    get heatMinimumColor() {
        return colorToString(this.i.na);
    }
    set heatMinimumColor(v) {
        this.i.na = stringToColor(v);
    }
    /**
     * Gets or sets the color to use for the maximum end of the scale.
    */
    get heatMaximumColor() {
        return colorToString(this.i.m9);
    }
    set heatMaximumColor(v) {
        this.i.m9 = stringToColor(v);
    }
    /**
     * Gets or sets the the pixel extent of the square data points that are rendered.
    */
    get pointExtent() {
        return this.i.mk;
    }
    set pointExtent(v) {
        this.i.mk = +v;
    }
    /**
     * Represents the current status of the progressive load of the series. It will range from 0 to 100, where 100 is fully loaded.
    */
    get progressiveStatus() {
        return this.i.ml;
    }
    set progressiveStatus(v) {
        this.i.ml = +v;
    }
    /**
     * Raised when the progressive loading state of the series has changed.
    */
    get progressiveLoadStatusChanged() {
        if (this._progressiveLoadStatusChanged == null) {
            this._progressiveLoadStatusChanged = new EventEmitter();
            this.i.progressiveLoadStatusChanged = delegateCombine(this.i.progressiveLoadStatusChanged, (o, e) => {
                this._runInZone(() => {
                    let outerArgs = new IgxProgressiveLoadStatusEventArgs();
                    outerArgs._provideImplementation(e);
                    if (this.beforeProgressiveLoadStatusChanged) {
                        this.beforeProgressiveLoadStatusChanged(this, outerArgs);
                    }
                    this._progressiveLoadStatusChanged.emit({
                        sender: this,
                        args: outerArgs
                    });
                });
            });
        }
        return this._progressiveLoadStatusChanged;
    }
};
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicHighDensityScatterSeriesComponent.prototype, "latitudeMemberPath", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicHighDensityScatterSeriesComponent.prototype, "longitudeMemberPath", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], IgxGeographicHighDensityScatterSeriesComponent.prototype, "useBruteForce", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], IgxGeographicHighDensityScatterSeriesComponent.prototype, "progressiveLoad", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], IgxGeographicHighDensityScatterSeriesComponent.prototype, "mouseOverEnabled", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicHighDensityScatterSeriesComponent.prototype, "heatMinimum", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicHighDensityScatterSeriesComponent.prototype, "heatMaximum", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicHighDensityScatterSeriesComponent.prototype, "heatMinimumColor", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicHighDensityScatterSeriesComponent.prototype, "heatMaximumColor", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicHighDensityScatterSeriesComponent.prototype, "pointExtent", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], IgxGeographicHighDensityScatterSeriesComponent.prototype, "progressiveStatus", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter),
    __metadata("design:paramtypes", [])
], IgxGeographicHighDensityScatterSeriesComponent.prototype, "progressiveLoadStatusChanged", null);
IgxGeographicHighDensityScatterSeriesComponent = IgxGeographicHighDensityScatterSeriesComponent_1 = __decorate([
    Component({
        selector: 'igx-geographic-high-density-scatter-series',
        template: ``,
        providers: [{ provide: IgxGeographicMapSeriesHostComponent, useExisting: forwardRef(() => IgxGeographicHighDensityScatterSeriesComponent_1) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxGeographicHighDensityScatterSeriesComponent_1) }],
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [])
], IgxGeographicHighDensityScatterSeriesComponent);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxGeographicHighDensityScatterSeriesModule = class IgxGeographicHighDensityScatterSeriesModule {
};
IgxGeographicHighDensityScatterSeriesModule = __decorate([
    NgModule({
        declarations: [IgxGeographicHighDensityScatterSeriesComponent],
        imports: [CommonModule, IgxHighDensityScatterSeriesDynamicModule],
        exports: [IgxGeographicHighDensityScatterSeriesComponent, IgxHighDensityScatterSeriesDynamicModule],
        entryComponents: []
    })
], IgxGeographicHighDensityScatterSeriesModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxGeographicHighDensityScatterSeriesDynamicModule = class IgxGeographicHighDensityScatterSeriesDynamicModule {
    constructor() {
        TypeRegistrar.registerCons("IgxGeographicHighDensityScatterSeriesComponent", IgxGeographicHighDensityScatterSeriesComponent);
        TypeRegistrar.register("GeographicHighDensityScatterSeries", GeographicHighDensityScatterSeries.$type);
    }
};
IgxGeographicHighDensityScatterSeriesDynamicModule = __decorate([
    NgModule({
        declarations: [],
        imports: [CommonModule, IgxGeographicHighDensityScatterSeriesModule],
        exports: [IgxGeographicHighDensityScatterSeriesModule],
        entryComponents: [IgxGeographicHighDensityScatterSeriesComponent]
    }),
    __metadata("design:paramtypes", [])
], IgxGeographicHighDensityScatterSeriesDynamicModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class GeographicContourLineSeriesView extends GeographicXYTriangulatingSeriesView {
    constructor(a) {
        super(a);
        this.b8 = null;
        this.b8 = a;
    }
    bv() {
        super.bv();
        if (this.b8.l3 != null) {
            this.b8.mv.nl = this.b8.mx;
            this.b8.mv.nq = this.b8.m0;
        }
    }
    b9() {
        if (this.b8.mv != null) {
            this.b8.mv.nl = this.b8.mx;
        }
    }
    ca() {
        if (this.b8.mv != null) {
            this.b8.mv.nq = this.b8.m0;
        }
    }
}
GeographicContourLineSeriesView.$t = markType(GeographicContourLineSeriesView, 'GeographicContourLineSeriesView', GeographicXYTriangulatingSeriesView.$);
/**
 * @hidden
 */
class GeographicContourLineSeries extends GeographicXYTriangulatingSeries {
    constructor() {
        super();
        this.triangulationStatusChanged = null;
        this.ab = GeographicContourLineSeries.$;
    }
    l8() {
        super.l8();
    }
    l2() {
        this.mv = new ScatterContourSeries();
        let a = this.mv;
        a.triangulationStatusChanged = delegateCombine(a.triangulationStatusChanged, runOn(this, this.m3));
        return this.mv;
    }
    m3(a, b) {
        if (this.triangulationStatusChanged != null) {
            this.triangulationStatusChanged(this, b);
        }
    }
    bf() {
        return new GeographicContourLineSeriesView(this);
    }
    iv(a) {
        super.iv(a);
        this.my = a;
    }
    i0(a, b, c, d) {
        super.i0(a, b, c, d);
        switch (b) {
            case GeographicContourLineSeries.$$p[0]:
                this.my.b9();
                break;
            case GeographicContourLineSeries.$$p[1]:
                this.my.ca();
                break;
            case GeographicContourLineSeries.$$p[2]:
                this.mv.nj = this.mu;
                break;
            case "Thickness":
                this.mv.ey = this.ey;
                break;
            case "DashArray":
                this.mv.lc = this.lc;
                break;
            case "DashCap":
                this.mv.ld = this.ld;
                break;
            case "MiterLimit":
                this.mv.es = this.es;
                break;
        }
    }
}
GeographicContourLineSeries.$t = markType(GeographicContourLineSeries, 'GeographicContourLineSeries', GeographicXYTriangulatingSeries.$);
GeographicContourLineSeries.$$p = markDep(DependencyProperty, PropertyMetadata, GeographicContourLineSeries, 'raisePropertyChanged', ['FillScale:mx:m4', [ValueBrushScale.$, null], 'ValueMemberPath:m0:m5', [2, "value"], 'ValueResolver:mu:m6', [ContourValueResolver.$, null]]);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

var IgxGeographicContourLineSeriesComponent_1;
/**
 * Represents a class for Geographic Contour Series displayed on a map.
*/
const IgxGeographicContourLineSeriesComponent_PROVIDERS = [{ provide: IgxGeographicXYTriangulatingSeriesComponent, useExisting: forwardRef(() => IgxGeographicContourLineSeriesComponent) }, { provide: IgxGeographicMapSeriesHostComponent, useExisting: forwardRef(() => IgxGeographicContourLineSeriesComponent) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxGeographicContourLineSeriesComponent) }];
let IgxGeographicContourLineSeriesComponent = IgxGeographicContourLineSeriesComponent_1 = class IgxGeographicContourLineSeriesComponent extends IgxGeographicXYTriangulatingSeriesComponent {
    constructor() {
        super();
        this._triangulationStatusChanged = null;
    }
    createImplementation() {
        return new GeographicContourLineSeries();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * The name of the property from which to retrieve the numeric values from the ItemsSource items.
    */
    get valueMemberPath() {
        return this.i.m0;
    }
    set valueMemberPath(v) {
        this.i.m0 = v;
    }
    /**
     * The ValueBrushScale to use when determining Brushes for each contour line, based on the values found in ValueMemberPath.
    */
    get fillScale() {
        if (this.i.mx == null) {
            return null;
        }
        if (!this.i.mx.externalObject) {
            let e = IgxValueBrushScaleComponent._createFromInternal(this.i.mx);
            if (e) {
                e._implementation = this.i.mx;
            }
            this.i.mx.externalObject = e;
        }
        return this.i.mx.externalObject;
    }
    set fillScale(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.mx = null : this.i.mx = v.i;
    }
    /**
     * The ContourValueResolver used to determine the numeric values of contours.
    */
    get valueResolver() {
        if (this.i.mu == null) {
            return null;
        }
        if (!this.i.mu.externalObject) {
            let e = IgxContourValueResolverComponent._createFromInternal(this.i.mu);
            if (e) {
                e._implementation = this.i.mu;
            }
            this.i.mu.externalObject = e;
        }
        return this.i.mu.externalObject;
    }
    set valueResolver(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.mu = null : this.i.mu = v.i;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.fillScale && this.fillScale.name && this.fillScale.name == name) {
            return this.fillScale;
        }
        if (this.valueResolver && this.valueResolver.name && this.valueResolver.name == name) {
            return this.valueResolver;
        }
        return null;
    }
    _styling(container, component, parent) {
        super._styling(container, component, parent);
        this._inStyling = true;
        if (this.fillScale && this.fillScale._styling) {
            this.fillScale._styling(container, component, this);
        }
        if (this.valueResolver && this.valueResolver._styling) {
            this.valueResolver._styling(container, component, this);
        }
        this._inStyling = false;
    }
    /**
     * Raised when the status of an ongoing Triangulation has changed.
    */
    get triangulationStatusChanged() {
        if (this._triangulationStatusChanged == null) {
            this._triangulationStatusChanged = new EventEmitter();
            this.i.triangulationStatusChanged = delegateCombine(this.i.triangulationStatusChanged, (o, e) => {
                this._runInZone(() => {
                    let outerArgs = new IgxTriangulationStatusEventArgs();
                    outerArgs._provideImplementation(e);
                    if (this.beforeTriangulationStatusChanged) {
                        this.beforeTriangulationStatusChanged(this, outerArgs);
                    }
                    this._triangulationStatusChanged.emit({
                        sender: this,
                        args: outerArgs
                    });
                });
            });
        }
        return this._triangulationStatusChanged;
    }
};
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], IgxGeographicContourLineSeriesComponent.prototype, "valueMemberPath", null);
__decorate([
    Input(),
    __metadata("design:type", IgxValueBrushScaleComponent),
    __metadata("design:paramtypes", [IgxValueBrushScaleComponent])
], IgxGeographicContourLineSeriesComponent.prototype, "fillScale", null);
__decorate([
    Input(),
    __metadata("design:type", IgxContourValueResolverComponent),
    __metadata("design:paramtypes", [IgxContourValueResolverComponent])
], IgxGeographicContourLineSeriesComponent.prototype, "valueResolver", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter),
    __metadata("design:paramtypes", [])
], IgxGeographicContourLineSeriesComponent.prototype, "triangulationStatusChanged", null);
IgxGeographicContourLineSeriesComponent = IgxGeographicContourLineSeriesComponent_1 = __decorate([
    Component({
        selector: 'igx-geographic-contour-line-series',
        template: ``,
        providers: [{ provide: IgxGeographicXYTriangulatingSeriesComponent, useExisting: forwardRef(() => IgxGeographicContourLineSeriesComponent_1) }, { provide: IgxGeographicMapSeriesHostComponent, useExisting: forwardRef(() => IgxGeographicContourLineSeriesComponent_1) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxGeographicContourLineSeriesComponent_1) }],
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [])
], IgxGeographicContourLineSeriesComponent);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxGeographicContourLineSeriesModule = class IgxGeographicContourLineSeriesModule {
};
IgxGeographicContourLineSeriesModule = __decorate([
    NgModule({
        declarations: [IgxGeographicContourLineSeriesComponent],
        imports: [CommonModule, IgxScatterContourSeriesDynamicModule],
        exports: [IgxGeographicContourLineSeriesComponent, IgxScatterContourSeriesDynamicModule],
        entryComponents: []
    })
], IgxGeographicContourLineSeriesModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxGeographicContourLineSeriesDynamicModule = class IgxGeographicContourLineSeriesDynamicModule {
    constructor() {
        TypeRegistrar.registerCons("IgxGeographicContourLineSeriesComponent", IgxGeographicContourLineSeriesComponent);
        TypeRegistrar.register("GeographicContourLineSeries", GeographicContourLineSeries.$type);
    }
};
IgxGeographicContourLineSeriesDynamicModule = __decorate([
    NgModule({
        declarations: [],
        imports: [CommonModule, IgxGeographicContourLineSeriesModule],
        exports: [IgxGeographicContourLineSeriesModule],
        entryComponents: [IgxGeographicContourLineSeriesComponent]
    }),
    __metadata("design:paramtypes", [])
], IgxGeographicContourLineSeriesDynamicModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxGeographicMapModule = class IgxGeographicMapModule {
};
IgxGeographicMapModule = __decorate([
    NgModule({
        declarations: [],
        exports: [IgxGeographicShapeSeriesModule,
            IgxGeographicPolylineSeriesModule,
            IgxTileGeneratorMapImageryModule,
            IgxHeatTileGeneratorModule,
            IgxGeographicTileSeriesModule,
            IgxSizeScaleModule,
            IgxValueBrushScaleModule,
            IgxCustomPaletteColorScaleModule,
            IgxGeographicProportionalSymbolSeriesModule,
            IgxGeographicSymbolSeriesModule,
            IgxGeographicScatterAreaSeriesModule,
            IgxGeographicHighDensityScatterSeriesModule,
            IgxGeographicContourLineSeriesModule,
            IgxGeographicMapCoreModule,
            IgxShapeDataSourceModule
        ],
        imports: [CommonModule, IgxGeographicShapeSeriesModule,
            IgxGeographicPolylineSeriesModule,
            IgxTileGeneratorMapImageryModule,
            IgxHeatTileGeneratorModule,
            IgxGeographicTileSeriesModule,
            IgxSizeScaleModule,
            IgxValueBrushScaleModule,
            IgxCustomPaletteColorScaleModule,
            IgxGeographicProportionalSymbolSeriesModule,
            IgxGeographicSymbolSeriesModule,
            IgxGeographicScatterAreaSeriesModule,
            IgxGeographicHighDensityScatterSeriesModule,
            IgxGeographicContourLineSeriesModule,
            IgxGeographicMapCoreModule,
            IgxShapeDataSourceModule
        ],
        entryComponents: []
    })
], IgxGeographicMapModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
let IgxGeographicMapDynamicModule = class IgxGeographicMapDynamicModule {
};
IgxGeographicMapDynamicModule = __decorate([
    NgModule({
        declarations: [],
        exports: [IgxGeographicShapeSeriesDynamicModule,
            IgxGeographicPolylineSeriesDynamicModule,
            IgxTileGeneratorMapImageryDynamicModule,
            IgxHeatTileGeneratorDynamicModule,
            IgxGeographicTileSeriesDynamicModule,
            IgxSizeScaleDynamicModule,
            IgxValueBrushScaleDynamicModule,
            IgxCustomPaletteColorScaleDynamicModule,
            IgxGeographicProportionalSymbolSeriesDynamicModule,
            IgxGeographicSymbolSeriesDynamicModule,
            IgxGeographicScatterAreaSeriesDynamicModule,
            IgxGeographicHighDensityScatterSeriesDynamicModule,
            IgxGeographicContourLineSeriesDynamicModule,
            IgxGeographicMapCoreDynamicModule,
            IgxShapeDataSourceDynamicModule,
            IgxGeographicMapModule
        ],
        imports: [CommonModule, IgxGeographicShapeSeriesDynamicModule,
            IgxGeographicPolylineSeriesDynamicModule,
            IgxTileGeneratorMapImageryDynamicModule,
            IgxHeatTileGeneratorDynamicModule,
            IgxGeographicTileSeriesDynamicModule,
            IgxSizeScaleDynamicModule,
            IgxValueBrushScaleDynamicModule,
            IgxCustomPaletteColorScaleDynamicModule,
            IgxGeographicProportionalSymbolSeriesDynamicModule,
            IgxGeographicSymbolSeriesDynamicModule,
            IgxGeographicScatterAreaSeriesDynamicModule,
            IgxGeographicHighDensityScatterSeriesDynamicModule,
            IgxGeographicContourLineSeriesDynamicModule,
            IgxGeographicMapCoreDynamicModule,
            IgxShapeDataSourceDynamicModule,
            IgxGeographicMapModule
        ],
        entryComponents: []
    })
], IgxGeographicMapDynamicModule);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class TokenResponseModel extends Base {
    constructor() {
        super(...arguments);
        this._token = null;
        this._expires = 0;
        this._ssl = false;
    }
    get token() {
        return this._token;
    }
    set token(a) {
        this._token = a;
    }
    get expires() {
        return this._expires;
    }
    set expires(a) {
        this._expires = a;
    }
    get ssl() {
        return this._ssl;
    }
    set ssl(a) {
        this._ssl = a;
    }
}
TokenResponseModel.$t = markType(TokenResponseModel, 'TokenResponseModel');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class MapServerResponseModel extends Base {
    constructor() {
        super(...arguments);
        this._name = null;
        this._tileInfo = null;
    }
    get name() {
        return this._name;
    }
    set name(a) {
        this._name = a;
    }
    get tileInfo() {
        return this._tileInfo;
    }
    set tileInfo(a) {
        this._tileInfo = a;
    }
}
MapServerResponseModel.$t = markType(MapServerResponseModel, 'MapServerResponseModel');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class TileInfoResponseModel extends Base {
    constructor() {
        super(...arguments);
        this._lods = null;
    }
    get lods() {
        return this._lods;
    }
    set lods(a) {
        this._lods = a;
    }
}
TileInfoResponseModel.$t = markType(TileInfoResponseModel, 'TileInfoResponseModel');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class LevelOfDetailResponseModel extends Base {
    constructor() {
        super(...arguments);
        this._level = 0;
        this._resolution = 0;
        this._scale = 0;
    }
    get level() {
        return this._level;
    }
    set level(a) {
        this._level = a;
    }
    get resolution() {
        return this._resolution;
    }
    set resolution(a) {
        this._resolution = a;
    }
    get scale() {
        return this._scale;
    }
    set scale(a) {
        this._scale = a;
    }
}
LevelOfDetailResponseModel.$t = markType(LevelOfDetailResponseModel, 'LevelOfDetailResponseModel');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class GeographicProportionalSymbolSeriesBaseView extends HostSeriesView {
    constructor(a) {
        super(a);
        this.b0 = null;
        this.b0 = a;
    }
}
GeographicProportionalSymbolSeriesBaseView.$t = markType(GeographicProportionalSymbolSeriesBaseView, 'GeographicProportionalSymbolSeriesBaseView', HostSeriesView.$);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class GeographicShapeSeriesBaseBaseView extends HostSeriesView {
    constructor(a) {
        super(a);
        this.b0 = null;
        this.b0 = a;
    }
}
GeographicShapeSeriesBaseBaseView.$t = markType(GeographicShapeSeriesBaseBaseView, 'GeographicShapeSeriesBaseBaseView', HostSeriesView.$);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class GeographicSymbolSeriesBaseView extends HostSeriesView {
    constructor(a) {
        super(a);
        this.b0 = null;
        this.b0 = a;
    }
}
GeographicSymbolSeriesBaseView.$t = markType(GeographicSymbolSeriesBaseView, 'GeographicSymbolSeriesBaseView', HostSeriesView.$);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class GeographicXYTriangulatingSeriesBaseView extends HostSeriesView {
    constructor(a) {
        super(a);
        this.b0 = null;
        this.b0 = a;
    }
}
GeographicXYTriangulatingSeriesBaseView.$t = markType(GeographicXYTriangulatingSeriesBaseView, 'GeographicXYTriangulatingSeriesBaseView', HostSeriesView.$);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class ImageryMetadata extends Base {
    constructor() {
        super();
        this.b = null;
        this.a = null;
        this.a = new List$1(String_$type, 0);
    }
}
ImageryMetadata.$t = markType(ImageryMetadata, 'ImageryMetadata');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class BingResourceSet extends Base {
    constructor() {
        super();
        this.a = null;
        this.a = new List$1(ImageryMetadata.$, 0);
    }
}
BingResourceSet.$t = markType(BingResourceSet, 'BingResourceSet');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class BingResponse extends Base {
    constructor() {
        super();
        this.a = null;
        this.a = new List$1(BingResourceSet.$, 0);
    }
}
BingResponse.$t = markType(BingResponse, 'BingResponse');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class GeographicProportionalSymbolSeriesBase extends GeographicMapSeriesHost {
}
GeographicProportionalSymbolSeriesBase.$t = markType(GeographicProportionalSymbolSeriesBase, 'GeographicProportionalSymbolSeriesBase', GeographicMapSeriesHost.$);

const IgxGeographicProportionalSymbolSeriesBaseComponent_PROVIDERS = [{ provide: IgxGeographicMapSeriesHostComponent, useExisting: forwardRef(() => IgxGeographicProportionalSymbolSeriesBaseComponent) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxGeographicProportionalSymbolSeriesBaseComponent) }];
class IgxGeographicProportionalSymbolSeriesBaseComponent extends IgxGeographicMapSeriesHostComponent {
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor() {
        super();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class GeographicShapeSeriesBaseBase extends GeographicMapSeriesHost {
}
GeographicShapeSeriesBaseBase.$t = markType(GeographicShapeSeriesBaseBase, 'GeographicShapeSeriesBaseBase', GeographicMapSeriesHost.$);

const IgxGeographicShapeSeriesBaseBaseComponent_PROVIDERS = [{ provide: IgxGeographicMapSeriesHostComponent, useExisting: forwardRef(() => IgxGeographicShapeSeriesBaseBaseComponent) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxGeographicShapeSeriesBaseBaseComponent) }];
class IgxGeographicShapeSeriesBaseBaseComponent extends IgxGeographicMapSeriesHostComponent {
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor() {
        super();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class GeographicSymbolSeriesBase extends GeographicMapSeriesHost {
}
GeographicSymbolSeriesBase.$t = markType(GeographicSymbolSeriesBase, 'GeographicSymbolSeriesBase', GeographicMapSeriesHost.$);

const IgxGeographicSymbolSeriesBaseComponent_PROVIDERS = [{ provide: IgxGeographicMapSeriesHostComponent, useExisting: forwardRef(() => IgxGeographicSymbolSeriesBaseComponent) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxGeographicSymbolSeriesBaseComponent) }];
class IgxGeographicSymbolSeriesBaseComponent extends IgxGeographicMapSeriesHostComponent {
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor() {
        super();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
class GeographicXYTriangulatingSeriesBase extends GeographicMapSeriesHost {
}
GeographicXYTriangulatingSeriesBase.$t = markType(GeographicXYTriangulatingSeriesBase, 'GeographicXYTriangulatingSeriesBase', GeographicMapSeriesHost.$);

const IgxGeographicXYTriangulatingSeriesBaseComponent_PROVIDERS = [{ provide: IgxGeographicMapSeriesHostComponent, useExisting: forwardRef(() => IgxGeographicXYTriangulatingSeriesBaseComponent) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxGeographicXYTriangulatingSeriesBaseComponent) }];
class IgxGeographicXYTriangulatingSeriesBaseComponent extends IgxGeographicMapSeriesHostComponent {
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor() {
        super();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/**
 * Generated bundle index. Do not edit.
 */

export { ArcGISOnlineMapImagery, BingMapsImageryStyle, BingMapsImageryStyle_$type, BingMapsMapImagery, BingMapsMapImageryView, BingResourceSet, BingResponse, CustomMapImagery, GeographicContourLineSeries, GeographicContourLineSeriesView, GeographicHighDensityScatterSeries, GeographicHighDensityScatterSeriesView, GeographicMapImagery, GeographicMapImageryView, GeographicMapSeriesHost, GeographicPolylineSeries, GeographicPolylineSeriesView, GeographicProportionalSymbolSeries, GeographicProportionalSymbolSeriesBase, GeographicProportionalSymbolSeriesBaseView, GeographicProportionalSymbolSeriesView, GeographicScatterAreaSeries, GeographicScatterAreaSeriesView, GeographicShapeSeries, GeographicShapeSeriesBase, GeographicShapeSeriesBaseBase, GeographicShapeSeriesBaseBaseView, GeographicShapeSeriesBaseView, GeographicShapeSeriesView, GeographicSymbolSeries, GeographicSymbolSeriesBase, GeographicSymbolSeriesBaseView, GeographicSymbolSeriesView, GeographicTileSeries, GeographicXYTriangulatingSeries, GeographicXYTriangulatingSeriesBase, GeographicXYTriangulatingSeriesBaseView, GeographicXYTriangulatingSeriesView, HostSeriesView, IgxArcGISOnlineMapImagery, IgxArcGISOnlineMapImageryDynamicModule, IgxArcGISOnlineMapImageryModule, IgxBingMapsMapImagery, IgxBingMapsMapImageryDynamicModule, IgxBingMapsMapImageryModule, IgxCustomMapImagery, IgxCustomMapImageryDynamicModule, IgxCustomMapImageryModule, IgxGeographicContourLineSeriesComponent, IgxGeographicContourLineSeriesComponent_PROVIDERS, IgxGeographicContourLineSeriesDynamicModule, IgxGeographicContourLineSeriesModule, IgxGeographicHighDensityScatterSeriesComponent, IgxGeographicHighDensityScatterSeriesComponent_PROVIDERS, IgxGeographicHighDensityScatterSeriesDynamicModule, IgxGeographicHighDensityScatterSeriesModule, IgxGeographicMapComponent, IgxGeographicMapComponent_PROVIDERS, IgxGeographicMapCoreDynamicModule, IgxGeographicMapCoreModule, IgxGeographicMapDynamicModule, IgxGeographicMapImagery, IgxGeographicMapModule, IgxGeographicMapSeriesHostComponent, IgxGeographicMapSeriesHostComponent_PROVIDERS, IgxGeographicPolylineSeriesComponent, IgxGeographicPolylineSeriesComponent_PROVIDERS, IgxGeographicPolylineSeriesDynamicModule, IgxGeographicPolylineSeriesModule, IgxGeographicProportionalSymbolSeriesBaseComponent, IgxGeographicProportionalSymbolSeriesBaseComponent_PROVIDERS, IgxGeographicProportionalSymbolSeriesComponent, IgxGeographicProportionalSymbolSeriesComponent_PROVIDERS, IgxGeographicProportionalSymbolSeriesDynamicModule, IgxGeographicProportionalSymbolSeriesModule, IgxGeographicScatterAreaSeriesComponent, IgxGeographicScatterAreaSeriesComponent_PROVIDERS, IgxGeographicScatterAreaSeriesDynamicModule, IgxGeographicScatterAreaSeriesModule, IgxGeographicShapeSeriesBaseBaseComponent, IgxGeographicShapeSeriesBaseBaseComponent_PROVIDERS, IgxGeographicShapeSeriesBaseComponent, IgxGeographicShapeSeriesBaseComponent_PROVIDERS, IgxGeographicShapeSeriesComponent, IgxGeographicShapeSeriesComponent_PROVIDERS, IgxGeographicShapeSeriesDynamicModule, IgxGeographicShapeSeriesModule, IgxGeographicSymbolSeriesBaseComponent, IgxGeographicSymbolSeriesBaseComponent_PROVIDERS, IgxGeographicSymbolSeriesComponent, IgxGeographicSymbolSeriesComponent_PROVIDERS, IgxGeographicSymbolSeriesDynamicModule, IgxGeographicSymbolSeriesModule, IgxGeographicTileSeriesComponent, IgxGeographicTileSeriesComponent_PROVIDERS, IgxGeographicTileSeriesDynamicModule, IgxGeographicTileSeriesModule, IgxGeographicXYTriangulatingSeriesBaseComponent, IgxGeographicXYTriangulatingSeriesBaseComponent_PROVIDERS, IgxGeographicXYTriangulatingSeriesComponent, IgxGeographicXYTriangulatingSeriesComponent_PROVIDERS, IgxImageTilesReadyEventArgs, IgxImagesChangedEventArgs, IgxOpenStreetMapImagery, IgxOpenStreetMapImageryDynamicModule, IgxOpenStreetMapImageryModule, IgxSubDomainsCollection, IgxTileGeneratorMapImagery, IgxTileGeneratorMapImageryDynamicModule, IgxTileGeneratorMapImageryModule, IgxTileSeriesComponent, IgxTileSeriesComponent_PROVIDERS, IgxTileSeriesDynamicModule, IgxTileSeriesModule, ImageTilesReadyEventArgs, ImageryMetadata, ImagesChangedEventArgs, LevelOfDetailResponseModel, MapResizeBehavior, MapResizeBehavior_$type, MapServerResponseModel, OpenStreetMapImagery, SphericalMercatorHorizontalScaler, SphericalMercatorVerticalScaler, SubDomainsCollection, TileGeneratorMapImagery, TileInfoResponseModel, TileSeries, TileSeriesView, TokenResponseModel, XamGeographicMap, XamGeographicMapView };
//# sourceMappingURL=igniteui-angular-maps.js.map
