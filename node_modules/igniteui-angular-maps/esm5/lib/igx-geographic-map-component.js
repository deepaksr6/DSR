/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import * as tslib_1 from "tslib";
import { EventEmitter, Output, Injector, ComponentFactoryResolver, Component, Renderer2, ViewChild, ContentChildren, QueryList, Input, forwardRef, NgZone, ChangeDetectionStrategy, ViewContainerRef } from '@angular/core';
import { IgxSeriesComponent } from "igniteui-angular-charts";
import { IgxSeriesViewerComponent } from "igniteui-angular-charts";
import { AngularRenderer, AngularWrapper } from "igniteui-angular-core";
import { TypeRegistrar } from "igniteui-angular-core";
import { XamGeographicMap } from './XamGeographicMap';
import { CollectionAdapter, toPoint, fromPoint, toRect, fromRect, ensureBool, ensureEnum, NamePatcher } from "igniteui-angular-core";
import { DataChartStylingDefaults } from "igniteui-angular-charts";
import { IgxDataContext } from "igniteui-angular-core";
import { delegateCombine } from "igniteui-angular-core";
import { IgxSeriesCollection } from "igniteui-angular-charts";
import { NotifyCollectionChangedAction } from "igniteui-angular-core";
import { IgxImageTilesReadyEventArgs } from './igx-image-tiles-ready-event-args';
import { IgxNumericXAxisComponent } from "igniteui-angular-charts";
import { IgxNumericYAxisComponent } from "igniteui-angular-charts";
import { MapResizeBehavior, MapResizeBehavior_$type } from './MapResizeBehavior';
export var IgxGeographicMapComponent_PROVIDERS = [{ provide: IgxSeriesViewerComponent, useExisting: forwardRef(function () { return IgxGeographicMapComponent; }) }];
/**
 * Represents the Infragistics IgxGeographicMapComponent control.
*/
var IgxGeographicMapComponent = /** @class */ (function (_super) {
    tslib_1.__extends(IgxGeographicMapComponent, _super);
    function IgxGeographicMapComponent(_renderer, _elRef, _ngZone, _componentFactoryResolver, _injector) {
        var _this = _super.call(this) || this;
        _this._renderer = _renderer;
        _this._elRef = _elRef;
        _this._ngZone = _ngZone;
        _this._componentFactoryResolver = _componentFactoryResolver;
        _this._injector = _injector;
        /**
         * The series actually present in the chart. Do not directly modify this array.
         * This array's contents can be modified by causing Angular to reproject the child content.
         * Or adding and removing series from the manual series collection on the series property.
         */
        _this.actualSeries = [];
        _this._series = null;
        _this._dataSource = null;
        _this._seriesAdapter = null;
        _this._defaultTooltips = null;
        _this._imageTilesReady = null;
        if (_this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(_this));
        }
        _this._zoneRunner = function (act) { return _this._ngZone.run(act); };
        _this._container = _renderer.createElement("div");
        _renderer.appendChild(_elRef.element.nativeElement, _this._container);
        _renderer.setStyle(_this._container, "display", "block");
        _renderer.setStyle(_this._container, "width", "100%");
        _renderer.setStyle(_this._container, "height", "100%");
        var root;
        root = _this._container;
        if (_this._container.nativeElement != null) {
            root = _this._container.nativeElement;
        }
        var ren = new AngularRenderer(root, _this._renderer, window.document, _this._ngZone, true, DataChartStylingDefaults);
        _this._wrapper = ren;
        var chart = _this.i;
        _this._chart = chart;
        chart.provideContainer(ren);
        ren.addSizeWatcher(function () {
            _this._chart.notifyContainerResized();
        });
        return _this;
    }
    IgxGeographicMapComponent_1 = IgxGeographicMapComponent;
    Object.defineProperty(IgxGeographicMapComponent.prototype, "height", {
        get: function () {
            return this._height;
        },
        set: function (value) {
            this._height = value;
            this._renderer.setStyle(this._elRef.element.nativeElement, "height", value);
            this._chart.notifyContainerResized();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGeographicMapComponent.prototype, "width", {
        get: function () {
            return this._width;
        },
        set: function (value) {
            this._width = value;
            this._renderer.setStyle(this._elRef.element.nativeElement, "width", value);
            this._chart.notifyContainerResized();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGeographicMapComponent.prototype, "legend", {
        /**
         * Gets or sets the legend used for the current chart.
        */
        get: function () {
            if (this.i.legend != null)
                return this.i.legend.externalObject;
        },
        set: function (v) {
            if (v != undefined && v != null)
                this.i.legend = v.i;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGeographicMapComponent.prototype, "series", {
        /**
         * A collection or manually added series for the chart.
        */
        get: function () {
            var _this = this;
            if (this._series === null) {
                var coll = new IgxSeriesCollection();
                var inner = coll._innerColl;
                inner.addListener(function (sender, e) {
                    switch (e.action) {
                        case NotifyCollectionChangedAction.Add:
                            _this._seriesAdapter.addManualItem(e.newItems.item(0));
                            break;
                        case NotifyCollectionChangedAction.Remove:
                            _this._seriesAdapter.removeManualItemAt(e.oldStartingIndex);
                            break;
                        case NotifyCollectionChangedAction.Replace:
                            _this._seriesAdapter.removeManualItemAt(e.oldStartingIndex);
                            _this._seriesAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                            break;
                        case NotifyCollectionChangedAction.Reset:
                            _this._seriesAdapter.clearManualItems();
                            break;
                    }
                });
                this._series = coll;
            }
            return this._series;
        },
        enumerable: true,
        configurable: true
    });
    IgxGeographicMapComponent.prototype.ngOnDestroy = function () {
        this._chart.destroy();
        this._wrapper.destroy();
    };
    IgxGeographicMapComponent.prototype.createImplementation = function () {
        return new XamGeographicMap();
    };
    Object.defineProperty(IgxGeographicMapComponent.prototype, "dataSource", {
        get: function () {
            return this._dataSource;
        },
        set: function (value) {
            this._dataSource = value;
            this.bindData();
        },
        enumerable: true,
        configurable: true
    });
    IgxGeographicMapComponent.prototype.bindData = function () {
        if (this.actualSeries && this.actualSeries.length > 0) {
            var currSeries = this.actualSeries;
            for (var i = 0; i < currSeries.length; i++) {
                currSeries[i].provideData(this._dataSource);
            }
        }
    };
    IgxGeographicMapComponent.prototype.ngAfterContentInit = function () {
        var _this = this;
        if (TypeRegistrar.isRegistered("IgxDataChartDefaultTooltipsComponent")) {
            var c = TypeRegistrar.get("IgxDataChartDefaultTooltipsComponent");
            var cf = this._componentFactoryResolver.resolveComponentFactory(c);
            var cr_1 = this._dynamicContent.createComponent(cf);
            //let cr = cf.create(this._injector);
            this._defaultTooltips = cr_1;
            cr_1.instance.onContentReady.subscribe(function () {
                _this._onDefaultTooltipsReady(cr_1);
            });
            //this._container.appendChild(cr.location.nativeElement);
        }
        this._seriesAdapter = new CollectionAdapter(this.contentSeries, this.i.series, this.actualSeries, function (c) { return c.i; }, function (i) {
            i.owner = _this;
            i._provideRenderer(_this._dataSource);
            i.provideData(_this._dataSource);
            //i.bindAxes(this.axes);
            _this._ensureDefaultTooltip(i);
            _this._ensureTooltipCreated(i);
        }, function (i) { i._provideRenderer(null); i.provideData(null); });
        this.i.notifyContainerResized();
    };
    IgxGeographicMapComponent.prototype._ensureTooltipCreated = function (series) {
        var _this = this;
        series._ensureTooltipCreated(function () { return _this.createTooltip(); }, function (ele) {
            var wrapper = new AngularWrapper(ele, _this._renderer, _this._ngZone);
            wrapper.updateToolTip = ele.updateToolTip;
            wrapper.hideToolTip = ele.hideToolTip;
            return wrapper;
        });
    };
    IgxGeographicMapComponent.prototype._ensureDefaultTooltip = function (series) {
        if (this._defaultTooltips == null) {
            return;
        }
        this._defaultTooltips.instance["ensureDefaultTooltip"](series);
    };
    IgxGeographicMapComponent.prototype._onDefaultTooltipsReady = function (cr) {
        if (this.actualSeries && this.actualSeries.length > 0) {
            var currSeries = this.actualSeries;
            for (var i = 0; i < currSeries.length; i++) {
                if (currSeries[i].showDefaultTooltip) {
                    this._ensureDefaultTooltip(currSeries[i]);
                }
            }
        }
    };
    IgxGeographicMapComponent.prototype.createTooltip = function () {
        if (!TypeRegistrar.isRegistered("IgxTooltipContainerComponent")) {
            return null;
        }
        var t = TypeRegistrar.get("IgxTooltipContainerComponent");
        var cf = this._componentFactoryResolver.resolveComponentFactory(t);
        //let cr = cf.create(this._injector);
        var cr = this._dynamicContent.createComponent(cf);
        var ele = cr.location.nativeElement;
        var self = this;
        ele.updateToolTip = function (c, isSubContent) {
            if (c.externalObject) {
                c = c.externalObject;
            }
            else {
                var ext = new IgxDataContext();
                ext._implementation = c;
                c = ext;
            }
            if (!isSubContent) {
                if (ele.parentElement != self._container) {
                    if (ele.parentElement != null) {
                        ele.parentElement.removeChild(ele);
                    }
                    self._container.appendChild(ele);
                }
            }
            else {
                c.isSubContent = true;
            }
            cr.instance.context = c;
            ele.style.display = "block";
            return true;
        };
        ele.hideToolTip = function () {
            ele.style.display = "none";
        };
        ele.style.display = "none";
        return cr;
    };
    Object.defineProperty(IgxGeographicMapComponent.prototype, "backgroundContent", {
        /**
         * An imagery to display behind all series, inside the viewport of the IgxGeographicMapComponent control.
        */
        get: function () {
            if (this.i.backgroundContent != null) {
                return this.i.backgroundContent.externalObject;
            }
            else {
                return null;
            }
        },
        set: function (v) {
            if (v != undefined && v != null) {
                this.i.backgroundContent = v.i;
            }
            else {
                this.i.backgroundContent = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGeographicMapComponent.prototype, "i", {
        /**
                                 * @hidden
                                 */
        get: function () {
            return this._implementation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGeographicMapComponent.prototype, "zoomable", {
        /**
     * Gets or sets zoomability of the current control
    */
        get: function () {
            return this.i.no;
        },
        set: function (v) {
            this.i.no = ensureBool(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGeographicMapComponent.prototype, "resizeBehavior", {
        /**
         * Gets or sets the behavior to use during resize.
        */
        get: function () {
            return this.i.nj;
        },
        set: function (v) {
            this.i.nj = ensureEnum(MapResizeBehavior_$type, v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGeographicMapComponent.prototype, "useWorldRectForZoomBounds", {
        /**
         * Gets or sets whether to use the uncoerced world rect to constrain the zoom bounds.
        */
        get: function () {
            return this.i.nn;
        },
        set: function (v) {
            this.i.nn = ensureBool(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGeographicMapComponent.prototype, "suppressZoomResetOnWorldRectChange", {
        /**
         * Gets or sets whether skip resetting the zoom when the world rect changes.
        */
        get: function () {
            return this.i.nm;
        },
        set: function (v) {
            this.i.nm = ensureBool(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGeographicMapComponent.prototype, "worldRect", {
        /**
         * Gets or sets the world bounding rectangle.
        */
        get: function () {
            return fromRect(this.i.pf);
        },
        set: function (v) {
            this.i.pf = toRect(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGeographicMapComponent.prototype, "actualWorldRect", {
        /**
         * Gets the actual value of the WorldRect.
        */
        get: function () {
            return fromRect(this.i.o3);
        },
        set: function (v) {
            this.i.o3 = toRect(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGeographicMapComponent.prototype, "xAxis", {
        /**
         * The X-axis for this IgxGeographicMap.Component
         * Under normal circumstances, this property should not be set in application code.  By default, it will be set to a numeric axis with a spherical mercator scaler.
        */
        get: function () {
            if (this.i.nc == null) {
                return null;
            }
            if (!this.i.nc.externalObject) {
                var e = IgxNumericXAxisComponent._createFromInternal(this.i.nc);
                if (e) {
                    e._implementation = this.i.nc;
                }
                this.i.nc.externalObject = e;
            }
            return this.i.nc.externalObject;
        },
        set: function (v) {
            if (v != null && this._stylingContainer && v._styling)
                v._styling(this._stylingContainer, this, this);
            v == null ? this.i.nc = null : this.i.nc = v.i;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGeographicMapComponent.prototype, "yAxis", {
        /**
         * The Y-axis for this IgxGeographicMap.Component
         * Under normal circumstances, this property should not be set in application code.  By default, it will be set to a numeric axis with a spherical mercator scaler.
        */
        get: function () {
            if (this.i.ne == null) {
                return null;
            }
            if (!this.i.ne.externalObject) {
                var e = IgxNumericYAxisComponent._createFromInternal(this.i.ne);
                if (e) {
                    e._implementation = this.i.ne;
                }
                this.i.ne.externalObject = e;
            }
            return this.i.ne.externalObject;
        },
        set: function (v) {
            if (v != null && this._stylingContainer && v._styling)
                v._styling(this._stylingContainer, this, this);
            v == null ? this.i.ne = null : this.i.ne = v.i;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGeographicMapComponent.prototype, "isMap", {
        /**
         * Indicates if this SeriesViewer is a map.
        */
        get: function () {
            return this.i.cx;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGeographicMapComponent.prototype, "windowScale", {
        /**
         * A number between 0 and 1 determining the scale of the horizontal/vertical zoom.
         * This property is effectively a shortcut to the Width/Height of the WindowRect property.
        */
        get: function () {
            return this.i.nt;
        },
        set: function (v) {
            this.i.nt = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGeographicMapComponent.prototype, "actualWindowScale", {
        /**
         * A number between 0 and 1 determining the scale of the horizontal/vertical zoom.
         * This property is effectively a shortcut to the Width/Height of the ActualWindowRect property.
        */
        get: function () {
            return this.i.ns;
        },
        set: function (v) {
            this.i.ns = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGeographicMapComponent.prototype, "zoomIsReady", {
        /**
         * Gets whether or not the control is ready for zooming
        */
        get: function () {
            return this.i.np;
        },
        enumerable: true,
        configurable: true
    });
    IgxGeographicMapComponent.prototype.findByName = function (name) {
        var baseResult = _super.prototype.findByName.call(this, name);
        if (baseResult) {
            return baseResult;
        }
        if (this.backgroundContent && this.backgroundContent.name && this.backgroundContent.name == name) {
            return this.backgroundContent;
        }
        return null;
    };
    IgxGeographicMapComponent.prototype._styling = function (container, component, parent) {
        _super.prototype._styling.call(this, container, component, parent);
        this._inStyling = true;
        if (this.xAxis && this.xAxis._styling) {
            this.xAxis._styling(container, component, this);
        }
        if (this.yAxis && this.yAxis._styling) {
            this.yAxis._styling(container, component, this);
        }
        this._inStyling = false;
    };
    IgxGeographicMapComponent.prototype.getCurrentActualWorldRect = function () {
        var iv = this.i.o7();
        return fromRect(iv);
    };
    /**
     * Given the current plot area of the control and a geographic region, get the WindowRect that would encompass that geographic region.
    
    * @param geographic  * The geographic area.
    */
    IgxGeographicMapComponent.prototype.getZoomRectFromGeoRect = function (geographic) {
        var iv = this.i.getZoomRectFromGeoRect(toRect(geographic));
        return fromRect(iv);
    };
    IgxGeographicMapComponent.prototype.updateZoomWindow = function (zoomWindow) {
        this.i.ol(toRect(zoomWindow));
    };
    IgxGeographicMapComponent.prototype.updateWorldRect = function (worldRect) {
        this.i.ok(toRect(worldRect));
    };
    /**
     * Given the current plot area of the control and a geographic region, get the WindowRect that would encompass that geographic region.
    
    * @param geographic  * The geographic area.
    */
    IgxGeographicMapComponent.prototype.getZoomFromGeographicRect = function (geographic) {
        var iv = this.i.getZoomFromGeographicRect(toRect(geographic));
        return fromRect(iv);
    };
    IgxGeographicMapComponent.prototype.convertGeographicToZoom = function (geographic, extraPixelPadding) {
        var iv = this.i.o4(toRect(geographic), extraPixelPadding);
        return fromRect(iv);
    };
    IgxGeographicMapComponent.prototype.getZoomFromGeographicPoints = function (northWest, southEast) {
        var iv = this.i.getZoomFromGeographicPoints(toPoint(northWest), toPoint(southEast));
        return fromRect(iv);
    };
    /**
     * Given a WindowRect and the current plot area, get the geographic region represented by that WindowRect.
    
    * @param windowRect  * The zoom area.
    */
    IgxGeographicMapComponent.prototype.getGeographicFromZoom = function (windowRect) {
        var iv = this.i.o9(toRect(windowRect));
        return fromRect(iv);
    };
    /**
     * Convert a pixel-based coordinate to a geographic coordinate.
    
    * @param pixelCoordinate  * A pixel-based coordinate
    */
    IgxGeographicMapComponent.prototype.getGeographicPoint = function (pixelCoordinate) {
        var iv = this.i.ov(toPoint(pixelCoordinate));
        return fromPoint(iv);
    };
    /**
     * Convert a geographic coordinate to a pixel-based coordinate.
    
    * @param geographicCoordinate  * A geographic coordinate
    */
    IgxGeographicMapComponent.prototype.getPixelPoint = function (geographicCoordinate) {
        var iv = this.i.ow(toPoint(geographicCoordinate));
        return fromPoint(iv);
    };
    /**
     * Convert a geographic coordinate to a pixel-based coordinate.
    
    * @param geographicCoordinate  * A geographic coordinate
    */
    IgxGeographicMapComponent.prototype.getWindowPoint = function (geographicCoordinate) {
        var iv = this.i.ox(toPoint(geographicCoordinate));
        return fromPoint(iv);
    };
    /**
     * Removes all cached tile images from the map imagery assigned to the map's background content.
    
    */
    IgxGeographicMapComponent.prototype.clearTileCache = function () {
        this.i.n8();
    };
    /**
     * Notifies the chart that the CSS styles in effect have been updated.
    
    */
    IgxGeographicMapComponent.prototype.styleUpdated = function () {
        this.i.og();
    };
    /**
     * Gets actual window scale for horizontal dimension of the control
    
    */
    IgxGeographicMapComponent.prototype.getActualWindowScaleHorizontal = function () {
        var iv = this.i.eg();
        return (iv);
    };
    /**
     * Gets actual window scale for vertical dimension of the control
    
    */
    IgxGeographicMapComponent.prototype.getActualWindowScaleVertical = function () {
        var iv = this.i.eh();
        return (iv);
    };
    /**
     * Calls for a deferred refresh to the GeographicMap's background.
    
    */
    IgxGeographicMapComponent.prototype.deferredRefresh = function () {
        this.i.deferredRefresh();
    };
    /**
     * Returns the chart visuals expressed as a ChartVisualData object.
    
    */
    IgxGeographicMapComponent.prototype.exportVisualData = function () {
        var iv = this.i.nw();
        return (iv);
    };
    /**
     * Zoom in to the geographic region specified, when possible (may need to wait for map to be initialized).
    
    * @param geographic  * The geographic region to zoom to.
    */
    IgxGeographicMapComponent.prototype.zoomToGeographic = function (geographic) {
        this.i.on(toRect(geographic));
    };
    Object.defineProperty(IgxGeographicMapComponent.prototype, "imageTilesReady", {
        /**
         * This event is fired whenever the image tiles transition from a loading state (e.g. some are fading in) to a loaded state.
        */
        get: function () {
            var _this = this;
            if (this._imageTilesReady == null) {
                this._imageTilesReady = new EventEmitter();
                this.i.imageTilesReady = delegateCombine(this.i.imageTilesReady, function (o, e) {
                    var outerArgs = new IgxImageTilesReadyEventArgs();
                    outerArgs._provideImplementation(e);
                    if (_this.beforeImageTilesReady) {
                        _this.beforeImageTilesReady(_this, outerArgs);
                    }
                    _this._imageTilesReady.emit({
                        sender: _this,
                        args: outerArgs
                    });
                });
            }
            return this._imageTilesReady;
        },
        enumerable: true,
        configurable: true
    });
    var IgxGeographicMapComponent_1;
    tslib_1.__decorate([
        ContentChildren(IgxSeriesComponent),
        tslib_1.__metadata("design:type", QueryList)
    ], IgxGeographicMapComponent.prototype, "contentSeries", void 0);
    tslib_1.__decorate([
        ViewChild("dynamicContent", { read: ViewContainerRef, static: true }),
        tslib_1.__metadata("design:type", ViewContainerRef)
    ], IgxGeographicMapComponent.prototype, "_dynamicContent", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String),
        tslib_1.__metadata("design:paramtypes", [String])
    ], IgxGeographicMapComponent.prototype, "height", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String),
        tslib_1.__metadata("design:paramtypes", [String])
    ], IgxGeographicMapComponent.prototype, "width", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object),
        tslib_1.__metadata("design:paramtypes", [Object])
    ], IgxGeographicMapComponent.prototype, "legend", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object),
        tslib_1.__metadata("design:paramtypes", [Object])
    ], IgxGeographicMapComponent.prototype, "dataSource", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], IgxGeographicMapComponent.prototype, "zoomable", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Number),
        tslib_1.__metadata("design:paramtypes", [Number])
    ], IgxGeographicMapComponent.prototype, "resizeBehavior", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], IgxGeographicMapComponent.prototype, "useWorldRectForZoomBounds", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], IgxGeographicMapComponent.prototype, "suppressZoomResetOnWorldRectChange", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object),
        tslib_1.__metadata("design:paramtypes", [Object])
    ], IgxGeographicMapComponent.prototype, "worldRect", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object),
        tslib_1.__metadata("design:paramtypes", [Object])
    ], IgxGeographicMapComponent.prototype, "actualWorldRect", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", IgxNumericXAxisComponent),
        tslib_1.__metadata("design:paramtypes", [IgxNumericXAxisComponent])
    ], IgxGeographicMapComponent.prototype, "xAxis", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", IgxNumericYAxisComponent),
        tslib_1.__metadata("design:paramtypes", [IgxNumericYAxisComponent])
    ], IgxGeographicMapComponent.prototype, "yAxis", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Number),
        tslib_1.__metadata("design:paramtypes", [Number])
    ], IgxGeographicMapComponent.prototype, "windowScale", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Number),
        tslib_1.__metadata("design:paramtypes", [Number])
    ], IgxGeographicMapComponent.prototype, "actualWindowScale", null);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", EventEmitter),
        tslib_1.__metadata("design:paramtypes", [])
    ], IgxGeographicMapComponent.prototype, "imageTilesReady", null);
    IgxGeographicMapComponent = IgxGeographicMapComponent_1 = tslib_1.__decorate([
        Component({
            selector: 'igx-geographic-map',
            template: "<ng-container #dynamicContent></ng-container>",
            changeDetection: ChangeDetectionStrategy.OnPush,
            providers: [{ provide: IgxSeriesViewerComponent, useExisting: forwardRef(function () { return IgxGeographicMapComponent_1; }) }],
            host: { 'class': 'igx-geographic-map ig-geographic-map' },
            styles: ["\n\t\t:host {\n\t\t\tdisplay: block;\n\t\t}\n\t"]
        }),
        tslib_1.__metadata("design:paramtypes", [Renderer2,
            ViewContainerRef,
            NgZone,
            ComponentFactoryResolver,
            Injector])
    ], IgxGeographicMapComponent);
    return IgxGeographicMapComponent;
}(IgxSeriesViewerComponent));
export { IgxGeographicMapComponent };
//# sourceMappingURL=igx-geographic-map-component.js.map